<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fraction fields · Nemo.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Nemo.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="about.html">About Nemo</a></li><li><a class="toctext" href="types.html">Types in Nemo</a></li><li><a class="toctext" href="constructors.html">Constructing mathematical objects in Nemo</a></li><li><span class="toctext">Rings</span><ul><li><a class="toctext" href="integer.html">Integers</a></li><li><a class="toctext" href="polynomial.html">Univariate polynomials</a></li><li><a class="toctext" href="series.html">Power series and Laurent series</a></li><li><a class="toctext" href="residue.html">Residue rings</a></li></ul></li><li><span class="toctext">Fields</span><ul><li class="current"><a class="toctext" href="fraction.html">Fraction fields</a><ul class="internal"><li><a class="toctext" href="#Fraction-functionality-1">Fraction functionality</a></li><li><a class="toctext" href="#Rational-enumeration-1">Rational enumeration</a></li></ul></li><li><a class="toctext" href="rational.html">Rationals</a></li><li><a class="toctext" href="arb.html">Real balls</a></li><li><a class="toctext" href="acb.html">Complex balls</a></li><li><a class="toctext" href="finitefield.html">Finite fields</a></li><li><a class="toctext" href="numberfield.html">Number field arithmetic</a></li><li><a class="toctext" href="padic.html">Padics</a></li></ul></li><li><a class="toctext" href="matrix.html">Matrices</a></li><li><a class="toctext" href="factor.html">Factorisation</a></li></ul></nav><article id="docs"><header><nav><ul><li>Fields</li><li><a href="fraction.html">Fraction fields</a></li></ul><a class="edit-page" href="https://github.com/Nemocas/Nemo.jl/blob/master/docs/src/fraction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Fraction fields</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Fraction-fields-1" href="#Fraction-fields-1">Fraction fields</a></h1><p>Nemo allows the creation of fraction fields over any ring <span>$R$</span>. We don&#39;t require <span>$R$</span> to be an integral domain, however no attempt is made to deal with the general case. Two fractions <span>$a/b$</span> and <span>$c/d$</span> are equal in Nemo iff <span>$ad = bc$</span>. Thus, in practice, a greatest common divisor function is currently required for the ring <span>$R$</span>.</p><p>In order to make the representation <span>$a/b$</span> unique for printing, we have a notion of canonical unit for elements of a ring <span>$R$</span>. When canonicalising <span>$a/b$</span>, each of the elements <span>$a$</span> and <span>$b$</span> is first divided by the canonical unit of <span>$b$</span>.</p><p>The <code>canonical_unit</code> function is defined for elements of every Nemo ring. It must have the properties</p><pre><code class="language-none">canonical_unit(u) == u
canonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)</code></pre><p>for any unit <span>$u$</span> of the ring in question, and <span>$a$</span> and <span>$b$</span> arbitrary elements of the ring.</p><p>For example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.</p><p>The canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.</p><p>There are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists (provided by AbstractAlgebra.jl), and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.</p><p>The following table shows each of the fraction types available in Nemo, the base ring <span>$R$</span>, and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).</p><table><tr><th>Base ring</th><th>Library</th><th>Element type</th><th>Parent type</th></tr><tr><td>Generic ring <span>$R$</span></td><td>AbstractAlgebra.jl</td><td><code>Generic.Frac{T}</code></td><td><code>Generic.FracField{T}</code></td></tr><tr><td><span>$\mathbb{Z}$</span></td><td>Flint</td><td><code>fmpq</code></td><td><code>FlintRationalField</code></td></tr></table><p>All fraction element types belong to the abstract type <code>FracElem</code> and all of the fraction field types belong to the abstract type <code>FracField</code>. This enables one to write generic functions that can accept any Nemo fraction type.</p><h2><a class="nav-anchor" id="Fraction-functionality-1" href="#Fraction-functionality-1">Fraction functionality</a></h2><p>All fraction types in Nemo implement the AbstractAlgebra.jl fraction field interface:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/fraction_fields.html">https://nemocas.github.io/AbstractAlgebra.jl/fraction_fields.html</a></p><p>In addition, generic fractions fields are implemented in AbstractAlgebra.jl, with the following functionality:</p><p><a href="https://nemocas.github.io/AbstractAlgebra.jl/fraction.html">https://nemocas.github.io/AbstractAlgebra.jl/fraction.html</a></p><p>All fraction types in Nemo also implement this generic functionality.</p><h3><a class="nav-anchor" id="Basic-manipulation-1" href="#Basic-manipulation-1">Basic manipulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.abs-Tuple{Nemo.fmpq}" href="#Base.abs-Tuple{Nemo.fmpq}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">abs(a::fmpq)</code></pre><blockquote><p>Return the absolute value of <span>$a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.height-Tuple{Nemo.fmpq}" href="#Nemo.height-Tuple{Nemo.fmpq}"><code>Nemo.height</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">height(a::fmpq)</code></pre><blockquote><p>Return the height of the fraction <span>$a$</span>, namely the largest of the absolute values of the numerator and denominator.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.height_bits-Tuple{Nemo.fmpq}" href="#Nemo.height_bits-Tuple{Nemo.fmpq}"><code>Nemo.height_bits</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">height_bits(a::fmpq)</code></pre><blockquote><p>Return the number of bits of the height of the fraction <span>$a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;&lt;-Tuple{Nemo.fmpq,Int64}" href="#Base.:&lt;&lt;-Tuple{Nemo.fmpq,Int64}"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&lt;&lt;(a::fmpq, b::Int)</code></pre><blockquote><p>Return <span>$2^b\times a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&gt;&gt;-Tuple{Nemo.fmpq,Int64}" href="#Base.:&gt;&gt;-Tuple{Nemo.fmpq,Int64}"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">&lt;&lt;(a::fmpq, b::Int)</code></pre><blockquote><p>Return <span>$2^b/a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L385">source</a></section><p>Rational fractions can be compared with each other and with integers. Julia provides the full range of operators <span>$&lt;, &gt;, \leq, \geq$</span> which depend on the following functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless-Tuple{Nemo.fmpq,Nemo.fmpq}" href="#Base.isless-Tuple{Nemo.fmpq,Nemo.fmpq}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpq, b::fmpq)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless-Tuple{Integer,Nemo.fmpq}" href="#Base.isless-Tuple{Integer,Nemo.fmpq}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::Integer, b::fmpq)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless-Tuple{Nemo.fmpq,Integer}" href="#Base.isless-Tuple{Nemo.fmpq,Integer}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpq, b::Integer)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless-Tuple{Nemo.fmpq,Nemo.fmpz}" href="#Base.isless-Tuple{Nemo.fmpq,Nemo.fmpz}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpq, b::fmpz)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L342">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isless-Tuple{Nemo.fmpz,Nemo.fmpq}" href="#Base.isless-Tuple{Nemo.fmpz,Nemo.fmpq}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isless(a::fmpz, b::fmpq)</code></pre><blockquote><p>Return <code>true</code> if <span>$a &lt; b$</span>, otherwise return <code>false</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L352">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">d = abs(ZZ(11)//3)
4 &lt;= ZZ(7)//ZZ(3)</code></pre><h3><a class="nav-anchor" id="Modular-arithmetic-1" href="#Modular-arithmetic-1">Modular arithmetic</a></h3><p>The following functions are available for rationals.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mod-Tuple{Nemo.fmpq,Nemo.fmpz}" href="#Base.mod-Tuple{Nemo.fmpq,Nemo.fmpz}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mod(a::fmpq, b::fmpz)</code></pre><blockquote><p>Return <span>$a \pmod{b}$</span> where <span>$b$</span> is an integer coprime to the denominator of <span>$a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L480">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.mod-Tuple{Nemo.fmpq,Integer}" href="#Base.mod-Tuple{Nemo.fmpq,Integer}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mod(a::fmpq, b::Integer)</code></pre><blockquote><p>Return <span>$a \pmod{b}$</span> where <span>$b$</span> is an integer coprime to the denominator of <span>$a$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L492">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = -fmpz(2)//3
b = fmpz(1)//2

c = mod(a, 7)
d = mod(b, fmpz(5))</code></pre><h3><a class="nav-anchor" id="Rational-Reconstruction-1" href="#Rational-Reconstruction-1">Rational Reconstruction</a></h3><p>Rational reconstruction is available for rational numbers.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.reconstruct-Tuple{Nemo.fmpz,Nemo.fmpz}" href="#Nemo.reconstruct-Tuple{Nemo.fmpz,Nemo.fmpz}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::fmpz, b::fmpz)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L528">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.reconstruct-Tuple{Nemo.fmpz,Integer}" href="#Nemo.reconstruct-Tuple{Nemo.fmpz,Integer}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::fmpz, b::Integer)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.reconstruct-Tuple{Integer,Nemo.fmpz}" href="#Nemo.reconstruct-Tuple{Integer,Nemo.fmpz}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::Integer, b::fmpz)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.reconstruct-Tuple{Integer,Integer}" href="#Nemo.reconstruct-Tuple{Integer,Integer}"><code>Nemo.reconstruct</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reconstruct(a::Integer, b::Integer)</code></pre><blockquote><p>Attempt to find a rational number <span>$n/d$</span> such that <span>$0 \leq |n| \leq \lfloor\sqrt{m/2}\rfloor$</span> and <span>$0 &lt; d \leq \lfloor\sqrt{m/2}\rfloor$</span> such that gcd<span>$(n, d) = 1$</span> and <span>$a \equiv nd^{-1} \pmod{m}$</span>. If no solution exists, an exception is thrown.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L562">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = reconstruct(7, 13)
b = reconstruct(fmpz(15), 31)
c = reconstruct(fmpz(123), fmpz(237))</code></pre><h2><a class="nav-anchor" id="Rational-enumeration-1" href="#Rational-enumeration-1">Rational enumeration</a></h2><p>Various methods exist to enumerate rationals.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.next_minimal-Tuple{Nemo.fmpq}" href="#Nemo.next_minimal-Tuple{Nemo.fmpq}"><code>Nemo.next_minimal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_minimal(a::fmpq)</code></pre><blockquote><p>Given <span>$x$</span>, returns the next rational number in the sequence obtained by enumerating all positive denominators <span>$q$</span>, and for each <span>$q$</span> enumerating the numerators <span>$1 \le p &lt; q$</span> in order and generating both <span>$p/q$</span> and <span>$q/p$</span>, but skipping all gcd<span>$(p,q) \neq 1$</span>. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being <span>$0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, \ldots$</span>. This enumeration produces the rational numbers in order of minimal height. It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If <span>$x &lt; 0$</span> we throw a <code>DomainError()</code>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.next_signed_minimal-Tuple{Nemo.fmpq}" href="#Nemo.next_signed_minimal-Tuple{Nemo.fmpq}"><code>Nemo.next_signed_minimal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_signed_minimal(a::fmpq)</code></pre><blockquote><p>Given a signed rational number <span>$x$</span> assumed to be in canonical form, returns the next element in the minimal-height sequence generated by <code>next_minimal</code> but with negative numbers interleaved. The sequence begins <span>$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots$</span>. Starting with zero, this generates every rational number once and only once, in order of minimal height.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L596">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.next_calkin_wilf-Tuple{Nemo.fmpq}" href="#Nemo.next_calkin_wilf-Tuple{Nemo.fmpq}"><code>Nemo.next_calkin_wilf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_calkin_wilf(a::fmpq)</code></pre><blockquote><p>Given <span>$x$</span> return the next number in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being <span>$0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \ldots$</span>. Despite the appearance of the initial entries, the Calkin-Wilf enumeration does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L612">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.next_signed_calkin_wilf-Tuple{Nemo.fmpq}" href="#Nemo.next_signed_calkin_wilf-Tuple{Nemo.fmpq}"><code>Nemo.next_signed_calkin_wilf</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">next_signed_calkin_wilf(a::fmpq)</code></pre><blockquote><p>Given a signed rational number <span>$x$</span> returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins <span>$0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \ldots$</span>. Starting with zero, this generates every rational number once and only once, but not in order of minimal height.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L631">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">next_minimal(fmpz(2)//3)
next_signed_minimal(-fmpz(21)//31)
next_calkin_wilf(fmpz(321)//113)
next_signed_calkin_wilf(-fmpz(51)//(17))</code></pre><h3><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h3><p>The following special functions are available for specific rings in Nemo.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.harmonic-Tuple{Int64}" href="#Nemo.harmonic-Tuple{Int64}"><code>Nemo.harmonic</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">harmonic(n::Int)</code></pre><blockquote><p>Computes the harmonic number <span>$H_n = 1 + 1/2 + 1/3 + \cdots + 1/n$</span>. Table lookup is used for <span>$H_n$</span> whose numerator and denominator fit in a single limb. For larger <span>$n$</span>, a divide and conquer strategy is used.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L652">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.bernoulli-Tuple{Int64}" href="#Nemo.bernoulli-Tuple{Int64}"><code>Nemo.bernoulli</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bernoulli(n::Int)</code></pre><blockquote><p>Computes the Bernoulli number <span>$B_n$</span> for nonnegative <span>$n$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L665">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.bernoulli_cache-Tuple{Int64}" href="#Nemo.bernoulli_cache-Tuple{Int64}"><code>Nemo.bernoulli_cache</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">bernoulli_cache(n::Int)</code></pre><blockquote><p>Precomputes and caches all the Bernoulli numbers up to <span>$B_n$</span>. This is much faster than repeatedly calling <code>bernoulli(k)</code>. Once cached, subsequent calls to <code>bernoulli(k)</code> for any <span>$k \le n$</span> will read from the cache, making them virtually free.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L676">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.dedekind_sum-Tuple{Nemo.fmpz,Nemo.fmpz}" href="#Nemo.dedekind_sum-Tuple{Nemo.fmpz,Nemo.fmpz}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::fmpz, k::fmpz)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L689">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.dedekind_sum-Tuple{Nemo.fmpz,Integer}" href="#Nemo.dedekind_sum-Tuple{Nemo.fmpz,Integer}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::fmpz, k::Integer)</code></pre><blockquote><p>Computes the Dedekind sum <span>$s(h,k)$</span> for arbitrary <span>$h$</span> and <span>$k$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L699">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.dedekind_sum-Tuple{Integer,Nemo.fmpz}" href="#Nemo.dedekind_sum-Tuple{Integer,Nemo.fmpz}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::Integer, k::fmpz)</code></pre><blockquote><p>Computes the Dedekind sum <span>$s(h,k)$</span> for arbitrary <span>$h$</span> and <span>$k$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L705">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Nemo.dedekind_sum-Tuple{Integer,Integer}" href="#Nemo.dedekind_sum-Tuple{Integer,Integer}"><code>Nemo.dedekind_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dedekind_sum(h::Integer, k::Integer)</code></pre><blockquote><p>Computes the Dedekind sum <span>$s(h,k)$</span> for arbitrary <span>$h$</span> and <span>$k$</span>.</p></blockquote></div><a class="source-link" target="_blank" href="https://github.com/Nemocas/Nemo.jl/blob/8ea012597690e012b8302d8c62fa23c00d96373c/src/flint/fmpq.jl#L711">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia">a = harmonic(12)

b = dedekind_sum(12, 13)
c = dedekind_sum(-120, fmpz(1305))

d = bernoulli(12)

bernoulli_cache(100)
e = bernoulli(100)</code></pre><footer><hr/><a class="previous" href="residue.html"><span class="direction">Previous</span><span class="title">Residue rings</span></a><a class="next" href="rational.html"><span class="direction">Next</span><span class="title">Rationals</span></a></footer></article></body></html>

{
    "docs": [
        {
            "location": "/", 
            "text": "Nemo\n\n\nIntroduction\n\n\nNemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.\n\n\n\n\nhttp://nemocas.org\n (Website)\n\n\nhttps://github.com/Nemocas/Nemo.jl\n (Source code)\n\n\nhttp://nemo.readthedocs.org/en/latest/\n (Online documentation)\n\n\n\n\nThe features of Nemo so far include:\n\n\n\n\nMultiprecision integers and rationals\n\n\nIntegers modulo n\n\n\np-adic numbers\n\n\nFinite fields (prime and non-prime order)\n\n\nNumber field arithmetic\n\n\nMaximal orders of number fields\n\n\nArithmetic of ideals in maximal orders\n\n\nArbitrary precision real and complex balls\n\n\nUnivariate polynomials and matrices over the above\n\n\nGeneric polynomials, power series, fraction fields, residue rings and matrices\n\n\n\n\nInstallation\n\n\nTo use Nemo we require Julia 0.4 or higher. Please see\n\nhttp://julialang.org/downloads\n for instructions on how to obtain\njulia for your system.\n\n\nAt the Julia prompt simply type\n\n\njulia\n Pkg.add(\nNemo\n)\njulia\n Pkg.build(\nNemo\n)\n\n\n\n\nAlternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https:://cloud.sagemath.com/).\n\n\nQuick start\n\n\nHere are some examples of using Nemo.\n\n\nThis example computes recursive univariate polynomials.\n\n\njulia\n using Nemo\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia\n T, z = PolynomialRing(S, \nz\n)\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia\n f = x + y + z + 1\nz+(y+(x+1))\n\njulia\n p = f^30; # semicolon supresses output\n\njulia\n @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)\n\n\n\n\nHere is an example using generic recursive ring constructions.\n\n\njulia\n using Nemo\n\njulia\n R, x = FiniteField(7, 11, \nx\n)\n(Finite field of degree 11 over F_7,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia\n T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia\n U, z = PolynomialRing(T, \nz\n)\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia\n f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia\n g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia\n s = f^12;\n\njulia\n t = (s + g)^12;\n\njulia\n @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)\n\n\n\n\nHere is an example using matrices.\n\n\njulia\n using Nemo\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia\n @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)\n\n\n\n\nAnd here is an example with power series.\n\n\njulia\n using Nemo\n\njulia\n R, x = QQ[\nx\n]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia\n S, t = PowerSeriesRing(R, 100, \nt\n)\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia\n u = t + O(t^100)\nt+O(t^100)\n\njulia\n @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/#introduction", 
            "text": "Nemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.   http://nemocas.org  (Website)  https://github.com/Nemocas/Nemo.jl  (Source code)  http://nemo.readthedocs.org/en/latest/  (Online documentation)   The features of Nemo so far include:   Multiprecision integers and rationals  Integers modulo n  p-adic numbers  Finite fields (prime and non-prime order)  Number field arithmetic  Maximal orders of number fields  Arithmetic of ideals in maximal orders  Arbitrary precision real and complex balls  Univariate polynomials and matrices over the above  Generic polynomials, power series, fraction fields, residue rings and matrices", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Nemo we require Julia 0.4 or higher. Please see http://julialang.org/downloads  for instructions on how to obtain\njulia for your system.  At the Julia prompt simply type  julia  Pkg.add( Nemo )\njulia  Pkg.build( Nemo )  Alternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https:://cloud.sagemath.com/).", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here are some examples of using Nemo.  This example computes recursive univariate polynomials.  julia  using Nemo\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia  T, z = PolynomialRing(S,  z )\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia  f = x + y + z + 1\nz+(y+(x+1))\n\njulia  p = f^30; # semicolon supresses output\n\njulia  @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)  Here is an example using generic recursive ring constructions.  julia  using Nemo\n\njulia  R, x = FiniteField(7, 11,  x )\n(Finite field of degree 11 over F_7,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia  T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia  U, z = PolynomialRing(T,  z )\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia  f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia  g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia  s = f^12;\n\njulia  t = (s + g)^12;\n\njulia  @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)  Here is an example using matrices.  julia  using Nemo\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia  @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)  And here is an example with power series.  julia  using Nemo\n\njulia  R, x = QQ[ x ]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia  S, t = PowerSeriesRing(R, 100,  t )\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia  u = t + O(t^100)\nt+O(t^100)\n\njulia  @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Quick start"
        }, 
        {
            "location": "/about/", 
            "text": "Nemo\n\n\nWhat is Nemo?\n\n\nNemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering\n\n\n\n\nCommutative Algebra\n\n\nNumber Theory\n\n\nGroup Theory\n\n\n\n\nNemo consists of wrappers of specialised C/C++ libraries:\n\n\n\n\nFlint    [http://flintlib.org/]\n\n\nArb      [http://fredrikj.net/arb/]\n\n\nAntic    [https://github.com/wbhart/antic/]\n\n\nSingular [https://www.singular.uni-kl.de/]\n\n\nPari     [http://pari.math.u-bordeaux.fr/]\n\n\n\n\nIt will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.\n\n\nNemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include\n\n\n\n\nUnivariate polynomial rings\n\n\nPower series rings\n\n\nResidue rings (modulo principal ideals)\n\n\nFraction fields\n\n\nMatrices\n\n\n\n\nWhy Julia?\n\n\nJulia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.\n\n\nThe benefits of Julia include\n\n\n\n\nFamiliar imperative syntax\n\n\nJIT compilation (provides near native performance, even for highly generic code)\n\n\nREPL console (cuts down on development time)\n\n\nParametric types (allows for fast generic constructions over other data types)\n\n\nPowerful metaprogramming facilities\n\n\nOperator overloading\n\n\nMultiple dispatch (dispatch on every argument of a function)\n\n\nEfficient native C interface (no wrapper overhead)\n\n\nExperimental C++ interface\n\n\nDynamic type inference\n\n\nBuilt-in bignums\n\n\nAble to be embedded in C programs\n\n\nHigh performance collection types (dictionaries, iterators, arrays, etc.)\n\n\nJupyter support (for web based notebooks)\n\n\n\n\nThe main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "About Nemo"
        }, 
        {
            "location": "/about/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/about/#what-is-nemo", 
            "text": "Nemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering   Commutative Algebra  Number Theory  Group Theory   Nemo consists of wrappers of specialised C/C++ libraries:   Flint    [http://flintlib.org/]  Arb      [http://fredrikj.net/arb/]  Antic    [https://github.com/wbhart/antic/]  Singular [https://www.singular.uni-kl.de/]  Pari     [http://pari.math.u-bordeaux.fr/]   It will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.  Nemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include   Univariate polynomial rings  Power series rings  Residue rings (modulo principal ideals)  Fraction fields  Matrices", 
            "title": "What is Nemo?"
        }, 
        {
            "location": "/about/#why-julia", 
            "text": "Julia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.  The benefits of Julia include   Familiar imperative syntax  JIT compilation (provides near native performance, even for highly generic code)  REPL console (cuts down on development time)  Parametric types (allows for fast generic constructions over other data types)  Powerful metaprogramming facilities  Operator overloading  Multiple dispatch (dispatch on every argument of a function)  Efficient native C interface (no wrapper overhead)  Experimental C++ interface  Dynamic type inference  Built-in bignums  Able to be embedded in C programs  High performance collection types (dictionaries, iterators, arrays, etc.)  Jupyter support (for web based notebooks)   The main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "Why Julia?"
        }, 
        {
            "location": "/types/", 
            "text": "Types in Nemo\n\n\nOn this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations. \n\n\nIn contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.\n\n\nIntroduction\n\n\nJulia provides two levels of types that we make use of\n\n\n\n\nabstract types\n\n\nconcrete types\n\n\n\n\nConcrete types are just like the usual types everyone is familiar with from C or C++.\n\n\nAbstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.\n\n\nTo write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter, \nT\n say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter \nT\n must belong to.\n\n\nWe use the symbol \n:\n in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type \nInt64\n for 64 bit machine integers belongs to the Julia abstract type\n\nInteger\n. Thus \nInt \n: Integer\n returns \ntrue\n.\n\n\nHere is some Julia code illustrating this with a more complex example. We create an abstract type called\n\nShape\n and two user defined concrete types \nsquare\n and \ncircle\n belonging to \nShape\n. We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type \nT\n belonging to the abstract type \nShape\n.\n\n\nNote that in the type definitions of \nsquare\n and \ncircle\n we specify that those types belong to the\nabstract type \nShape\n using the \n:\n operator.\n\n\nabstract Shape\n\ntype square \n: Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle \n: Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T \n: Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)\n\n\n\n\nThe abstract type hierarchy in Nemo\n\n\nAbstract types in Julia can also belong to one another in a hierarchy. For example, the \nNemo.Field\n\nabstract type belongs to the \nNemo.Ring\n abstract type. An object representing a field in Nemo has type\nbelonging to \nNemo.Field\n. But because we define the inclusion \nNemo.Field \n: Nemo.Ring\n in Nemo, the\ntype of such an object also automatically belongs to \nNemo.Ring\n. This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.\n\n\nIn Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type\n\nPolynomialRing\n to model a generic polynomial ring, and elements of that polynomial ring would have\ntype \nPoly\n. \n\n\nIn order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains. \n\n\n\n\nAll objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.\n\n\nWhy types aren't enough\n\n\nNaively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.\n\n\nAs an example, consider the ring \nR = \\mathbb{Z}/n\\mathbb{Z}\n for a multiprecision integer \nn\n. If we\nwere to model the ring \nR\n as a type, then the type would somehow need to contain the modulus\n\nn\n. This is not possible in Julia, and in fact it is not desirable either.\n\n\nJulia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings \n\\mathbb{Z}/n\\mathbb{Z}\n would be needed\nand every function we use would be recompiled over and over for each different \nn\n. This would result \nin a huge delay as the compiler is invoked many times.\n\n\nFor this reason, the modulus \nn\n needs to be attached to the \nelements\n of the ring, not to type\nassociated with those elements.\n\n\nBut now we have a problem. How do we create new elements of the ring \n\\mathbb{Z}/n\\mathbb{Z}\n given only\nthe type? Suppose all rings \n\\mathbb{Z}/n\\mathbb{Z}\n were represented by the same type \nZmod\n say. How\nwould we create \na = 3 \\pmod{7}\n? We could not write \na = Zmod(3)\n since the modulus \n7\n is not contained\nin the type \nZmod\n.\n\n\nWe could of course use the notation \na = Zmod(3, 7)\n, but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as \na = ZZ(7)\n and cases where they take a modulus, such as \na = Zmod(3, 7)\n.\n\n\nThe way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called \nparent\n objects can contain extra information,\nsuch as the modulus \nn\n. \n\n\nIn order to create new elements of \n\\mathbb{Z}/n\\mathbb{Z}\n as above, we overload the \ncall\n operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.\n\n\nIn the following Nemo example, we create the parent object \nR\n corresponding to the ring\n\n\\mathbb{Z}/7\\mathbb{Z}\n. We then create a new element \na\n of this ring by calling the parent object\n\nR\n, just as though \nR\n were a type with a constructor accepting an \nInt\n parameter. \n\n\nR = ResidueRing(ZZ, 7)\na = R(3)\n\n\n\n\nThis example creates the element \na = 3 \\pmod{7}\n. \n\n\nThe important point is that unlike a type, a parent object such as \nR\n can contain additional information\nthat a type cannot contain, such as the modulus \n7\n of the ring in this example, or context objects\nrequired by C libraries in other examples.\n\n\nMore complex example of parent objects\n\n\nHere is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.\n\n\njulia\n using Nemo\n\njulia\n R, x = ZZ[\nx\n]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia\n typeof(R)\nNemo.FmpzPolyRing\n\njulia\n typeof(f)\nNemo.fmpz_poly\n\njulia\n parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia\n typeof(R) \n: FmpzPolyRing\ntrue\n\njulia\n typeof(f) \n: PolyElem\ntrue\n\njulia\n parent(f) == R\ntrue\n\n\n\n\nConcrete types in Nemo\n\n\nFinally we come to all the concrete types in Nemo. \n\n\nThese are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).\n\n\nBelow we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess. \n\n\nFor example, \nfmpz\n belongs to the abstract type \nRingElem\n and \nFlintIntegerRing\n belongs to \nRing\n.\nSimilarly \nPoly{T}\n belongs to \nPolyElem\n whereas \nPolynomialRing{T}\n belongs to \nRing\n. We also have\nthat \nfmpz_poly\n belongs to \nPolyElem\n and \nFmpzPolyRing\n belongs to \nRing\n, and so on.\n\n\nAll the generic types are parameterised by a type \nT\n which is the type of the \nelements\n of the ring\nthey are defined over. For example, a polynomial ring over the Flint integers \nfmpz\n would have type\n\nPolynomialRing{fmpz}\n, thus in that example the type parameter \nT\n would be instantiated as \nfmpz\n.\n\n\n\n\n\n\nGeneric\n\n\n\n\nPoly{T}\n (\nPolynomialRing{T}\n)\n\n\nPowerSeries{T}\n (\nPowerSeriesRing{T}\n)\n\n\nResidue{T}\n (\nResidueRing{T}\n)\n\n\nFraction{T}\n (\nFractionField{T}\n)\n\n\nMat{T}\n (\nMatrixSpace{T}\n)\n\n\n\n\n\n\n\n\nFlint\n\n\n\n\nfmpz\n (\nFlintIntegerRing\n)\n\n\nfmpq\n (\nFlintRationalField\n)\n\n\nfq_nmod\n (\nFqNmodFiniteField\n)\n\n\nfq\n (\nFqFiniteField\n)\n\n\npadic\n (\nFlintPadicField\n)\n\n\nfmpz_poly\n (\nFmpzPolyRing\n)\n\n\nfmpq_poly\n (\nFmpqPolyRing\n)\n\n\nnmod_poly\n (\nNmodPolyRing\n)\n\n\nfmpz_mod_poly\n (\nFmpzModPolyRing\n)\n\n\nfq_poly\n (\nFqPolyRing\n)\n\n\nfq_nmod_poly\n (\nFqNmodPolyRing\n)\n\n\nfmpz_series\n (\nFmpzSeriesRing\n)\n\n\nfmpq_series\n (\nFmpqSeriesRing\n)\n\n\nfmpz_mod_series\n (\nFmpzModSeriesRing\n)\n\n\nfq_nmod_series\n (\nFqNmodSeriesRing\n)\n\n\nfq_series\n (\nFqSeriesRing\n)\n\n\nfmpz_mat\n (\nFmpzMatSpace\n)\n\n\nnmod_mat\n (\nNmodMatSpace\n)\n\n\nperm\n (\nFlintPermGroup\n)\n\n\n\n\n\n\n\n\nAntic\n\n\n\n\nnf_elem\n (\nAnticNumberField\n)\n\n\n\n\n\n\n\n\nArb\n\n\n\n\narb\n (\nArbField\n)\n\n\nacb\n (\nAcbField\n)\n\n\n\n\n\n\n\n\nPari\n\n\n\n\npari_int\n (\nPariIntegerRing\n)\n\n\npari_rat\n (\nPariRationalField\n)\n\n\npari_vec{T}\n (\nPariVector{T}\n)\n\n\npari_poly{T}\n (\nPariPolyRing{T}\n)\n\n\npari_polmod{T}\n (\nPariPolModRing{T}\n)\n\n\npari_maximal_order_elem\n (\nPariMaximalOrder\n)\n\n\nPariIdeal\n (\nPariIdealSet\n)\n\n\nno element type (\nPariNumberField\n)\n\n\nPariFactor{T}\n (no parent type)", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#types-in-nemo", 
            "text": "On this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations.   In contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#introduction", 
            "text": "Julia provides two levels of types that we make use of   abstract types  concrete types   Concrete types are just like the usual types everyone is familiar with from C or C++.  Abstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.  To write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter,  T  say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter  T  must belong to.  We use the symbol  :  in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type  Int64  for 64 bit machine integers belongs to the Julia abstract type Integer . Thus  Int  : Integer  returns  true .  Here is some Julia code illustrating this with a more complex example. We create an abstract type called Shape  and two user defined concrete types  square  and  circle  belonging to  Shape . We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type  T  belonging to the abstract type  Shape .  Note that in the type definitions of  square  and  circle  we specify that those types belong to the\nabstract type  Shape  using the  :  operator.  abstract Shape\n\ntype square  : Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle  : Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T  : Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)", 
            "title": "Introduction"
        }, 
        {
            "location": "/types/#the-abstract-type-hierarchy-in-nemo", 
            "text": "Abstract types in Julia can also belong to one another in a hierarchy. For example, the  Nemo.Field \nabstract type belongs to the  Nemo.Ring  abstract type. An object representing a field in Nemo has type\nbelonging to  Nemo.Field . But because we define the inclusion  Nemo.Field  : Nemo.Ring  in Nemo, the\ntype of such an object also automatically belongs to  Nemo.Ring . This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.  In Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type PolynomialRing  to model a generic polynomial ring, and elements of that polynomial ring would have\ntype  Poly .   In order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains.    All objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.", 
            "title": "The abstract type hierarchy in Nemo"
        }, 
        {
            "location": "/types/#why-types-arent-enough", 
            "text": "Naively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.  As an example, consider the ring  R = \\mathbb{Z}/n\\mathbb{Z}  for a multiprecision integer  n . If we\nwere to model the ring  R  as a type, then the type would somehow need to contain the modulus n . This is not possible in Julia, and in fact it is not desirable either.  Julia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings  \\mathbb{Z}/n\\mathbb{Z}  would be needed\nand every function we use would be recompiled over and over for each different  n . This would result \nin a huge delay as the compiler is invoked many times.  For this reason, the modulus  n  needs to be attached to the  elements  of the ring, not to type\nassociated with those elements.  But now we have a problem. How do we create new elements of the ring  \\mathbb{Z}/n\\mathbb{Z}  given only\nthe type? Suppose all rings  \\mathbb{Z}/n\\mathbb{Z}  were represented by the same type  Zmod  say. How\nwould we create  a = 3 \\pmod{7} ? We could not write  a = Zmod(3)  since the modulus  7  is not contained\nin the type  Zmod .  We could of course use the notation  a = Zmod(3, 7) , but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as  a = ZZ(7)  and cases where they take a modulus, such as  a = Zmod(3, 7) .  The way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called  parent  objects can contain extra information,\nsuch as the modulus  n .   In order to create new elements of  \\mathbb{Z}/n\\mathbb{Z}  as above, we overload the  call  operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.  In the following Nemo example, we create the parent object  R  corresponding to the ring \\mathbb{Z}/7\\mathbb{Z} . We then create a new element  a  of this ring by calling the parent object R , just as though  R  were a type with a constructor accepting an  Int  parameter.   R = ResidueRing(ZZ, 7)\na = R(3)  This example creates the element  a = 3 \\pmod{7} .   The important point is that unlike a type, a parent object such as  R  can contain additional information\nthat a type cannot contain, such as the modulus  7  of the ring in this example, or context objects\nrequired by C libraries in other examples.", 
            "title": "Why types aren't enough"
        }, 
        {
            "location": "/types/#more-complex-example-of-parent-objects", 
            "text": "Here is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.  julia  using Nemo\n\njulia  R, x = ZZ[ x ]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia  typeof(R)\nNemo.FmpzPolyRing\n\njulia  typeof(f)\nNemo.fmpz_poly\n\njulia  parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia  typeof(R)  : FmpzPolyRing\ntrue\n\njulia  typeof(f)  : PolyElem\ntrue\n\njulia  parent(f) == R\ntrue", 
            "title": "More complex example of parent objects"
        }, 
        {
            "location": "/types/#concrete-types-in-nemo", 
            "text": "Finally we come to all the concrete types in Nemo.   These are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).  Below we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess.   For example,  fmpz  belongs to the abstract type  RingElem  and  FlintIntegerRing  belongs to  Ring .\nSimilarly  Poly{T}  belongs to  PolyElem  whereas  PolynomialRing{T}  belongs to  Ring . We also have\nthat  fmpz_poly  belongs to  PolyElem  and  FmpzPolyRing  belongs to  Ring , and so on.  All the generic types are parameterised by a type  T  which is the type of the  elements  of the ring\nthey are defined over. For example, a polynomial ring over the Flint integers  fmpz  would have type PolynomialRing{fmpz} , thus in that example the type parameter  T  would be instantiated as  fmpz .    Generic   Poly{T}  ( PolynomialRing{T} )  PowerSeries{T}  ( PowerSeriesRing{T} )  Residue{T}  ( ResidueRing{T} )  Fraction{T}  ( FractionField{T} )  Mat{T}  ( MatrixSpace{T} )     Flint   fmpz  ( FlintIntegerRing )  fmpq  ( FlintRationalField )  fq_nmod  ( FqNmodFiniteField )  fq  ( FqFiniteField )  padic  ( FlintPadicField )  fmpz_poly  ( FmpzPolyRing )  fmpq_poly  ( FmpqPolyRing )  nmod_poly  ( NmodPolyRing )  fmpz_mod_poly  ( FmpzModPolyRing )  fq_poly  ( FqPolyRing )  fq_nmod_poly  ( FqNmodPolyRing )  fmpz_series  ( FmpzSeriesRing )  fmpq_series  ( FmpqSeriesRing )  fmpz_mod_series  ( FmpzModSeriesRing )  fq_nmod_series  ( FqNmodSeriesRing )  fq_series  ( FqSeriesRing )  fmpz_mat  ( FmpzMatSpace )  nmod_mat  ( NmodMatSpace )  perm  ( FlintPermGroup )     Antic   nf_elem  ( AnticNumberField )     Arb   arb  ( ArbField )  acb  ( AcbField )     Pari   pari_int  ( PariIntegerRing )  pari_rat  ( PariRationalField )  pari_vec{T}  ( PariVector{T} )  pari_poly{T}  ( PariPolyRing{T} )  pari_polmod{T}  ( PariPolModRing{T} )  pari_maximal_order_elem  ( PariMaximalOrder )  PariIdeal  ( PariIdealSet )  no element type ( PariNumberField )  PariFactor{T}  (no parent type)", 
            "title": "Concrete types in Nemo"
        }
    ]
}
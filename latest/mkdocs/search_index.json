{
    "docs": [
        {
            "location": "/", 
            "text": "Nemo\n\n\nIntroduction\n\n\nNemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.\n\n\n\n\nhttp://nemocas.org\n (Website)\n\n\nhttps://github.com/Nemocas/Nemo.jl\n (Source code)\n\n\nhttp://nemo.readthedocs.org/en/latest/\n (Online documentation)\n\n\n\n\nThe features of Nemo so far include:\n\n\n\n\nMultiprecision integers and rationals\n\n\nIntegers modulo n\n\n\np-adic numbers\n\n\nFinite fields (prime and non-prime order)\n\n\nNumber field arithmetic\n\n\nMaximal orders of number fields\n\n\nArithmetic of ideals in maximal orders\n\n\nArbitrary precision real and complex balls\n\n\nUnivariate polynomials and matrices over the above\n\n\nGeneric polynomials, power series, fraction fields, residue rings and matrices\n\n\n\n\nInstallation\n\n\nTo use Nemo we require Julia 0.4 or higher. Please see\n\nhttp://julialang.org/downloads\n for instructions on how to obtain\njulia for your system.\n\n\nAt the Julia prompt simply type\n\n\njulia\n Pkg.add(\nNemo\n)\njulia\n Pkg.build(\nNemo\n)\n\n\n\n\nAlternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https://cloud.sagemath.com/).\n\n\nQuick start\n\n\nHere are some examples of using Nemo.\n\n\nThis example computes recursive univariate polynomials.\n\n\njulia\n using Nemo\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia\n T, z = PolynomialRing(S, \nz\n)\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia\n f = x + y + z + 1\nz+(y+(x+1))\n\njulia\n p = f^30; # semicolon supresses output\n\njulia\n @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)\n\n\n\n\nHere is an example using generic recursive ring constructions.\n\n\njulia\n using Nemo\n\njulia\n R, x = FiniteField(7, 11, \nx\n)\n(Finite field of degree 11 over F_7,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia\n T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia\n U, z = PolynomialRing(T, \nz\n)\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia\n f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia\n g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia\n s = f^12;\n\njulia\n t = (s + g)^12;\n\njulia\n @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)\n\n\n\n\nHere is an example using matrices.\n\n\njulia\n using Nemo\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia\n @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)\n\n\n\n\nAnd here is an example with power series.\n\n\njulia\n using Nemo\n\njulia\n R, x = QQ[\nx\n]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia\n S, t = PowerSeriesRing(R, 100, \nt\n)\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia\n u = t + O(t^100)\nt+O(t^100)\n\njulia\n @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/#introduction", 
            "text": "Nemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.   http://nemocas.org  (Website)  https://github.com/Nemocas/Nemo.jl  (Source code)  http://nemo.readthedocs.org/en/latest/  (Online documentation)   The features of Nemo so far include:   Multiprecision integers and rationals  Integers modulo n  p-adic numbers  Finite fields (prime and non-prime order)  Number field arithmetic  Maximal orders of number fields  Arithmetic of ideals in maximal orders  Arbitrary precision real and complex balls  Univariate polynomials and matrices over the above  Generic polynomials, power series, fraction fields, residue rings and matrices", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Nemo we require Julia 0.4 or higher. Please see http://julialang.org/downloads  for instructions on how to obtain\njulia for your system.  At the Julia prompt simply type  julia  Pkg.add( Nemo )\njulia  Pkg.build( Nemo )  Alternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https://cloud.sagemath.com/).", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here are some examples of using Nemo.  This example computes recursive univariate polynomials.  julia  using Nemo\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia  T, z = PolynomialRing(S,  z )\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia  f = x + y + z + 1\nz+(y+(x+1))\n\njulia  p = f^30; # semicolon supresses output\n\njulia  @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)  Here is an example using generic recursive ring constructions.  julia  using Nemo\n\njulia  R, x = FiniteField(7, 11,  x )\n(Finite field of degree 11 over F_7,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia  T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia  U, z = PolynomialRing(T,  z )\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia  f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia  g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia  s = f^12;\n\njulia  t = (s + g)^12;\n\njulia  @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)  Here is an example using matrices.  julia  using Nemo\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia  @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)  And here is an example with power series.  julia  using Nemo\n\njulia  R, x = QQ[ x ]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia  S, t = PowerSeriesRing(R, 100,  t )\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia  u = t + O(t^100)\nt+O(t^100)\n\njulia  @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Quick start"
        }, 
        {
            "location": "/about/", 
            "text": "Nemo\n\n\nWhat is Nemo?\n\n\nNemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering\n\n\n\n\nCommutative Algebra\n\n\nNumber Theory\n\n\nGroup Theory\n\n\n\n\nNemo consists of wrappers of specialised C/C++ libraries:\n\n\n\n\nFlint    [http://flintlib.org/]\n\n\nArb      [http://fredrikj.net/arb/]\n\n\nAntic    [https://github.com/wbhart/antic/]\n\n\nSingular [https://www.singular.uni-kl.de/]\n\n\nPari     [http://pari.math.u-bordeaux.fr/]\n\n\n\n\nIt will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.\n\n\nNemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include\n\n\n\n\nUnivariate polynomial rings\n\n\nPower series rings\n\n\nResidue rings (modulo principal ideals)\n\n\nFraction fields\n\n\nMatrices\n\n\n\n\nWhy Julia?\n\n\nJulia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.\n\n\nThe benefits of Julia include\n\n\n\n\nFamiliar imperative syntax\n\n\nJIT compilation (provides near native performance, even for highly generic code)\n\n\nREPL console (cuts down on development time)\n\n\nParametric types (allows for fast generic constructions over other data types)\n\n\nPowerful metaprogramming facilities\n\n\nOperator overloading\n\n\nMultiple dispatch (dispatch on every argument of a function)\n\n\nEfficient native C interface (no wrapper overhead)\n\n\nExperimental C++ interface\n\n\nDynamic type inference\n\n\nBuilt-in bignums\n\n\nAble to be embedded in C programs\n\n\nHigh performance collection types (dictionaries, iterators, arrays, etc.)\n\n\nJupyter support (for web based notebooks)\n\n\n\n\nThe main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "About Nemo"
        }, 
        {
            "location": "/about/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/about/#what-is-nemo", 
            "text": "Nemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering   Commutative Algebra  Number Theory  Group Theory   Nemo consists of wrappers of specialised C/C++ libraries:   Flint    [http://flintlib.org/]  Arb      [http://fredrikj.net/arb/]  Antic    [https://github.com/wbhart/antic/]  Singular [https://www.singular.uni-kl.de/]  Pari     [http://pari.math.u-bordeaux.fr/]   It will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.  Nemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include   Univariate polynomial rings  Power series rings  Residue rings (modulo principal ideals)  Fraction fields  Matrices", 
            "title": "What is Nemo?"
        }, 
        {
            "location": "/about/#why-julia", 
            "text": "Julia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.  The benefits of Julia include   Familiar imperative syntax  JIT compilation (provides near native performance, even for highly generic code)  REPL console (cuts down on development time)  Parametric types (allows for fast generic constructions over other data types)  Powerful metaprogramming facilities  Operator overloading  Multiple dispatch (dispatch on every argument of a function)  Efficient native C interface (no wrapper overhead)  Experimental C++ interface  Dynamic type inference  Built-in bignums  Able to be embedded in C programs  High performance collection types (dictionaries, iterators, arrays, etc.)  Jupyter support (for web based notebooks)   The main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "Why Julia?"
        }, 
        {
            "location": "/types/", 
            "text": "Types in Nemo\n\n\nOn this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations. \n\n\nIn contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.\n\n\nIntroduction\n\n\nJulia provides two levels of types that we make use of\n\n\n\n\nabstract types\n\n\nconcrete types\n\n\n\n\nConcrete types are just like the usual types everyone is familiar with from C or C++.\n\n\nAbstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.\n\n\nTo write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter, \nT\n say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter \nT\n must belong to.\n\n\nWe use the symbol \n:\n in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type \nInt64\n for 64 bit machine integers belongs to the Julia abstract type\n\nInteger\n. Thus \nInt \n: Integer\n returns \ntrue\n.\n\n\nHere is some Julia code illustrating this with a more complex example. We create an abstract type called\n\nShape\n and two user defined concrete types \nsquare\n and \ncircle\n belonging to \nShape\n. We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type \nT\n belonging to the abstract type \nShape\n.\n\n\nNote that in the type definitions of \nsquare\n and \ncircle\n we specify that those types belong to the\nabstract type \nShape\n using the \n:\n operator.\n\n\nabstract Shape\n\ntype square \n: Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle \n: Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T \n: Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)\n\n\n\n\nThe abstract type hierarchy in Nemo\n\n\nAbstract types in Julia can also belong to one another in a hierarchy. For example, the \nNemo.Field\n\nabstract type belongs to the \nNemo.Ring\n abstract type. An object representing a field in Nemo has type\nbelonging to \nNemo.Field\n. But because we define the inclusion \nNemo.Field \n: Nemo.Ring\n in Nemo, the\ntype of such an object also automatically belongs to \nNemo.Ring\n. This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.\n\n\nIn Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type\n\nGenPolyRing\n to model a generic polynomial ring, and elements of that polynomial ring would have\ntype \nGenPoly\n. \n\n\nIn order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains. \n\n\n\n\nAll objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.\n\n\nWhy types aren't enough\n\n\nNaively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.\n\n\nAs an example, consider the ring \nR = \\mathbb{Z}/n\\mathbb{Z}\n for a multiprecision integer \nn\n. If we\nwere to model the ring \nR\n as a type, then the type would somehow need to contain the modulus\n\nn\n. This is not possible in Julia, and in fact it is not desirable either.\n\n\nJulia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings \n\\mathbb{Z}/n\\mathbb{Z}\n would be needed\nand every function we use would be recompiled over and over for each different \nn\n. This would result \nin a huge delay as the compiler is invoked many times.\n\n\nFor this reason, the modulus \nn\n needs to be attached to the \nelements\n of the ring, not to type\nassociated with those elements.\n\n\nBut now we have a problem. How do we create new elements of the ring \n\\mathbb{Z}/n\\mathbb{Z}\n given only\nthe type? Suppose all rings \n\\mathbb{Z}/n\\mathbb{Z}\n were represented by the same type \nZmod\n say. How\nwould we create \na = 3 \\pmod{7}\n? We could not write \na = Zmod(3)\n since the modulus \n7\n is not contained\nin the type \nZmod\n.\n\n\nWe could of course use the notation \na = Zmod(3, 7)\n, but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as \na = ZZ(7)\n and cases where they take a modulus, such as \na = Zmod(3, 7)\n.\n\n\nThe way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called \nparent\n objects can contain extra information,\nsuch as the modulus \nn\n. \n\n\nIn order to create new elements of \n\\mathbb{Z}/n\\mathbb{Z}\n as above, we overload the \ncall\n operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.\n\n\nIn the following Nemo example, we create the parent object \nR\n corresponding to the ring\n\n\\mathbb{Z}/7\\mathbb{Z}\n. We then create a new element \na\n of this ring by calling the parent object\n\nR\n, just as though \nR\n were a type with a constructor accepting an \nInt\n parameter. \n\n\nR = ResidueRing(ZZ, 7)\na = R(3)\n\n\n\n\nThis example creates the element \na = 3 \\pmod{7}\n. \n\n\nThe important point is that unlike a type, a parent object such as \nR\n can contain additional information\nthat a type cannot contain, such as the modulus \n7\n of the ring in this example, or context objects\nrequired by C libraries in other examples.\n\n\nMore complex example of parent objects\n\n\nHere is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.\n\n\njulia\n using Nemo\n\njulia\n R, x = ZZ[\nx\n]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia\n typeof(R)\nNemo.FmpzPolyRing\n\njulia\n typeof(f)\nNemo.fmpz_poly\n\njulia\n parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia\n typeof(R) \n: PolyRing\ntrue\n\njulia\n typeof(f) \n: PolyElem\ntrue\n\njulia\n parent(f) == R\ntrue\n\n\n\n\nConcrete types in Nemo\n\n\nFinally we come to all the concrete types in Nemo. \n\n\nThese are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).\n\n\nBelow we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess. \n\n\nFor example, \nfmpz\n belongs to the abstract type \nRingElem\n and \nFlintIntegerRing\n belongs to \nRing\n.\nSimilarly \nPoly{T}\n belongs to \nPolyElem\n whereas \nPolynomialRing{T}\n belongs to \nPolyRing\n. We also\nhave that \nfmpz_poly\n belongs to \nPolyElem\n and \nFmpzPolyRing\n belongs to \nPolyRing\n, and so on.\n\n\nAll the generic types are parameterised by a type \nT\n which is the type of the \nelements\n of the ring\nthey are defined over. \n\n\n\n\n\n\nGeneric\n\n\n\n\nGenPoly{T}\n (\nGenPolyRing{T}\n)\n\n\nGenRelSeries{T}\n (\nGenRelSeriesRing{T}\n)\n\n\nGenRes{T}\n (\nGenResRing{T}\n)\n\n\nGenFrac{T}\n (\nGenFracField{T}\n)\n\n\nGenMat{T}\n (\nGenMatSpace{T}\n)\n\n\n\n\n\n\n\n\nFlint\n\n\n\n\nfmpz\n (\nFlintIntegerRing\n)\n\n\nfmpq\n (\nFlintRationalField\n)\n\n\nfq_nmod\n (\nFqNmodFiniteField\n)\n\n\nfq\n (\nFqFiniteField\n)\n\n\npadic\n (\nFlintPadicField\n)\n\n\nfmpz_poly\n (\nFmpzPolyRing\n)\n\n\nfmpq_poly\n (\nFmpqPolyRing\n)\n\n\nnmod_poly\n (\nNmodPolyRing\n)\n\n\nfmpz_mod_poly\n (\nFmpzModPolyRing\n)\n\n\nfq_poly\n (\nFqPolyRing\n)\n\n\nfq_nmod_poly\n (\nFqNmodPolyRing\n)\n\n\nfmpz_series\n (\nFmpzSeriesRing\n)\n\n\nfmpq_series\n (\nFmpqSeriesRing\n)\n\n\nfmpz_mod_series\n (\nFmpzModSeriesRing\n)\n\n\nfq_nmod_series\n (\nFqNmodSeriesRing\n)\n\n\nfq_series\n (\nFqSeriesRing\n)\n\n\nfmpz_mat\n (\nFmpzMatSpace\n)\n\n\nnmod_mat\n (\nNmodMatSpace\n)\n\n\nperm\n (\nFlintPermGroup\n)\n\n\n\n\n\n\n\n\nAntic\n\n\n\n\nnf_elem\n (\nAnticNumberField\n)\n\n\n\n\n\n\n\n\nArb\n\n\n\n\narb\n (\nArbField\n)\n\n\nacb\n (\nAcbField\n)\n\n\n\n\n\n\n\n\nPari\n\n\n\n\npari_int\n (\nPariIntegerRing\n)\n\n\npari_rat\n (\nPariRationalField\n)\n\n\npari_vec{T}\n (\nPariVector{T}\n)\n\n\npari_poly{T}\n (\nPariPolyRing{T}\n)\n\n\npari_polmod{T}\n (\nPariPolModRing{T}\n)\n\n\npari_maximal_order_elem\n (\nPariMaximalOrder\n)\n\n\nPariIdeal\n (\nPariIdealSet\n)\n\n\nno element type (\nPariNumberField\n)\n\n\nPariFactor{T}\n (no parent type)", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#types-in-nemo", 
            "text": "On this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations.   In contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#introduction", 
            "text": "Julia provides two levels of types that we make use of   abstract types  concrete types   Concrete types are just like the usual types everyone is familiar with from C or C++.  Abstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.  To write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter,  T  say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter  T  must belong to.  We use the symbol  :  in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type  Int64  for 64 bit machine integers belongs to the Julia abstract type Integer . Thus  Int  : Integer  returns  true .  Here is some Julia code illustrating this with a more complex example. We create an abstract type called Shape  and two user defined concrete types  square  and  circle  belonging to  Shape . We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type  T  belonging to the abstract type  Shape .  Note that in the type definitions of  square  and  circle  we specify that those types belong to the\nabstract type  Shape  using the  :  operator.  abstract Shape\n\ntype square  : Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle  : Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T  : Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)", 
            "title": "Introduction"
        }, 
        {
            "location": "/types/#the-abstract-type-hierarchy-in-nemo", 
            "text": "Abstract types in Julia can also belong to one another in a hierarchy. For example, the  Nemo.Field \nabstract type belongs to the  Nemo.Ring  abstract type. An object representing a field in Nemo has type\nbelonging to  Nemo.Field . But because we define the inclusion  Nemo.Field  : Nemo.Ring  in Nemo, the\ntype of such an object also automatically belongs to  Nemo.Ring . This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.  In Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type GenPolyRing  to model a generic polynomial ring, and elements of that polynomial ring would have\ntype  GenPoly .   In order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains.    All objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.", 
            "title": "The abstract type hierarchy in Nemo"
        }, 
        {
            "location": "/types/#why-types-arent-enough", 
            "text": "Naively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.  As an example, consider the ring  R = \\mathbb{Z}/n\\mathbb{Z}  for a multiprecision integer  n . If we\nwere to model the ring  R  as a type, then the type would somehow need to contain the modulus n . This is not possible in Julia, and in fact it is not desirable either.  Julia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings  \\mathbb{Z}/n\\mathbb{Z}  would be needed\nand every function we use would be recompiled over and over for each different  n . This would result \nin a huge delay as the compiler is invoked many times.  For this reason, the modulus  n  needs to be attached to the  elements  of the ring, not to type\nassociated with those elements.  But now we have a problem. How do we create new elements of the ring  \\mathbb{Z}/n\\mathbb{Z}  given only\nthe type? Suppose all rings  \\mathbb{Z}/n\\mathbb{Z}  were represented by the same type  Zmod  say. How\nwould we create  a = 3 \\pmod{7} ? We could not write  a = Zmod(3)  since the modulus  7  is not contained\nin the type  Zmod .  We could of course use the notation  a = Zmod(3, 7) , but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as  a = ZZ(7)  and cases where they take a modulus, such as  a = Zmod(3, 7) .  The way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called  parent  objects can contain extra information,\nsuch as the modulus  n .   In order to create new elements of  \\mathbb{Z}/n\\mathbb{Z}  as above, we overload the  call  operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.  In the following Nemo example, we create the parent object  R  corresponding to the ring \\mathbb{Z}/7\\mathbb{Z} . We then create a new element  a  of this ring by calling the parent object R , just as though  R  were a type with a constructor accepting an  Int  parameter.   R = ResidueRing(ZZ, 7)\na = R(3)  This example creates the element  a = 3 \\pmod{7} .   The important point is that unlike a type, a parent object such as  R  can contain additional information\nthat a type cannot contain, such as the modulus  7  of the ring in this example, or context objects\nrequired by C libraries in other examples.", 
            "title": "Why types aren't enough"
        }, 
        {
            "location": "/types/#more-complex-example-of-parent-objects", 
            "text": "Here is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.  julia  using Nemo\n\njulia  R, x = ZZ[ x ]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia  typeof(R)\nNemo.FmpzPolyRing\n\njulia  typeof(f)\nNemo.fmpz_poly\n\njulia  parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia  typeof(R)  : PolyRing\ntrue\n\njulia  typeof(f)  : PolyElem\ntrue\n\njulia  parent(f) == R\ntrue", 
            "title": "More complex example of parent objects"
        }, 
        {
            "location": "/types/#concrete-types-in-nemo", 
            "text": "Finally we come to all the concrete types in Nemo.   These are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).  Below we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess.   For example,  fmpz  belongs to the abstract type  RingElem  and  FlintIntegerRing  belongs to  Ring .\nSimilarly  Poly{T}  belongs to  PolyElem  whereas  PolynomialRing{T}  belongs to  PolyRing . We also\nhave that  fmpz_poly  belongs to  PolyElem  and  FmpzPolyRing  belongs to  PolyRing , and so on.  All the generic types are parameterised by a type  T  which is the type of the  elements  of the ring\nthey are defined over.     Generic   GenPoly{T}  ( GenPolyRing{T} )  GenRelSeries{T}  ( GenRelSeriesRing{T} )  GenRes{T}  ( GenResRing{T} )  GenFrac{T}  ( GenFracField{T} )  GenMat{T}  ( GenMatSpace{T} )     Flint   fmpz  ( FlintIntegerRing )  fmpq  ( FlintRationalField )  fq_nmod  ( FqNmodFiniteField )  fq  ( FqFiniteField )  padic  ( FlintPadicField )  fmpz_poly  ( FmpzPolyRing )  fmpq_poly  ( FmpqPolyRing )  nmod_poly  ( NmodPolyRing )  fmpz_mod_poly  ( FmpzModPolyRing )  fq_poly  ( FqPolyRing )  fq_nmod_poly  ( FqNmodPolyRing )  fmpz_series  ( FmpzSeriesRing )  fmpq_series  ( FmpqSeriesRing )  fmpz_mod_series  ( FmpzModSeriesRing )  fq_nmod_series  ( FqNmodSeriesRing )  fq_series  ( FqSeriesRing )  fmpz_mat  ( FmpzMatSpace )  nmod_mat  ( NmodMatSpace )  perm  ( FlintPermGroup )     Antic   nf_elem  ( AnticNumberField )     Arb   arb  ( ArbField )  acb  ( AcbField )     Pari   pari_int  ( PariIntegerRing )  pari_rat  ( PariRationalField )  pari_vec{T}  ( PariVector{T} )  pari_poly{T}  ( PariPolyRing{T} )  pari_polmod{T}  ( PariPolModRing{T} )  pari_maximal_order_elem  ( PariMaximalOrder )  PariIdeal  ( PariIdealSet )  no element type ( PariNumberField )  PariFactor{T}  (no parent type)", 
            "title": "Concrete types in Nemo"
        }, 
        {
            "location": "/constructors/", 
            "text": "Constructing mathematical objects in Nemo\n\n\nConstructing objects in Julia\n\n\nIn Julia, one constructs objects of a given type by calling a type constructor. This is simply a function\nwith the same name as the type itself. For example, to construct a \nBigInt\n object in Julia, we simply\ncall the \nBigInt\n constructor:\n\n\nn = BigInt(\n1234567898765434567898765434567876543456787654567890\n)\n\n\n\n\nJulia also uses constructors to convert between types. For example, to convert an \nInt\n to a \nBigInt\n:\n\n\nm = BigInt(123)\n\n\n\n\nHow we construct objects in Nemo\n\n\nAs we explained in the previous section, Julia types don't contain enough information to properly model\nthe ring of integers modulo \nn\n for a multiprecision modulus \nn\n. Instead of using types to construct\nobjects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.\n\n\nConsider the following simple example, to create a Flint multiprecision integer:\n\n\nn = ZZ(\n12345678765456787654567890987654567898765678909876567890\n)\n\n\n\n\nHere \nZZ\n is not a Julia type, but a callable object. However, for most purposes one can think of such\na parent object \nZZ\n as though it were a type.\n\n\nConstructing parent objects\n\n\nFor more complicated groups, rings, fields, etc., one first needs to construct the parent object before\none can use it to construct element objects.\n\n\nNemo provides a set of functions for constructing such parent objects. For example, to create a parent\nobject for polynomials over the integers, we use the \nPolynomialRing\n parent object constructor.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nf = x^3 + 3x + 1\ng = R(12)\n\n\n\n\nIn this example, \nR\n is the parent object and we use it to convert the \nInt\n value \n12\n to an element\nof the polynomial ring \n\\mathbb{Z}[x]\n.\n\n\nList of parent object constructors\n\n\nFor convenience, we provide a list of all the parent object constructors in Nemo and explain what domains\nthey represent.\n\n\n\n\n\n\n\n\nMathematics\n\n\nNemo constructor\n\n\n\n\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}\n\n\n\n\nR = ZZ\n\n\n\n\n\n\n\n\nR = \\mathbb{Q}\n\n\n\n\nR = QQ\n\n\n\n\n\n\n\n\nR = \\mathbb{F}_{p^n}\n\n\n\n\nR, a = FiniteField(p, n, \"a\")\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}/n\\mathbb{Z}\n\n\n\n\nR = ResidueRing(ZZ, n)\n\n\n\n\n\n\n\n\nS = R[x]\n\n\n\n\nS, x = PolynomialRing(R, \"x\")\n\n\n\n\n\n\n\n\nS = R[x]\n (to precision \nn\n)\n\n\nS, x = PowerSeriesRing(R, n, \"x\")\n\n\n\n\n\n\n\n\nS = \\mbox{Frac}_R\n\n\n\n\nS = FractionField(R)\n\n\n\n\n\n\n\n\nS = R/(f)\n\n\n\n\nS = ResidueRing(R, f)\n\n\n\n\n\n\n\n\nS = \\mbox{Mat}_{m\\times n}(R)\n\n\n\n\nS = MatrixSpace(R, m, n)\n\n\n\n\n\n\n\n\nS = \\mathbb{Q}[x]/(f)\n\n\n\n\nS, a = NumberField(f, \"a\")\n\n\n\n\n\n\n\n\nO = \\mathcal{O}_K\n\n\n\n\nS = MaximalOrder(K)\n\n\n\n\n\n\nideal \nI\n of \nO = \\mathcal{O}_K\n\n\n\n\nI = Ideal(O, gens, ...)", 
            "title": "Parent object constructors"
        }, 
        {
            "location": "/constructors/#constructing-mathematical-objects-in-nemo", 
            "text": "", 
            "title": "Constructing mathematical objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-objects-in-julia", 
            "text": "In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function\nwith the same name as the type itself. For example, to construct a  BigInt  object in Julia, we simply\ncall the  BigInt  constructor:  n = BigInt( 1234567898765434567898765434567876543456787654567890 )  Julia also uses constructors to convert between types. For example, to convert an  Int  to a  BigInt :  m = BigInt(123)", 
            "title": "Constructing objects in Julia"
        }, 
        {
            "location": "/constructors/#how-we-construct-objects-in-nemo", 
            "text": "As we explained in the previous section, Julia types don't contain enough information to properly model\nthe ring of integers modulo  n  for a multiprecision modulus  n . Instead of using types to construct\nobjects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.  Consider the following simple example, to create a Flint multiprecision integer:  n = ZZ( 12345678765456787654567890987654567898765678909876567890 )  Here  ZZ  is not a Julia type, but a callable object. However, for most purposes one can think of such\na parent object  ZZ  as though it were a type.", 
            "title": "How we construct objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-parent-objects", 
            "text": "For more complicated groups, rings, fields, etc., one first needs to construct the parent object before\none can use it to construct element objects.  Nemo provides a set of functions for constructing such parent objects. For example, to create a parent\nobject for polynomials over the integers, we use the  PolynomialRing  parent object constructor.  R, x = PolynomialRing(ZZ,  x )\nf = x^3 + 3x + 1\ng = R(12)  In this example,  R  is the parent object and we use it to convert the  Int  value  12  to an element\nof the polynomial ring  \\mathbb{Z}[x] .", 
            "title": "Constructing parent objects"
        }, 
        {
            "location": "/constructors/#list-of-parent-object-constructors", 
            "text": "For convenience, we provide a list of all the parent object constructors in Nemo and explain what domains\nthey represent.     Mathematics  Nemo constructor       R = \\mathbb{Z}   R = ZZ     R = \\mathbb{Q}   R = QQ     R = \\mathbb{F}_{p^n}   R, a = FiniteField(p, n, \"a\")     R = \\mathbb{Z}/n\\mathbb{Z}   R = ResidueRing(ZZ, n)     S = R[x]   S, x = PolynomialRing(R, \"x\")     S = R[x]  (to precision  n )  S, x = PowerSeriesRing(R, n, \"x\")     S = \\mbox{Frac}_R   S = FractionField(R)     S = R/(f)   S = ResidueRing(R, f)     S = \\mbox{Mat}_{m\\times n}(R)   S = MatrixSpace(R, m, n)     S = \\mathbb{Q}[x]/(f)   S, a = NumberField(f, \"a\")     O = \\mathcal{O}_K   S = MaximalOrder(K)    ideal  I  of  O = \\mathcal{O}_K   I = Ideal(O, gens, ...)", 
            "title": "List of parent object constructors"
        }, 
        {
            "location": "/src/polynomial/", 
            "text": "```@meta\nCurrentModule = Nemo\n\n\n\n# Univariate polynomials\n\nNemo allow the creation of dense, univariate polynomials over any ring $R$.\n\n## Polynomial types\n\nAlthough the user rarely needs to deal directly with Julia types for Nemo\nobjects, we provide the relevant information here for developers.\n\nGeneric univariate polynomials in Nemo have type `GenPoly{T}`, where `T` is the\ntype of the coefficients of the polynomial.\n\nThe string representation of the variable and the base ring $R$ of a generic\npolynomial is stored in its parent object. Parent objects of generic univariate\npolynomials have type `GenPolyRing{T}`.\n\nIn addition to generic polynomials, Nemo provides access to numerous polynomial\nimplementations over specific rings, provided by C/C++ libraries. The following\ntable shows each of the polynomial types available in Nemo, their base ring $R$,\nthe type of their parent objects and the library providing those types.\n\nBase ring                             | Library             | Element type        | Parent type\n--------------------------------------|---------------------|---------------------|----------------------\nGeneric ring $R$                      | Nemo                | `GenPoly{T}`        | `GenPolyRing{T}`\n$\\mathbb{Z}$                          | Flint               | `fmpz_poly`         | `FmpzPolyRing`\n$\\mathbb{Z}/n\\mathbb{Z}$ (small $n$)  | Flint               | `nmod_poly`         | `NmodPolyRing`\n$\\mathbb{Z}/n\\mathbb{Z}$ (large $n$)  | Flint               | `fmpz_mod_poly`     | `FmpzModPolyRing`\n$\\mathbb{Q}$                          | Flint               | `fmpq_poly`         | `FmpqPolyRing`\n$\\mathbb{F}_{p^n}$ (small $n$)        | Flint               | `fq_nmod_poly`      | `FqNmodPolyRing`\n$\\mathbb{F}_{p^n}$ (large $n$)        | Flint               | `fq_poly`           | `FqPolyRing`\n\nAll polynomial element types belong to the abstract type `PolyElem` and all of\nthe polynomial ring types belong to the abstract type `PolyRing`. This enables\none to write generic functions that can accept any Nemo polynomial type.\n\n## Basic functionality\n\nAll univariate polynomial modules in Nemo must provide the functionality listed\nbelow. Note that only some of these functions are useful to a user.\n\nDevelopers who are writing their own polynomial module, whether as an interface\nto a C library, or as some kind of generic module, must provide all of these\nfunctions for custom univariate polynomial types in Nemo. \n\nWe write `T` for the type of the polynomials in the polynomial ring.\n\nAll of these functions are provided for all existing polynomial types in Nemo.\n\n\n\n\n\nparent_type{T \n: PolyElem}(::Type{T})\n\n\n\nGiven the type of polynomial elements, should return the type of the\ncorresponding parent object.\n\n\n\n\n\nelem_type(R::PolyRing)\n\n\n\nGiven a parent object for the polynomial ring, return the type of elements\nof the polynomial ring.\n\n\n\n\n\nBase.hash(a::PolyElem, h::UInt)\n\n\n\nReturn a `UInt` hexadecimal hash of the polynomial $a$. This should be xor'd\nwith a fixed random hexadecimal specific to the polynomial type. The hash of\neach coefficient should be xor'd with the supplied parameter `h` as part of\ncomputing the hash.\n\n\n\n\n\nfit!(a::PolyElem, n::Int)\n\n\n\nBy reallocating if necessary, ensure that the given polynomial has space for at\nleast $n$ coefficients. This function does not change the length of the\npolynomial and will only ever increase the number of allocated coefficients.\nAny coefficients added by this function are initialised to zero.\n\n\n\n\n\nnormalise(a::PolyElem, n::Int)\n\n\n\nReturn the normalised length of the given polynomial, assuming its current\nlength is $n$. Its normalised length is such that it either has nonzero\nleading term or is the zero polynomial. Note that this function doesn't\nnormalise the polynomial. That can be done with a subsequent call to\n`set_length!` using the length returned by `normalise`.\n\n\n\n\n\nset_length!(a::PolyElem, n::Int)\n\n\n\nSet the length of an existing polynomial that has sufficient space allocated,\ni.e. a polynomial for which no reallocation is needed. Note that if the Julia\ntype definition for a custom polynomial type has a field, `length`, which\ncorresponds to the current length of the polynomial, then the developer doesn't\nneed to supply this function, as the supplied generic implementation will work.\nNote that it can change the length to any value from zero to the number of\ncoefficients currently allocated and initialised.\n\n\n\n\n\nlength(a::PolyElem)\n\n\n\nReturn the current length (not the number of allocated coefficients), of the\ngiven polynomial. Note that this function only needs to be provided by a\ndeveloper for a custome polynomial type if the Julia type definition for\npolynomial elements doesn't contain a field `length` corresponding to the\ncurrent length of the polynomial. Otherwise the supplied generic implementation\nwill work.\n\n\n\n\n\ncoeff(a::PolyElem, n::Int)\n\n\n\nReturn the degree `n` coefficient of the given polynomial. Note coefficients\nare numbered from `n = 0` for the constant coefficient. If $n$ is bigger\nthen the degree of the polynomial, the function returns a zero coefficient.\nWe require $n \\geq 0$. \n\n\n\n\n\nsetcoeff!{T \n: RingElem}(a::PolyElem{T}, n::Int, c::T)\n\n\n\nSet the coefficient of the degree $n$ term of the given polynomial to the given\nvalue `a`. The polynomial is not normalised automatically after this operation,\nhowever the polynomial is automatically resized if there is not sufficient\nallocated space.\n\n\n\n\n\ndeepcopy(a::PolyElem)\n\n\n\nConstruct a copy of the given polynomial and return it. This function must\nrecursively construct copies of all of the internal data in the given\npolynomial. Nemo polynomials are mutable and so returning shallow copies is not\nsufficient.\n\n\n\n\n\nmul!(c::PolyElem, a::PolyElem, b::PolyElem)\n\n\n\nMultiply $a$ by $b$ and set the existing polynomial $c$ to the result. This\nfunction is provided for performance reasons as it saves allocating a new\nobject for the result and eliminates associated garbage collection.\n\n\n\n\n\naddeq!(c::PolyElem, a::PolyElem)\n\n\n\nIn-place addition. Adds $a$ to $c$ and sets $c$ to the result. This function\nis provided for performance reasons as it saves allocating a new object for\nthe result and eliminates associated garbage collection.\n\nGiven a parent object `S` for a polynomial ring, the following coercion\nfunctions are provided to coerce various elements into the polynomial\nring. Developers provide these by overloading the `call` operator for the\npolynomial parent objects.\n\n\n\n\n\nS()\n\n\n\nCoerce zero into the ring $S$.\n\n\n\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\nCoerce an integer value or Flint integer into the polynomial ring $S$.\n\n\n\n\n\nS(n::T)\n\n\n\nCoerces an element of the base ring, of type `T` into $S$.\n\n\n\n\n\nS(A::Array{T, 1})\n\n\n\nTake an array of elements in the base ring, of type `T` and construct the\npolynomial with those coefficients, starting with the constant coefficient.\n\n\n\n\n\nS(f::PolyElem)\n\n\n\nTake a polynomial that is already in the ring $S$ and simply return it. A copy\nof the original is not made.\n\n\n\n\n\nS(c::RingElem)\n\n\n\nTry to coerce the given ring element into the polynomial ring. This only\nsucceeds if $c$ can be coerced into the base ring.\n\nIn addition to the above, developers of custom polynomials must ensure the\nparent object of a polynomial type constains a field `base_ring` specifying the\nbase ring, a field `S` containing a symbol (not a string) representing the\nvariable name of the polynomial ring. They must also ensure that each\npolynomial element contains a field `parent` specifying the parent object of\nthe polynomial.\n\nTypically a developer will also overload the `PolynomialRing` generic function\nto create polynomials of the custom type they are implementing.\n\n## Polynomial ring constructors\n\nIn order to construct polynomials, one must first construct the polynomial ring\nitself. This is accomplished with the following constructor.\n\n```@docs\nPolynomialRing(::Ring, ::AbstractString{}, ::Bool)\n\n\n\n\nA shorthand version of this function is provided. Given a base ring \nR\n, we can\nabbreviate the above constructor as follows.\n\n\nR[\nx\n]\n\n\n\n\nHere are some examples of creating polynomial rings and making use of the\nresulting parent objects to coerce various elements into the polynomial ring.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = QQ[\nz\n]\n\nf = R()\ng = R(123)\nh = S(ZZ(1234))\nk = S(x + 1)\nm = T(z + 1)\n\n\n\n\nPolynomial element constructors\n\n\nOnce a polynomial ring is constructed, there are various ways to construct\npolynomials in that ring.\n\n\nThe easiest way is simply using the generator returned by the \nPolynomialRing\n\nconstructor and and build up the polynomial using basic arithmetic. Julia has\nquite flexible notation for the construction of polynomials in this way.\n\n\nIn addition we provide the following functions for constructing certain useful\npolynomials.\n\n\n```@docs\nzero(::PolyRing)\n\n\n\n```@docs\none(::PolyRing)\n\n\n\n\n```@docs\ngen(::PolyRing)\n\n\n\nHere are some examples of constructing polynomials.\n\n\n\n\n\nR, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\n\n\nf = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1\n\n\nh = zero(S)\nk = one(R)\nm = gen(S)\n\n\n\n## Basic manipulation\n\nNumerous functions are provided to manipulate polynomials and to set and\nretrieve coefficients and other basic data associated with the polynomials.\nAlso see the section on basic functionality above.\n\n```@docs\nbase_ring(::PolyRing)\n\n\n\n\n```@docs\nbase_ring(::PolyElem)\n\n\n\n```@docs\nparent(::PolyElem)\n\n\n\n\n```@docs\nvar(::PolyRing)\n\n\n\n```@docs\ndegree(::PolyElem)\n\n\n\n\n```@docs\nmodulus{T \n: ResElem}(::PolyElem{T})\n\n\n\n```@docs\nlead(::PolyElem)\n\n\n\n\n```@docs\niszero(::PolyElem)\n\n\n\n```@docs\nisone(::PolyElem)\n\n\n\n\n```@docs\nisgen(::PolyElem)\n\n\n\n```@docs\nisunit(::PolyElem)\n\n\n\n\n```@docs\nden(::fmpq_poly)\n\n\n\nHere are some examples of basic manipulation of polynomials.\n\n\n\n\n\nR, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\nT, z = PolynomialRing(QQ, \"z\")\n\n\na = zero(S)\nb = one(S)\n\n\nc = ZZ(1)//2\nz^2 + ZZ(1)//3\nd = x\ny^2 + (x + 1)*y + 3\n\n\nU = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)\n\n\nf = lead(d)\n\n\ng = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)\n\n\n\n## Arithmetic operators\n\nAll the usual arithmetic operators are overloaded for Nemo polynomials. Note\nthat Julia uses the single slash for floating point division. Therefore to\nperform exact division in a ring we use `divexact`. To construct an element\nof a fraction field one can use the double slash operator `//`.\n\n```@docs\n-(::PolyElem)\n\n\n\n\n```@docs\n+{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\n-{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n\n```@docs\n*{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\ndivexact(::PolyElem, ::PolyElem)\n\n\n\n\nThe following ad hoc operators are also provided.\n\n\n```@docs\n+(::Integer, ::PolyElem)\n\n\n\n```@docs\n+(::PolyElem, ::Integer)\n\n\n\n\n```@docs\n+(::fmpz, ::PolyElem)\n\n\n\n```@docs\n+(::PolyElem, ::fmpz)\n\n\n\n\n```@docs\n+{T \n: RingElem}(::T, ::PolyElem{T})\n\n\n\n```@docs\n+{T \n: RingElem}(::PolyElem, ::T)\n\n\n\n\n```@docs\n-(::Integer, ::PolyElem)\n\n\n\n```@docs\n-(::PolyElem, ::Integer)\n\n\n\n\n```@docs\n-(::fmpz, ::PolyElem)\n\n\n\n```@docs\n-(::PolyElem, ::fmpz)\n\n\n\n\n```@docs\n-{T \n: RingElem}(::T, ::PolyElem{T})\n\n\n\n```@docs\n-{T \n: RingElem}(::PolyElem, ::T)\n\n\n\n\n```@docs\n*(::Integer, ::PolyElem)\n\n\n\n```@docs\n*(::PolyElem, ::Integer)\n\n\n\n\n```@docs\n*(::fmpz, ::PolyElem)\n\n\n\n```@docs\n*(::PolyElem, ::fmpz)\n\n\n\n\n```@docs\n*{T \n: RingElem}(::T, ::PolyElem{T})\n\n\n\n```@docs\n*{T \n: RingElem}(::PolyElem, ::T)\n\n\n\n\n```@docs\ndivexact(::PolyElem, ::Integer)\n\n\n\n```@docs\ndivexact(::PolyElem, ::fmpz)\n\n\n\n\n```@docs\ndivexact{T \n: RingElem}(::PolyElem{T}, ::T)\n\n\n\n```@docs\n^(::PolyElem, ::Int)\n\n\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also\nbe used with elements of other rings. Nemo will try to coerce the operands to\nthe dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for polynomials in Nemo.\n\n\n```@docs\n=={T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\nisequal{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n```@docs\n=={T \n: RingElem}(::PolyElem{T}, ::T)\n\n\n\n```@docs\n=={T \n: RingElem}(::T, ::PolyElem{T})\n\n\n\n\n```@docs\n==(::PolyElem, ::Integer)\n\n\n\n```@docs\n==(::Integer, ::PolyElem)\n\n\n\n\n```@docs\n==(::PolyElem, ::fmpz)\n\n\n\n```@docs\n==(::fmpz, ::PolyElem)\n\n\n\n\nHere are some examples of comparisons.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)\n\n\n\n\nTruncation\n\n\n```@docs\ntruncate(::PolyElem, ::Int)\n\n\n\n```@docs\nmullow{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T}, ::Int)\n\n\n\n\nHere are some examples of truncated operations.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)\n\n\n\n\nReversal\n\n\n```@docs\nreverse(::PolyElem, ::Int)\n\n\n\n```@docs\nreverse(::PolyElem)\n\n\n\n\nHere are some examples of reversal.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)\n\n\n\n\nShifting\n\n\n```@docs\nshift_left(::PolyElem, ::Int)\n\n\n\n```@docs\nshift_right(::PolyElem, ::Int)\n\n\n\n\nHere are some examples of shifting.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)\n\n\n\n\nModulo arithmetic\n\n\nFor polynomials over a field or residue ring, we can reduce modulo a given\npolynomial. This isn't always well-defined in the case of a residue ring,\nbut when it is well-defined, we obtain the correct result. If Nemo encounters\nan impossible inverse, an exception will be raised.\n\n\n```@docs\nmulmod{T \n: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\npowmod{T \n: Union{ResElem, FieldElem}}(::PolyElem{T}, ::Int, ::PolyElem{T})\n\n\n\n\n```@docs\npowmod(::fmpz_mod_poly, ::fmpz, ::fmpz_mod_poly)\n\n\n\n```@docs\ninvmod{T \n: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n\nHere are some examples of modular arithmetic.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S, \ny\n)\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)\n\n\n\n\nEuclidean division\n\n\nFor polynomials over a field, we have a euclidean domain, and in many cases for\npolynomials over a residue ring things behave as though we had a euclidean\ndomain so long as we don't hit an impossible inverse. For such rings we define\neuclidean division of polynomials. If an impossible inverse is hit, we raise an\nexception.\n\n\n```@docs\nmod{T \n: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\ndivrem{T \n: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n\nHere are some examples of euclidean division.\n\n\nR = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T, \ny\n)\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)\n\n\n\n\nPseudodivision\n\n\nGiven two polynomials \na, b\n, pseudodivision computes polynomials \nq\n and \nr\n\nwith length\n(r) <\n length\n(b)\n such that\n\nL^d a = bq + r,\n\nwhere \nd =\n length\n(a) -\n length\n(b) + 1\n and \nL\n is the leading coefficient\nof \nb\n.\n\n\nWe call \nq\n the pseudoquotient and \nr\n the pseudoremainder.\n\n\n```@docs\npseudorem{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\npseudodivrem{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n\nHere are some examples of pseudodivision.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)\n\n\n\n\nContent, primitive part, GCD and LCM\n\n\nIn Nemo, we allow computation of the greatest common divisor of polynomials\nover any ring. This is enabled by making use of pseudoremainders when we\naren't working over a euclidean domain or something mimicking such a domain.\nIn certain cases this allows us to return a greatest common divisor when it\notherwise wouldn't be possible. However, a greatest common divisor is not\nnecessarily unique, or even well-defined.\n\n\nIf an impossible inverse is encountered whilst computing the greatest common\ndivisor, an exception is thrown.\n\n\n```@docs\ngcd{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\nlcm{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n\n```@docs\ncontent(::PolyElem)\n\n\n\n```@docs\nprimpart(::PolyElem)\n\n\n\n\n```@docs\ngcdx{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\ngcdx{T \n: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n\n```@docs\ngcdinv{T \n: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})\n\n\n\nHere are some examples of content, primitive part and GCD.\n\n\n\n\n\nR, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\n\n\nk = x\ny^2 + (x + 1)\ny + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1\n\n\nn = content(k)\np = primpart(k\n(x^2 + 1))\nq = gcd(k\nm, l\nm)\nr = lcm(k\nm, l*m)\n\n\nR, x = PolynomialRing(QQ, \"x\")\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T, \"z\")\n\n\ng = z^3 + 2z + 1\nh = z^5 + 1\n\n\nr, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)\n\n\n\n## Evaluation, composition and substitution\n\n```@docs\nevaluate{T \n: RingElem}(::PolyElem{T}, ::T)\n\n\n\n\n```@docs\nevaluate(::PolyElem, ::Integer)\n\n\n\n```@docs\nevaluate(::PolyElem, ::fmpz)\n\n\n\n\n```@docs\ncompose(::PolyElem, ::PolyElem)\n\n\n\n```@docs\nsubst{T \n: RingElem}(::PolyElem{T}, ::Any)\n\n\n\n\nWe also overload the functional notation so that the polynomial \nf\n can be\nevaluated at \na\n by writing \nf(a)\n. This feature is only available with \nJulia 0.5 however.\n\n\nHere are some examples of polynomial evaluation, composition and substitution.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nM = R[x + 1 2x; x - 3 2x - 1]\n\nh = evaluate(f, 3)\nk = evaluate(f, x^2 + 2x + 1)\nm = compose(f, g)\nn = subst(f, M)\np = f(M)\nk = f(23)\n\n\n\n\nDerivative and integral\n\n\n```@docs\nderivative(::PolyElem)\n\n\n\n```@docs\nintegral{T \n: Union{ResElem, FieldElem}}(::PolyElem{T})\n\n\n\n\nHere are some examples of integral and derivative.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(QQ, \nz\n)\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U, \nw\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)   \n\n\n\n\nResultant and discriminant\n\n\n```@docs\nresultant{T \n: RingElem}(::PolyElem{T}, ::PolyElem{T})\n\n\n\n```@docs\ndiscriminant(a::PolyElem)\n\n\n\n\nHere are some examples of computing the resultant and discriminant.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)\n\n\n\n\nNewton representation\n\n\n```@docs\nmonomial_to_newton!{T \n: RingElem}(::Array{T, 1}, ::Array{T, 1})\n\n\n\n```@docs\nnewton_to_monomial!{T \n: RingElem}(::Array{T, 1}, ::Array{T, 1})\n\n\n\n\nHere are some examples of conversion to and from Newton representation.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)\n\n\n\n\nInterpolation\n\n\n```@docs\ninterpolate{T \n: RingElem}(::PolyRing, ::Array{T, 1}, ::Array{T, 1})\n\n\n\nHere is an example of interpolation.\n\n\n\n\n\nR, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\n\n\nxs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]\n\n\nf = interpolate(S, xs, ys)\n\n\n\n## Signature\n\nSignature is only available for certain coefficient rings.\n\n```@docs\nsignature(::fmpz_poly)\n\n\n\n\n```@docs\nsignature(::fmpq_poly)\n\n\n\nHere is an example of signature.\n\n\n\n\n\nR, x = PolynomialRing(ZZ, \"x\")\n\n\nf = x^3 + 3x + 1\n\n\n(r, s) = signature(f)\n\n\n\n## Lifting\n\nWhen working over a residue ring it is useful to be able to lift to the base\nring of the residue ring, e.g. from $\\mathbb{Z}/n\\mathbb{Z}$ to $\\mathbb{Z}$.\n\n```@docs\nlift(::FmpzPolyRing, ::nmod_poly)\n\n\n\n\n```@docs\nlift(::FmpzPolyRing, ::fmpz_mod_poly)\n\n\n\nHere is an example of lifting.\n\n\n\n\n\nR = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R, \"x\")\nT, y = PolynomialRing(ZZ, \"y\")\n\n\nf = x^2 + 2x + 1\n\n\na = lift(T, f)\n\n\n\n## Factorisation\n\nPolynomials can only be factorised over certain rings. In general we use the\nsame format for the output as the Julia factorisation function, namely an\nassociative array with polynomial factors as keys and exponents as values.\n\n```@docs\nisirreducible(::nmod_poly)\n\n\n\n\n```@docs\nisirreducible(::fmpz_mod_poly)\n\n\n\n```@docs\nissquarefree(::nmod_poly)\n\n\n\n\n```@docs\nissquarefree(::fmpz_mod_poly)\n\n\n\n```@docs\nfactor(::nmod_poly)\n\n\n\n\n```@docs\nfactor(::fmpz_mod_poly)\n\n\n\n```@docs\nfactor_squarefree(::nmod_poly)\n\n\n\n\n```@docs\nfactor_squarefree(::fmpz_mod_poly)\n\n\n\n```@docs\nfactor_distinct_deg(::nmod_poly)\n\n\n\n\n```@docs\nfactor_distinct_deg(::fmpz_mod_poly)\n\n\n\nHere are some examples of factorisation.\n\n\n\n\n\nR = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R, \"x\")\n\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\n\nR = factor(f\ng)\nS = factor_squarefree(f\ng)\nT = factor_distinct_deg((x + 1)\ng\n(x^5+x^3+x+1))\n\n\n\n## Special functions\n\nThe following special functions can be computed for any polynomial ring.\nTypically one uses the generator $x$ of a polynomial ring to get the respective\nspecial polynomials expressed in terms of that generator.\n\n```@docs\nchebyshev_t(::Int, ::PolyElem)\n\n\n\n\n```@docs\nchebyshev_u(::Int, ::PolyElem)\n\n\n\nThe following special polynomials are only available for certain base rings.\n\n```@docs\ncyclotomic(::Int, ::fmpz_poly)\n\n\n\n\n```@docs\nswinnerton_dyer(::Int, ::fmpz_poly)\n\n\n\n```@docs\ncos_minpoly(::Int, ::fmpz_poly)\n\n\n\n\n```@docs\ntheta_qexp(::Int, ::Int, ::fmpz_poly)\n\n\n\n```@docs\neta_qexp(::Int, ::Int, ::fmpz_poly)\n\n\n\n\nHere are some examples of special functions.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Univariate polynomials"
        }, 
        {
            "location": "/src/polynomial/#polynomial-element-constructors", 
            "text": "Once a polynomial ring is constructed, there are various ways to construct\npolynomials in that ring.  The easiest way is simply using the generator returned by the  PolynomialRing \nconstructor and and build up the polynomial using basic arithmetic. Julia has\nquite flexible notation for the construction of polynomials in this way.  In addition we provide the following functions for constructing certain useful\npolynomials.  ```@docs\nzero(::PolyRing)  \n```@docs\none(::PolyRing)  ```@docs\ngen(::PolyRing)  \nHere are some examples of constructing polynomials.  R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")  f = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1  h = zero(S)\nk = one(R)\nm = gen(S)  \n## Basic manipulation\n\nNumerous functions are provided to manipulate polynomials and to set and\nretrieve coefficients and other basic data associated with the polynomials.\nAlso see the section on basic functionality above.\n\n```@docs\nbase_ring(::PolyRing)  ```@docs\nbase_ring(::PolyElem)  \n```@docs\nparent(::PolyElem)  ```@docs\nvar(::PolyRing)  \n```@docs\ndegree(::PolyElem)  ```@docs\nmodulus{T  : ResElem}(::PolyElem{T})  \n```@docs\nlead(::PolyElem)  ```@docs\niszero(::PolyElem)  \n```@docs\nisone(::PolyElem)  ```@docs\nisgen(::PolyElem)  \n```@docs\nisunit(::PolyElem)  ```@docs\nden(::fmpq_poly)  \nHere are some examples of basic manipulation of polynomials.  R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")\nT, z = PolynomialRing(QQ, \"z\")  a = zero(S)\nb = one(S)  c = ZZ(1)//2 z^2 + ZZ(1)//3\nd = x y^2 + (x + 1)*y + 3  U = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)  f = lead(d)  g = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)  \n## Arithmetic operators\n\nAll the usual arithmetic operators are overloaded for Nemo polynomials. Note\nthat Julia uses the single slash for floating point division. Therefore to\nperform exact division in a ring we use `divexact`. To construct an element\nof a fraction field one can use the double slash operator `//`.\n\n```@docs\n-(::PolyElem)  ```@docs\n+{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\n-{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  ```@docs\n*{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\ndivexact(::PolyElem, ::PolyElem)  The following ad hoc operators are also provided.  ```@docs\n+(::Integer, ::PolyElem)  \n```@docs\n+(::PolyElem, ::Integer)  ```@docs\n+(::fmpz, ::PolyElem)  \n```@docs\n+(::PolyElem, ::fmpz)  ```@docs\n+{T  : RingElem}(::T, ::PolyElem{T})  \n```@docs\n+{T  : RingElem}(::PolyElem, ::T)  ```@docs\n-(::Integer, ::PolyElem)  \n```@docs\n-(::PolyElem, ::Integer)  ```@docs\n-(::fmpz, ::PolyElem)  \n```@docs\n-(::PolyElem, ::fmpz)  ```@docs\n-{T  : RingElem}(::T, ::PolyElem{T})  \n```@docs\n-{T  : RingElem}(::PolyElem, ::T)  ```@docs\n*(::Integer, ::PolyElem)  \n```@docs\n*(::PolyElem, ::Integer)  ```@docs\n*(::fmpz, ::PolyElem)  \n```@docs\n*(::PolyElem, ::fmpz)  ```@docs\n*{T  : RingElem}(::T, ::PolyElem{T})  \n```@docs\n*{T  : RingElem}(::PolyElem, ::T)  ```@docs\ndivexact(::PolyElem, ::Integer)  \n```@docs\ndivexact(::PolyElem, ::fmpz)  ```@docs\ndivexact{T  : RingElem}(::PolyElem{T}, ::T)  \n```@docs\n^(::PolyElem, ::Int)  If the appropriate  promote_rule  and coercion exists, these operators can also\nbe used with elements of other rings. Nemo will try to coerce the operands to\nthe dominating type and then apply the operator.  Here are some examples of arithmetic operations on polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3", 
            "title": "Polynomial element constructors"
        }, 
        {
            "location": "/src/polynomial/#comparison-operators", 
            "text": "The following comparison operators are implemented for polynomials in Nemo.  ```@docs\n=={T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\nisequal{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  In addition we have the following ad hoc comparison operators.  ```@docs\n=={T  : RingElem}(::PolyElem{T}, ::T)  \n```@docs\n=={T  : RingElem}(::T, ::PolyElem{T})  ```@docs\n==(::PolyElem, ::Integer)  \n```@docs\n==(::Integer, ::PolyElem)  ```@docs\n==(::PolyElem, ::fmpz)  \n```@docs\n==(::fmpz, ::PolyElem)  Here are some examples of comparisons.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/src/polynomial/#truncation", 
            "text": "```@docs\ntruncate(::PolyElem, ::Int)  \n```@docs\nmullow{T  : RingElem}(::PolyElem{T}, ::PolyElem{T}, ::Int)  Here are some examples of truncated operations.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)", 
            "title": "Truncation"
        }, 
        {
            "location": "/src/polynomial/#reversal", 
            "text": "```@docs\nreverse(::PolyElem, ::Int)  \n```@docs\nreverse(::PolyElem)  Here are some examples of reversal.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)", 
            "title": "Reversal"
        }, 
        {
            "location": "/src/polynomial/#shifting", 
            "text": "```@docs\nshift_left(::PolyElem, ::Int)  \n```@docs\nshift_right(::PolyElem, ::Int)  Here are some examples of shifting.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)", 
            "title": "Shifting"
        }, 
        {
            "location": "/src/polynomial/#modulo-arithmetic", 
            "text": "For polynomials over a field or residue ring, we can reduce modulo a given\npolynomial. This isn't always well-defined in the case of a residue ring,\nbut when it is well-defined, we obtain the correct result. If Nemo encounters\nan impossible inverse, an exception will be raised.  ```@docs\nmulmod{T  : Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T}, ::PolyElem{T})  \n```@docs\npowmod{T  : Union{ResElem, FieldElem}}(::PolyElem{T}, ::Int, ::PolyElem{T})  ```@docs\npowmod(::fmpz_mod_poly, ::fmpz, ::fmpz_mod_poly)  \n```@docs\ninvmod{T  : Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})  Here are some examples of modular arithmetic.  R, x = PolynomialRing(QQ,  x )\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S,  y )\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)", 
            "title": "Modulo arithmetic"
        }, 
        {
            "location": "/src/polynomial/#euclidean-division", 
            "text": "For polynomials over a field, we have a euclidean domain, and in many cases for\npolynomials over a residue ring things behave as though we had a euclidean\ndomain so long as we don't hit an impossible inverse. For such rings we define\neuclidean division of polynomials. If an impossible inverse is hit, we raise an\nexception.  ```@docs\nmod{T  : Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\ndivrem{T  : Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})  Here are some examples of euclidean division.  R = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T,  y )\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)", 
            "title": "Euclidean division"
        }, 
        {
            "location": "/src/polynomial/#pseudodivision", 
            "text": "Given two polynomials  a, b , pseudodivision computes polynomials  q  and  r \nwith length (r) <  length (b)  such that L^d a = bq + r, \nwhere  d =  length (a) -  length (b) + 1  and  L  is the leading coefficient\nof  b .  We call  q  the pseudoquotient and  r  the pseudoremainder.  ```@docs\npseudorem{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\npseudodivrem{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  Here are some examples of pseudodivision.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)", 
            "title": "Pseudodivision"
        }, 
        {
            "location": "/src/polynomial/#content-primitive-part-gcd-and-lcm", 
            "text": "In Nemo, we allow computation of the greatest common divisor of polynomials\nover any ring. This is enabled by making use of pseudoremainders when we\naren't working over a euclidean domain or something mimicking such a domain.\nIn certain cases this allows us to return a greatest common divisor when it\notherwise wouldn't be possible. However, a greatest common divisor is not\nnecessarily unique, or even well-defined.  If an impossible inverse is encountered whilst computing the greatest common\ndivisor, an exception is thrown.  ```@docs\ngcd{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\nlcm{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  ```@docs\ncontent(::PolyElem)  \n```@docs\nprimpart(::PolyElem)  ```@docs\ngcdx{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\ngcdx{T  : Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})  ```@docs\ngcdinv{T  : Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})  \nHere are some examples of content, primitive part and GCD.  R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")  k = x y^2 + (x + 1) y + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1  n = content(k)\np = primpart(k (x^2 + 1))\nq = gcd(k m, l m)\nr = lcm(k m, l*m)  R, x = PolynomialRing(QQ, \"x\")\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T, \"z\")  g = z^3 + 2z + 1\nh = z^5 + 1  r, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)  \n## Evaluation, composition and substitution\n\n```@docs\nevaluate{T  : RingElem}(::PolyElem{T}, ::T)  ```@docs\nevaluate(::PolyElem, ::Integer)  \n```@docs\nevaluate(::PolyElem, ::fmpz)  ```@docs\ncompose(::PolyElem, ::PolyElem)  \n```@docs\nsubst{T  : RingElem}(::PolyElem{T}, ::Any)  We also overload the functional notation so that the polynomial  f  can be\nevaluated at  a  by writing  f(a) . This feature is only available with \nJulia 0.5 however.  Here are some examples of polynomial evaluation, composition and substitution.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nM = R[x + 1 2x; x - 3 2x - 1]\n\nh = evaluate(f, 3)\nk = evaluate(f, x^2 + 2x + 1)\nm = compose(f, g)\nn = subst(f, M)\np = f(M)\nk = f(23)", 
            "title": "Content, primitive part, GCD and LCM"
        }, 
        {
            "location": "/src/polynomial/#derivative-and-integral", 
            "text": "```@docs\nderivative(::PolyElem)  \n```@docs\nintegral{T  : Union{ResElem, FieldElem}}(::PolyElem{T})  Here are some examples of integral and derivative.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(QQ,  z )\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U,  w )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)", 
            "title": "Derivative and integral"
        }, 
        {
            "location": "/src/polynomial/#resultant-and-discriminant", 
            "text": "```@docs\nresultant{T  : RingElem}(::PolyElem{T}, ::PolyElem{T})  \n```@docs\ndiscriminant(a::PolyElem)  Here are some examples of computing the resultant and discriminant.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)", 
            "title": "Resultant and discriminant"
        }, 
        {
            "location": "/src/polynomial/#newton-representation", 
            "text": "```@docs\nmonomial_to_newton!{T  : RingElem}(::Array{T, 1}, ::Array{T, 1})  \n```@docs\nnewton_to_monomial!{T  : RingElem}(::Array{T, 1}, ::Array{T, 1})  Here are some examples of conversion to and from Newton representation.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)", 
            "title": "Newton representation"
        }, 
        {
            "location": "/src/polynomial/#interpolation", 
            "text": "```@docs\ninterpolate{T  : RingElem}(::PolyRing, ::Array{T, 1}, ::Array{T, 1})  \nHere is an example of interpolation.  R, x = PolynomialRing(ZZ, \"x\")\nS, y = PolynomialRing(R, \"y\")  xs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]  f = interpolate(S, xs, ys)  \n## Signature\n\nSignature is only available for certain coefficient rings.\n\n```@docs\nsignature(::fmpz_poly)  ```@docs\nsignature(::fmpq_poly)  \nHere is an example of signature.  R, x = PolynomialRing(ZZ, \"x\")  f = x^3 + 3x + 1  (r, s) = signature(f)  \n## Lifting\n\nWhen working over a residue ring it is useful to be able to lift to the base\nring of the residue ring, e.g. from $\\mathbb{Z}/n\\mathbb{Z}$ to $\\mathbb{Z}$.\n\n```@docs\nlift(::FmpzPolyRing, ::nmod_poly)  ```@docs\nlift(::FmpzPolyRing, ::fmpz_mod_poly)  \nHere is an example of lifting.  R = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R, \"x\")\nT, y = PolynomialRing(ZZ, \"y\")  f = x^2 + 2x + 1  a = lift(T, f)  \n## Factorisation\n\nPolynomials can only be factorised over certain rings. In general we use the\nsame format for the output as the Julia factorisation function, namely an\nassociative array with polynomial factors as keys and exponents as values.\n\n```@docs\nisirreducible(::nmod_poly)  ```@docs\nisirreducible(::fmpz_mod_poly)  \n```@docs\nissquarefree(::nmod_poly)  ```@docs\nissquarefree(::fmpz_mod_poly)  \n```@docs\nfactor(::nmod_poly)  ```@docs\nfactor(::fmpz_mod_poly)  \n```@docs\nfactor_squarefree(::nmod_poly)  ```@docs\nfactor_squarefree(::fmpz_mod_poly)  \n```@docs\nfactor_distinct_deg(::nmod_poly)  ```@docs\nfactor_distinct_deg(::fmpz_mod_poly)  \nHere are some examples of factorisation.  R = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R, \"x\")  f = x^2 + 2x + 1\ng = x^3 + 3x + 1  R = factor(f g)\nS = factor_squarefree(f g)\nT = factor_distinct_deg((x + 1) g (x^5+x^3+x+1))  \n## Special functions\n\nThe following special functions can be computed for any polynomial ring.\nTypically one uses the generator $x$ of a polynomial ring to get the respective\nspecial polynomials expressed in terms of that generator.\n\n```@docs\nchebyshev_t(::Int, ::PolyElem)  ```@docs\nchebyshev_u(::Int, ::PolyElem)  \nThe following special polynomials are only available for certain base rings.\n\n```@docs\ncyclotomic(::Int, ::fmpz_poly)  ```@docs\nswinnerton_dyer(::Int, ::fmpz_poly)  \n```@docs\ncos_minpoly(::Int, ::fmpz_poly)  ```@docs\ntheta_qexp(::Int, ::Int, ::fmpz_poly)  \n```@docs\neta_qexp(::Int, ::Int, ::fmpz_poly)  Here are some examples of special functions.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Interpolation"
        }
    ]
}
{
    "docs": [
        {
            "location": "/", 
            "text": "Nemo\n\n\n\n\nIntroduction\n\n\nNemo is a computer algebra package for the Julia programming language, maintained by William Hart,  Tommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other contributors.\n\n\n\n\nhttp://nemocas.org\n (Website)\n\n\nhttps://github.com/Nemocas/Nemo.jl\n (Source code)\n\n\nhttp://nemocas.github.io/Nemo.jl/latest/\n (Online documentation)\n\n\n\n\nThe features of Nemo so far include:\n\n\n\n\nMultiprecision integers and rationals\n\n\nIntegers modulo n\n\n\np-adic numbers\n\n\nFinite fields (prime and non-prime order)\n\n\nNumber field arithmetic\n\n\nMaximal orders of number fields\n\n\nArithmetic of ideals in maximal orders\n\n\nArbitrary precision real and complex balls\n\n\nUnivariate polynomials and matrices over the above\n\n\nGeneric polynomials, power series, fraction fields, residue rings and matrices\n\n\n\n\n\n\nInstallation\n\n\nTo use Nemo we require Julia 0.4 or higher. Please see \nhttp://julialang.org/downloads\n for instructions on how to obtain julia for your system.\n\n\nAt the Julia prompt simply type\n\n\njulia\n Pkg.add(\nNemo\n)\njulia\n Pkg.build(\nNemo\n)\n\n\n\n\nAlternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on \nhttps://cloud.sagemath.com/\n.\n\n\n\n\nQuick start\n\n\nHere are some examples of using Nemo.\n\n\nThis example computes recursive univariate polynomials.\n\n\njulia\n using Nemo\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia\n T, z = PolynomialRing(S, \nz\n)\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia\n f = x + y + z + 1\nz+(y+(x+1))\n\njulia\n p = f^30; # semicolon supresses output\n\njulia\n @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)\n\n\n\n\nHere is an example using generic recursive ring constructions.\n\n\njulia\n using Nemo\n\njulia\n R, x = FiniteField(7, 11, \nx\n)\n(Finite field of degree 11 over F_7,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia\n T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia\n U, z = PolynomialRing(T, \nz\n)\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia\n f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia\n g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia\n s = f^12;\n\njulia\n t = (s + g)^12;\n\njulia\n @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)\n\n\n\n\nHere is an example using matrices.\n\n\njulia\n using Nemo\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia\n @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)\n\n\n\n\nAnd here is an example with power series.\n\n\njulia\n using Nemo\n\njulia\n R, x = QQ[\nx\n]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia\n S, t = PowerSeriesRing(R, 100, \nt\n)\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia\n u = t + O(t^100)\nt+O(t^100)\n\njulia\n @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/#introduction", 
            "text": "Nemo is a computer algebra package for the Julia programming language, maintained by William Hart,  Tommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other contributors.   http://nemocas.org  (Website)  https://github.com/Nemocas/Nemo.jl  (Source code)  http://nemocas.github.io/Nemo.jl/latest/  (Online documentation)   The features of Nemo so far include:   Multiprecision integers and rationals  Integers modulo n  p-adic numbers  Finite fields (prime and non-prime order)  Number field arithmetic  Maximal orders of number fields  Arithmetic of ideals in maximal orders  Arbitrary precision real and complex balls  Univariate polynomials and matrices over the above  Generic polynomials, power series, fraction fields, residue rings and matrices", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Nemo we require Julia 0.4 or higher. Please see  http://julialang.org/downloads  for instructions on how to obtain julia for your system.  At the Julia prompt simply type  julia  Pkg.add( Nemo )\njulia  Pkg.build( Nemo )  Alternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on  https://cloud.sagemath.com/ .", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here are some examples of using Nemo.  This example computes recursive univariate polynomials.  julia  using Nemo\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia  T, z = PolynomialRing(S,  z )\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia  f = x + y + z + 1\nz+(y+(x+1))\n\njulia  p = f^30; # semicolon supresses output\n\njulia  @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)  Here is an example using generic recursive ring constructions.  julia  using Nemo\n\njulia  R, x = FiniteField(7, 11,  x )\n(Finite field of degree 11 over F_7,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia  T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia  U, z = PolynomialRing(T,  z )\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia  f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia  g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia  s = f^12;\n\njulia  t = (s + g)^12;\n\njulia  @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)  Here is an example using matrices.  julia  using Nemo\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia  @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)  And here is an example with power series.  julia  using Nemo\n\njulia  R, x = QQ[ x ]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia  S, t = PowerSeriesRing(R, 100,  t )\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia  u = t + O(t^100)\nt+O(t^100)\n\njulia  @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Quick start"
        }, 
        {
            "location": "/about/", 
            "text": "Nemo\n\n\n\n\nWhat is Nemo?\n\n\nNemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly performant computer algebra package covering\n\n\n\n\nCommutative Algebra\n\n\nNumber Theory\n\n\nGroup Theory\n\n\n\n\nNemo consists of wrappers of specialised C/C++ libraries:\n\n\n\n\nFlint    [http://flintlib.org/]\n\n\nArb      [http://fredrikj.net/arb/]\n\n\nAntic    [https://github.com/wbhart/antic/]\n\n\nSingular [https://www.singular.uni-kl.de/]\n\n\nPari     [http://pari.math.u-bordeaux.fr/]\n\n\n\n\nIt will also eventually provide interfaces to interpreted library code from other computer algebra systems such as Gap and Singular.\n\n\nNemo also provides implementations of generic algorithms and mathematical data structures. So far the fully recursive constructions include\n\n\n\n\nUnivariate polynomial rings\n\n\nPower series rings\n\n\nResidue rings (modulo principal ideals)\n\n\nFraction fields\n\n\nMatrices\n\n\n\n\n\n\nWhy Julia?\n\n\nJulia is a sophisticated, modern programming language which is designed to be both performant and flexible. It was written by mathematicians, for mathematicians.\n\n\nThe benefits of Julia include\n\n\n\n\nFamiliar imperative syntax\n\n\nJIT compilation (provides near native performance, even for highly generic code)\n\n\nREPL console (cuts down on development time)\n\n\nParametric types (allows for fast generic constructions over other data types)\n\n\nPowerful metaprogramming facilities\n\n\nOperator overloading\n\n\nMultiple dispatch (dispatch on every argument of a function)\n\n\nEfficient native C interface (no wrapper overhead)\n\n\nExperimental C++ interface\n\n\nDynamic type inference\n\n\nBuilt-in bignums\n\n\nAble to be embedded in C programs\n\n\nHigh performance collection types (dictionaries, iterators, arrays, etc.)\n\n\nJupyter support (for web based notebooks)\n\n\n\n\nThe main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to model many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter speeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "About Nemo"
        }, 
        {
            "location": "/about/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/about/#what-is-nemo", 
            "text": "Nemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly performant computer algebra package covering   Commutative Algebra  Number Theory  Group Theory   Nemo consists of wrappers of specialised C/C++ libraries:   Flint    [http://flintlib.org/]  Arb      [http://fredrikj.net/arb/]  Antic    [https://github.com/wbhart/antic/]  Singular [https://www.singular.uni-kl.de/]  Pari     [http://pari.math.u-bordeaux.fr/]   It will also eventually provide interfaces to interpreted library code from other computer algebra systems such as Gap and Singular.  Nemo also provides implementations of generic algorithms and mathematical data structures. So far the fully recursive constructions include   Univariate polynomial rings  Power series rings  Residue rings (modulo principal ideals)  Fraction fields  Matrices", 
            "title": "What is Nemo?"
        }, 
        {
            "location": "/about/#why-julia", 
            "text": "Julia is a sophisticated, modern programming language which is designed to be both performant and flexible. It was written by mathematicians, for mathematicians.  The benefits of Julia include   Familiar imperative syntax  JIT compilation (provides near native performance, even for highly generic code)  REPL console (cuts down on development time)  Parametric types (allows for fast generic constructions over other data types)  Powerful metaprogramming facilities  Operator overloading  Multiple dispatch (dispatch on every argument of a function)  Efficient native C interface (no wrapper overhead)  Experimental C++ interface  Dynamic type inference  Built-in bignums  Able to be embedded in C programs  High performance collection types (dictionaries, iterators, arrays, etc.)  Jupyter support (for web based notebooks)   The main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to model many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter speeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "Why Julia?"
        }, 
        {
            "location": "/types/", 
            "text": "Types in Nemo\n\n\nOn this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are quite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with directly when scripting Nemo to do mathematical computations. \n\n\nIn contrast, Nemo developers will certainly want to know how we model mathematical objects and the rings, fields, groups, etc. that they belong to in Nemo.\n\n\n\n\nIntroduction\n\n\nJulia provides two levels of types that we make use of\n\n\n\n\nabstract types\n\n\nconcrete types\n\n\n\n\nConcrete types are just like the usual types everyone is familiar with from C or C++.\n\n\nAbstract types can be thought of as collections of types. They are used when writing generic functions that should work for any type in the given collection.\n\n\nTo write a generic function that accepts any type in a given collection of types, we first create an abstract type. Then we create the individual concrete types that belong to that abstract type. A generic function can then be constructed with a type parameter, \nT\n say, similar to a template parameter in C++. The main difference is that we can specify which abstract type our type parameter \nT\n must belong to.\n\n\nWe use the symbol \n:\n in Julia to determine that a given type belongs to a given abstract type. For example the built-in Julia type \nInt64\n for 64 bit machine integers belongs to the Julia abstract type \nInteger\n. Thus \nInt \n: Integer\n returns \ntrue\n.\n\n\nHere is some Julia code illustrating this with a more complex example. We create an abstract type called \nShape\n and two user defined concrete types \nsquare\n and \ncircle\n belonging to \nShape\n. We then show how to write methods that accept each of the concrete types and then show how to write a generic function for any type \nT\n belonging to the abstract type \nShape\n.\n\n\nNote that in the type definitions of \nsquare\n and \ncircle\n we specify that those types belong to the abstract type \nShape\n using the \n:\n operator.\n\n\nabstract Shape\n\ntype square \n: Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle \n: Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T \n: Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)\n\n\n\n\n\n\nThe abstract type hierarchy in Nemo\n\n\nAbstract types in Julia can also belong to one another in a hierarchy. For example, the \nNemo.Field\n abstract type belongs to the \nNemo.Ring\n abstract type. An object representing a field in Nemo has type belonging to \nNemo.Field\n. But because we define the inclusion \nNemo.Field \n: Nemo.Ring\n in Nemo, the type of such an object also automatically belongs to \nNemo.Ring\n. This means that any generic function in Nemo which is designed to work with ring objects will certainly also work with field objects.\n\n\nIn Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly for groups and rings and all other kinds of domains in Nemo. For example, we have an object of type \nGenPolyRing\n to model a generic polynomial ring, and elements of that polynomial ring would have type \nGenPoly\n. \n\n\nIn order to model this distinction between elements and the domains they belong to, Nemo has two main branches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the abstract types for the domains available in Nemo and the other branch is for the abstract types for elements of those domains. \n\n\n\n\nAll objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring elements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract types shown above.\n\n\n\n\nWhy types aren't enough\n\n\nNaively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the given type. But there are various reasons why this is not a good model.\n\n\nAs an example, consider the ring \nR = \\mathbb{Z}/n\\mathbb{Z}\n for a multiprecision integer \nn\n. If we were to model the ring \nR\n as a type, then the type would somehow need to contain the modulus \nn\n. This is not possible in Julia, and in fact it is not desirable either.\n\n\nJulia dispatches on type, and each time we call a generic function with different types, a new version of the function is compiled at runtime for performance. But this would be a disaster if we were writing a multimodular algorithm, say. In such an algorithm many rings \n\\mathbb{Z}/n\\mathbb{Z}\n would be needed and every function we use would be recompiled over and over for each different \nn\n. This would result  in a huge delay as the compiler is invoked many times.\n\n\nFor this reason, the modulus \nn\n needs to be attached to the \nelements\n of the ring, not to type associated with those elements.\n\n\nBut now we have a problem. How do we create new elements of the ring \n\\mathbb{Z}/n\\mathbb{Z}\n given only the type? Suppose all rings \n\\mathbb{Z}/n\\mathbb{Z}\n were represented by the same type \nZmod\n say. How would we create \na = 3 \\pmod{7}\n? We could not write \na = Zmod(3)\n since the modulus \n7\n is not contained in the type \nZmod\n.\n\n\nWe could of course use the notation \na = Zmod(3, 7)\n, but this would make implementation of generic algorithms very difficult, as they would need to distinguish the case where constructors take a single argument, such as \na = ZZ(7)\n and cases where they take a modulus, such as \na = Zmod(3, 7)\n.\n\n\nThe way we get around this in Nemo is to have special (singleton) objects that act like types, but are really just ordinary Julia objects. These objects, called \nparent\n objects can contain extra information, such as the modulus \nn\n. \n\n\nIn order to create new elements of \n\\mathbb{Z}/n\\mathbb{Z}\n as above, we overload the \ncall\n operator for the parent object, making it callable. Making a parent object callable is exactly analogous to writing a constructor for a type.\n\n\nIn the following Nemo example, we create the parent object \nR\n corresponding to the ring \n\\mathbb{Z}/7\\mathbb{Z}\n. We then create a new element \na\n of this ring by calling the parent object \nR\n, just as though \nR\n were a type with a constructor accepting an \nInt\n parameter. \n\n\nR = ResidueRing(ZZ, 7)\na = R(3)\n\n\n\n\nThis example creates the element \na = 3 \\pmod{7}\n. \n\n\nThe important point is that unlike a type, a parent object such as \nR\n can contain additional information that a type cannot contain, such as the modulus \n7\n of the ring in this example, or context objects required by C libraries in other examples.\n\n\n\n\nMore complex example of parent objects\n\n\nHere is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that ring and then does some introspection to illustrate the various relations between the objects and types.\n\n\njulia\n using Nemo\n\njulia\n R, x = ZZ[\nx\n]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia\n typeof(R)\nNemo.FmpzPolyRing\n\njulia\n typeof(f)\nNemo.fmpz_poly\n\njulia\n parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia\n typeof(R) \n: PolyRing\ntrue\n\njulia\n typeof(f) \n: PolyElem\ntrue\n\njulia\n parent(f) == R\ntrue\n\n\n\n\n\n\nConcrete types in Nemo\n\n\nFinally we come to all the concrete types in Nemo. \n\n\nThese are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary ring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the integers, provided by Flint).\n\n\nBelow we give the type of each kind of element available in Nemo. In parentheses we list the types of their corresponding parent objects. Note that these are the types of the element objects and parent objects respectively, not the abstract types to which these types belong, which the reader can easily guess. \n\n\nFor example, \nfmpz\n belongs to the abstract type \nRingElem\n and \nFlintIntegerRing\n belongs to \nRing\n. Similarly \nPoly{T}\n belongs to \nPolyElem\n whereas \nPolynomialRing{T}\n belongs to \nPolyRing\n. We also have that \nfmpz_poly\n belongs to \nPolyElem\n and \nFmpzPolyRing\n belongs to \nPolyRing\n, and so on.\n\n\nAll the generic types are parameterised by a type \nT\n which is the type of the \nelements\n of the ring they are defined over. \n\n\n\n\n\n\nGeneric\n\n\n\n\nGenPoly{T}\n (\nGenPolyRing{T}\n)\n\n\nGenRelSeries{T}\n (\nGenRelSeriesRing{T}\n)\n\n\nGenRes{T}\n (\nGenResRing{T}\n)\n\n\nGenFrac{T}\n (\nGenFracField{T}\n)\n\n\nGenMat{T}\n (\nGenMatSpace{T}\n)\n\n\n\n\nFlint\n\n\n\n\n\n\nfmpz\n (\nFlintIntegerRing\n)\n\n\n\n\nfmpq\n (\nFlintRationalField\n)\n\n\nfq_nmod\n (\nFqNmodFiniteField\n)\n\n\nfq\n (\nFqFiniteField\n)\n\n\npadic\n (\nFlintPadicField\n)\n\n\nfmpz_poly\n (\nFmpzPolyRing\n)\n\n\nfmpq_poly\n (\nFmpqPolyRing\n)\n\n\nnmod_poly\n (\nNmodPolyRing\n)\n\n\nfmpz_mod_poly\n (\nFmpzModPolyRing\n)\n\n\nfq_poly\n (\nFqPolyRing\n)\n\n\nfq_nmod_poly\n (\nFqNmodPolyRing\n)\n\n\nfmpz_rel_series\n (\nFmpzRelSeriesRing\n)\n\n\nfmpq_rel_series\n (\nFmpqRelSeriesRing\n)\n\n\nfmpz_mod_rel_series\n (\nFmpzModRelSeriesRing\n)\n\n\nfq_nmod_rel_series\n (\nFqNmodRelSeriesRing\n)\n\n\nfq_rel_series\n (\nFqRelSeriesRing\n)\n\n\nfmpz_mat\n (\nFmpzMatSpace\n)\n\n\nnmod_mat\n (\nNmodMatSpace\n)\n\n\nperm\n (\nPermGroup\n)\n\n\n\n\nAntic\n\n\n\n\n\n\nnf_elem\n (\nAnticNumberField\n)\n\n\n\n\n\n\nArb\n\n\n\n\n\n\narb\n (\nArbField\n)\n\n\n\n\nacb\n (\nAcbField\n)", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#types-in-nemo", 
            "text": "On this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are quite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with directly when scripting Nemo to do mathematical computations.   In contrast, Nemo developers will certainly want to know how we model mathematical objects and the rings, fields, groups, etc. that they belong to in Nemo.", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#introduction", 
            "text": "Julia provides two levels of types that we make use of   abstract types  concrete types   Concrete types are just like the usual types everyone is familiar with from C or C++.  Abstract types can be thought of as collections of types. They are used when writing generic functions that should work for any type in the given collection.  To write a generic function that accepts any type in a given collection of types, we first create an abstract type. Then we create the individual concrete types that belong to that abstract type. A generic function can then be constructed with a type parameter,  T  say, similar to a template parameter in C++. The main difference is that we can specify which abstract type our type parameter  T  must belong to.  We use the symbol  :  in Julia to determine that a given type belongs to a given abstract type. For example the built-in Julia type  Int64  for 64 bit machine integers belongs to the Julia abstract type  Integer . Thus  Int  : Integer  returns  true .  Here is some Julia code illustrating this with a more complex example. We create an abstract type called  Shape  and two user defined concrete types  square  and  circle  belonging to  Shape . We then show how to write methods that accept each of the concrete types and then show how to write a generic function for any type  T  belonging to the abstract type  Shape .  Note that in the type definitions of  square  and  circle  we specify that those types belong to the abstract type  Shape  using the  :  operator.  abstract Shape\n\ntype square  : Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle  : Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T  : Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)", 
            "title": "Introduction"
        }, 
        {
            "location": "/types/#the-abstract-type-hierarchy-in-nemo", 
            "text": "Abstract types in Julia can also belong to one another in a hierarchy. For example, the  Nemo.Field  abstract type belongs to the  Nemo.Ring  abstract type. An object representing a field in Nemo has type belonging to  Nemo.Field . But because we define the inclusion  Nemo.Field  : Nemo.Ring  in Nemo, the type of such an object also automatically belongs to  Nemo.Ring . This means that any generic function in Nemo which is designed to work with ring objects will certainly also work with field objects.  In Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly for groups and rings and all other kinds of domains in Nemo. For example, we have an object of type  GenPolyRing  to model a generic polynomial ring, and elements of that polynomial ring would have type  GenPoly .   In order to model this distinction between elements and the domains they belong to, Nemo has two main branches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the abstract types for the domains available in Nemo and the other branch is for the abstract types for elements of those domains.    All objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring elements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract types shown above.", 
            "title": "The abstract type hierarchy in Nemo"
        }, 
        {
            "location": "/types/#why-types-arent-enough", 
            "text": "Naively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the given type. But there are various reasons why this is not a good model.  As an example, consider the ring  R = \\mathbb{Z}/n\\mathbb{Z}  for a multiprecision integer  n . If we were to model the ring  R  as a type, then the type would somehow need to contain the modulus  n . This is not possible in Julia, and in fact it is not desirable either.  Julia dispatches on type, and each time we call a generic function with different types, a new version of the function is compiled at runtime for performance. But this would be a disaster if we were writing a multimodular algorithm, say. In such an algorithm many rings  \\mathbb{Z}/n\\mathbb{Z}  would be needed and every function we use would be recompiled over and over for each different  n . This would result  in a huge delay as the compiler is invoked many times.  For this reason, the modulus  n  needs to be attached to the  elements  of the ring, not to type associated with those elements.  But now we have a problem. How do we create new elements of the ring  \\mathbb{Z}/n\\mathbb{Z}  given only the type? Suppose all rings  \\mathbb{Z}/n\\mathbb{Z}  were represented by the same type  Zmod  say. How would we create  a = 3 \\pmod{7} ? We could not write  a = Zmod(3)  since the modulus  7  is not contained in the type  Zmod .  We could of course use the notation  a = Zmod(3, 7) , but this would make implementation of generic algorithms very difficult, as they would need to distinguish the case where constructors take a single argument, such as  a = ZZ(7)  and cases where they take a modulus, such as  a = Zmod(3, 7) .  The way we get around this in Nemo is to have special (singleton) objects that act like types, but are really just ordinary Julia objects. These objects, called  parent  objects can contain extra information, such as the modulus  n .   In order to create new elements of  \\mathbb{Z}/n\\mathbb{Z}  as above, we overload the  call  operator for the parent object, making it callable. Making a parent object callable is exactly analogous to writing a constructor for a type.  In the following Nemo example, we create the parent object  R  corresponding to the ring  \\mathbb{Z}/7\\mathbb{Z} . We then create a new element  a  of this ring by calling the parent object  R , just as though  R  were a type with a constructor accepting an  Int  parameter.   R = ResidueRing(ZZ, 7)\na = R(3)  This example creates the element  a = 3 \\pmod{7} .   The important point is that unlike a type, a parent object such as  R  can contain additional information that a type cannot contain, such as the modulus  7  of the ring in this example, or context objects required by C libraries in other examples.", 
            "title": "Why types aren't enough"
        }, 
        {
            "location": "/types/#more-complex-example-of-parent-objects", 
            "text": "Here is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that ring and then does some introspection to illustrate the various relations between the objects and types.  julia  using Nemo\n\njulia  R, x = ZZ[ x ]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia  typeof(R)\nNemo.FmpzPolyRing\n\njulia  typeof(f)\nNemo.fmpz_poly\n\njulia  parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia  typeof(R)  : PolyRing\ntrue\n\njulia  typeof(f)  : PolyElem\ntrue\n\njulia  parent(f) == R\ntrue", 
            "title": "More complex example of parent objects"
        }, 
        {
            "location": "/types/#concrete-types-in-nemo", 
            "text": "Finally we come to all the concrete types in Nemo.   These are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary ring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the integers, provided by Flint).  Below we give the type of each kind of element available in Nemo. In parentheses we list the types of their corresponding parent objects. Note that these are the types of the element objects and parent objects respectively, not the abstract types to which these types belong, which the reader can easily guess.   For example,  fmpz  belongs to the abstract type  RingElem  and  FlintIntegerRing  belongs to  Ring . Similarly  Poly{T}  belongs to  PolyElem  whereas  PolynomialRing{T}  belongs to  PolyRing . We also have that  fmpz_poly  belongs to  PolyElem  and  FmpzPolyRing  belongs to  PolyRing , and so on.  All the generic types are parameterised by a type  T  which is the type of the  elements  of the ring they are defined over.     Generic   GenPoly{T}  ( GenPolyRing{T} )  GenRelSeries{T}  ( GenRelSeriesRing{T} )  GenRes{T}  ( GenResRing{T} )  GenFrac{T}  ( GenFracField{T} )  GenMat{T}  ( GenMatSpace{T} )   Flint    fmpz  ( FlintIntegerRing )   fmpq  ( FlintRationalField )  fq_nmod  ( FqNmodFiniteField )  fq  ( FqFiniteField )  padic  ( FlintPadicField )  fmpz_poly  ( FmpzPolyRing )  fmpq_poly  ( FmpqPolyRing )  nmod_poly  ( NmodPolyRing )  fmpz_mod_poly  ( FmpzModPolyRing )  fq_poly  ( FqPolyRing )  fq_nmod_poly  ( FqNmodPolyRing )  fmpz_rel_series  ( FmpzRelSeriesRing )  fmpq_rel_series  ( FmpqRelSeriesRing )  fmpz_mod_rel_series  ( FmpzModRelSeriesRing )  fq_nmod_rel_series  ( FqNmodRelSeriesRing )  fq_rel_series  ( FqRelSeriesRing )  fmpz_mat  ( FmpzMatSpace )  nmod_mat  ( NmodMatSpace )  perm  ( PermGroup )   Antic    nf_elem  ( AnticNumberField )    Arb    arb  ( ArbField )   acb  ( AcbField )", 
            "title": "Concrete types in Nemo"
        }, 
        {
            "location": "/constructors/", 
            "text": "Constructing mathematical objects in Nemo\n\n\n\n\nConstructing objects in Julia\n\n\nIn Julia, one constructs objects of a given type by calling a type constructor. This is simply a function with the same name as the type itself. For example, to construct a \nBigInt\n object in Julia, we simply call the \nBigInt\n constructor:\n\n\nn = BigInt(\n1234567898765434567898765434567876543456787654567890\n)\n\n\n\n\nJulia also uses constructors to convert between types. For example, to convert an \nInt\n to a \nBigInt\n:\n\n\nm = BigInt(123)\n\n\n\n\n\n\nHow we construct objects in Nemo\n\n\nAs we explained in the previous section, Julia types don't contain enough information to properly model the ring of integers modulo \nn\n for a multiprecision modulus \nn\n. Instead of using types to construct objects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.\n\n\nConsider the following simple example, to create a Flint multiprecision integer:\n\n\nn = ZZ(\n12345678765456787654567890987654567898765678909876567890\n)\n\n\n\n\nHere \nZZ\n is not a Julia type, but a callable object. However, for most purposes one can think of such a parent object \nZZ\n as though it were a type.\n\n\n\n\nConstructing parent objects\n\n\nFor more complicated groups, rings, fields, etc., one first needs to construct the parent object before one can use it to construct element objects.\n\n\nNemo provides a set of functions for constructing such parent objects. For example, to create a parent object for polynomials over the integers, we use the \nPolynomialRing\n parent object constructor.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nf = x^3 + 3x + 1\ng = R(12)\n\n\n\n\nIn this example, \nR\n is the parent object and we use it to convert the \nInt\n value \n12\n to an element of the polynomial ring \n\\mathbb{Z}[x]\n.\n\n\n\n\nList of parent object constructors\n\n\nFor convenience, we provide a list of all the parent object constructors in Nemo and explain what domains they represent.\n\n\n\n\n\n\n\n\nMathematics\n\n\nNemo constructor\n\n\n\n\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}\n\n\n\n\nR = ZZ\n\n\n\n\n\n\n\n\nR = \\mathbb{Q}\n\n\n\n\nR = QQ\n\n\n\n\n\n\n\n\nR = \\mathbb{F}_{p^n}\n\n\n\n\nR, a = FiniteField(p, n, \"a\")\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}/n\\mathbb{Z}\n\n\n\n\nR = ResidueRing(ZZ, n)\n\n\n\n\n\n\n\n\nS = R[x]\n\n\n\n\nS, x = PolynomialRing(R, \"x\")\n\n\n\n\n\n\n\n\nS = R[x]\n (to precision \nn\n)\n\n\nS, x = PowerSeriesRing(R, n, \"x\")\n\n\n\n\n\n\n\n\nS = \\mbox{Frac}_R\n\n\n\n\nS = FractionField(R)\n\n\n\n\n\n\n\n\nS = R/(f)\n\n\n\n\nS = ResidueRing(R, f)\n\n\n\n\n\n\n\n\nS = \\mbox{Mat}_{m\\times n}(R)\n\n\n\n\nS = MatrixSpace(R, m, n)\n\n\n\n\n\n\n\n\nS = \\mathbb{Q}[x]/(f)\n\n\n\n\nS, a = NumberField(f, \"a\")\n\n\n\n\n\n\n\n\nO = \\mathcal{O}_K\n\n\n\n\nS = MaximalOrder(K)\n\n\n\n\n\n\nideal \nI\n of \nO = \\mathcal{O}_K\n\n\n\n\nI = Ideal(O, gens, ...)", 
            "title": "Parent object constructors"
        }, 
        {
            "location": "/constructors/#constructing-mathematical-objects-in-nemo", 
            "text": "", 
            "title": "Constructing mathematical objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-objects-in-julia", 
            "text": "In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function with the same name as the type itself. For example, to construct a  BigInt  object in Julia, we simply call the  BigInt  constructor:  n = BigInt( 1234567898765434567898765434567876543456787654567890 )  Julia also uses constructors to convert between types. For example, to convert an  Int  to a  BigInt :  m = BigInt(123)", 
            "title": "Constructing objects in Julia"
        }, 
        {
            "location": "/constructors/#how-we-construct-objects-in-nemo", 
            "text": "As we explained in the previous section, Julia types don't contain enough information to properly model the ring of integers modulo  n  for a multiprecision modulus  n . Instead of using types to construct objects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.  Consider the following simple example, to create a Flint multiprecision integer:  n = ZZ( 12345678765456787654567890987654567898765678909876567890 )  Here  ZZ  is not a Julia type, but a callable object. However, for most purposes one can think of such a parent object  ZZ  as though it were a type.", 
            "title": "How we construct objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-parent-objects", 
            "text": "For more complicated groups, rings, fields, etc., one first needs to construct the parent object before one can use it to construct element objects.  Nemo provides a set of functions for constructing such parent objects. For example, to create a parent object for polynomials over the integers, we use the  PolynomialRing  parent object constructor.  R, x = PolynomialRing(ZZ,  x )\nf = x^3 + 3x + 1\ng = R(12)  In this example,  R  is the parent object and we use it to convert the  Int  value  12  to an element of the polynomial ring  \\mathbb{Z}[x] .", 
            "title": "Constructing parent objects"
        }, 
        {
            "location": "/constructors/#list-of-parent-object-constructors", 
            "text": "For convenience, we provide a list of all the parent object constructors in Nemo and explain what domains they represent.     Mathematics  Nemo constructor       R = \\mathbb{Z}   R = ZZ     R = \\mathbb{Q}   R = QQ     R = \\mathbb{F}_{p^n}   R, a = FiniteField(p, n, \"a\")     R = \\mathbb{Z}/n\\mathbb{Z}   R = ResidueRing(ZZ, n)     S = R[x]   S, x = PolynomialRing(R, \"x\")     S = R[x]  (to precision  n )  S, x = PowerSeriesRing(R, n, \"x\")     S = \\mbox{Frac}_R   S = FractionField(R)     S = R/(f)   S = ResidueRing(R, f)     S = \\mbox{Mat}_{m\\times n}(R)   S = MatrixSpace(R, m, n)     S = \\mathbb{Q}[x]/(f)   S, a = NumberField(f, \"a\")     O = \\mathcal{O}_K   S = MaximalOrder(K)    ideal  I  of  O = \\mathcal{O}_K   I = Ideal(O, gens, ...)", 
            "title": "List of parent object constructors"
        }, 
        {
            "location": "/polynomial/", 
            "text": "Introduction\n\n\nNemo allow the creation of dense, univariate polynomials over any computable ring \nR\n. There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the polynomial types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenPoly{T}\n\n\nGenPolyRing{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_poly\n\n\nFmpzPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n (small \nn\n)\n\n\nFlint\n\n\nnmod_poly\n\n\nNmodPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n (large \nn\n)\n\n\nFlint\n\n\nfmpz_mod_poly\n\n\nFmpzModPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Q}\n\n\n\n\nFlint\n\n\nfmpq_poly\n\n\nFmpqPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (small \nn\n)\n\n\nFlint\n\n\nfq_nmod_poly\n\n\nFqNmodPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (large \nn\n)\n\n\nFlint\n\n\nfq_poly\n\n\nFqPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{R}\n\n\n\n\nArb\n\n\narb_poly\n\n\nArbPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{C}\n\n\n\n\nArb\n\n\nacb_poly\n\n\nAcbPolyRing\n\n\n\n\n\n\n\n\nThe string representation of the variable and the base ring \nR\n of a generic polynomial is stored in its parent object. \n\n\nAll polynomial element types belong to the abstract type \nPolyElem\n and all of the polynomial ring types belong to the abstract type \nPolyRing\n. This enables one to write generic functions that can accept any Nemo polynomial type.\n\n\n\n\nPolynomial ring constructors\n\n\nIn order to construct polynomials in Nemo, one must first construct the polynomial ring itself. This is accomplished with the following constructor.\n\n\nPolynomialRing(::Ring, ::AbstractString, ::Bool)\n\n\n\n\nA shorthand version of this function is provided: given a base ring \nR\n, we abbreviate the constructor as follows.\n\n\nR[\nx\n]\n\n\n\n\nHere are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = QQ[\nz\n]\n\nf = R()\ng = R(123)\nh = S(ZZ(1234))\nk = S(x + 1)\nm = T(z + 1)\n\n\n\n\n\n\nPolynomial element constructors\n\n\nOnce a polynomial ring is constructed, there are various ways to construct polynomials in that ring.\n\n\nThe easiest way is simply using the generator returned by the \nPolynomialRing\n constructor and and build up the polynomial using basic arithmetic. Julia has quite flexible notation for the construction of polynomials in this way.\n\n\nIn addition we provide the following functions for constructing certain useful polynomials.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::PolyRing)\n\n\n\n\n\n\nReturn the zero polynomial in the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::PolyRing)\n\n\n\n\n\n\nReturn the constant polynomial \n1\n in the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gen\n \n \nMethod\n.\n\n\ngen(R::PolyRing)\n\n\n\n\n\n\nReturn the generator of the given polynomial ring.\n\n\n\n\nsource\n\n\nHere are some examples of constructing polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1\n\nh = zero(S)\nk = one(R)\nm = gen(S)\n\n\n\n\n\n\nBasic functionality\n\n\nAll univariate polynomial modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own polynomial module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom univariate polynomial types in Nemo. \n\n\nWe write \nU\n for the type of the polynomials in the polynomial ring and \nT\n for the type of elements of the coefficient ring.\n\n\nAll of these functions are provided for all existing polynomial types in Nemo.\n\n\nparent_type{U \n: PolyElem}(::Type{U})\n\n\n\n\nGiven the type of polynomial elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::PolyRing)\n\n\n\n\nGiven a parent object for the polynomial ring, return the type of elements of the polynomial ring.\n\n\nBase.hash(a::PolyElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the polynomial \na\n. This should be xor'd with a fixed random hexadecimal specific to the polynomial type. The hash of each coefficient should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\nfit!(a::PolyElem, n::Int)\n\n\n\n\nBy reallocating if necessary, ensure that the given polynomial has space for at least \nn\n coefficients. This function does not change the length of the polynomial and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.\n\n\nnormalise(a::PolyElem, n::Int)\n\n\n\n\nReturn the normalised length of the given polynomial, assuming its current length is \nn\n. Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the polynomial. That can be done with a subsequent call to \nset_length!\n using the length returned by \nnormalise\n.\n\n\nset_length!(a::PolyElem, n::Int)\n\n\n\n\nSet the length of an existing polynomial that has sufficient space allocated, i.e. a polynomial for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial type has a field, \nlength\n, which corresponds to the current length of the polynomial, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.\n\n\nlength(a::PolyElem)\n\n\n\n\nReturn the current length (not the number of allocated coefficients), of the given polynomial. Note that this function only needs to be provided by a developer for a custom polynomial type if the Julia type definition for polynomial elements doesn't contain a field \nlength\n corresponding to the current length of the polynomial. Otherwise the supplied generic implementation will work.\n\n\ncoeff(a::PolyElem, n::Int)\n\n\n\n\nReturn the degree \nn\n coefficient of the given polynomial. Note coefficients are numbered from \nn = 0\n for the constant coefficient. If \nn\n is bigger then the degree of the polynomial, the function returns a zero coefficient. We require \nn \\geq 0\n. \n\n\nsetcoeff!{T \n: RingElem}(a::PolyElem{T}, n::Int, c::T)\n\n\n\n\nSet the coefficient of the degree \nn\n term of the given polynomial to the given value \na\n. The polynomial is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.\n\n\ndeepcopy(a::PolyElem)\n\n\n\n\nConstruct a copy of the given polynomial and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo polynomials are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::PolyElem, a::PolyElem, b::PolyElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing polynomial \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::PolyElem, a::PolyElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a polynomial ring, the following coercion functions are provided to coerce various elements into the polynomial ring. Developers provide these by overloading the \ncall\n operator for the polynomial parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the ring \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the polynomial ring \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(A::Array{T, 1})\n\n\n\n\nTake an array of elements in the base ring, of type \nT\n and construct the polynomial with those coefficients, starting with the constant coefficient.\n\n\nS(f::PolyElem)\n\n\n\n\nTake a polynomial that is already in the ring \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the polynomial ring. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom polynomials must ensure the parent object of a polynomial type constains a field \nbase_ring\n specifying the base ring, a field \nS\n containing a symbol (not a string) representing the variable name of the polynomial ring. They must also ensure that each polynomial element contains a field \nparent\n specifying the parent object of the polynomial.\n\n\nTypically a developer will also overload the \nPolynomialRing\n generic function to create polynomials of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(R::PolyRing)\n\n\n\n\n\n\nReturn the base ring of the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::PolyElem)\n\n\n\n\n\n\nReturn the base ring of the polynomial ring of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::PolyElem)\n\n\n\n\n\n\nReturn the parent of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nBase.var\n \n \nMethod\n.\n\n\nvar(a::PolyRing)\n\n\n\n\n\n\nReturn the internal name of the generator of the polynomial ring. Note that this is returned as a \nSymbol\n not a \nString\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.vars\n \n \nMethod\n.\n\n\nvars(a::PolyRing)\n\n\n\n\n\n\nReturn an array of the variable names for the polynomial ring. Note that this is returned as an array of \nSymbol\n not \nString\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.degree\n \n \nMethod\n.\n\n\ndegree(a::PolyElem)\n\n\n\n\n\n\nReturn the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus{T \n: ResElem}(a::PolyElem{T})\n\n\n\n\n\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lead\n \n \nMethod\n.\n\n\nlead(x::PolyElem)\n\n\n\n\n\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.trail\n \n \nMethod\n.\n\n\ntrail(x::PolyElem)\n\n\n\n\n\n\nReturn the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is the constant polynomial \n1\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isgen\n \n \nMethod\n.\n\n\nisgen(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is the constant generator of its polynomial ring, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is a unit in its polynomial ring, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ismonomial\n \n \nMethod\n.\n\n\nismonomial(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is a monomial. This function is recursive, with all scalar types returning true.\n\n\n\n\nsource\n\n\n#\n\n\nBase.den\n \n \nMethod\n.\n\n\nden(a::fmpq_poly)\n\n\n\n\n\n\nReturn the least common denominator of the coefficients of the polynomial \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(QQ, \nz\n)\n\na = zero(S)\nb = one(S)\n\nc = ZZ(1)//2*z^2 + ZZ(1)//3\nd = x*y^2 + (x + 1)*y + 3\n\nU = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)\n\nf = lead(d)\n\ng = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo polynomials. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\nThe following standard operators and functions are provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::PolyElem)\n\n\nunary minus\n\n\n\n\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\naddition\n\n\n\n\n\n\n-{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n*{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\nmultiplication\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\nexact division\n\n\n\n\n\n\n\n\nThe following ad hoc operators and functions are also provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::Integer, b::PolyElem)\n\n\naddition\n\n\n\n\n\n\n+(a::PolyElem, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::PolyElem)\n\n\naddition\n\n\n\n\n\n\n+(a::PolyElem, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\naddition\n\n\n\n\n\n\n-(a::Integer, b::PolyElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::PolyElem, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::PolyElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::PolyElem, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::Integer, b::PolyElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::PolyElem, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::PolyElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::PolyElem, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::PolyElem, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::PolyElem, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\nexact division\n\n\n\n\n\n\n^(a::PolyElem, n::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for polynomials in Nemo. Julia provides the corresponding \n!=\n operator automatically.\n\n\n\n\nFunction\n\n\nisequal{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n \n=={T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\nThe \nisequal\n operation returns \ntrue\n if and only if all the coefficients of the polynomial are precisely equal as compared by \nisequal\n. This is a stronger form of equality, used for comparing inexact coefficients, such as elements of a power series ring, the \np\n-adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal. \n\n\nWe also have the following ad hoc comparison operators.\n\n\n\n\nFunction\n\n\n=={T \n: RingElem}(a::PolyElem{T}, b::T)\n \n=={T \n: RingElem}(a::T, b::PolyElem{T})\n \n==(a::PolyElem, b::Integer)\n \n==(a::Integer, b::PolyElem)\n \n==(a::PolyElem, b::fmpz)\n \n==(a::fmpz, b::PolyElem)\n\n\nHere are some examples of comparisons.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)\n\n\n\n\n\n\nTruncation\n\n\n#\n\n\nBase.truncate\n \n \nMethod\n.\n\n\ntruncate(a::PolyElem, n::Int)\n\n\n\n\n\n\nReturn \na\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.mullow\n \n \nMethod\n.\n\n\nmullow{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T}, n::Int)\n\n\n\n\n\n\nReturn \na\\times b\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\nHere are some examples of truncated operations.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)\n\n\n\n\n\n\nReversal\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(x::PolyElem, len::Int)\n\n\n\n\n\n\nReturn the reverse of the polynomial \nx\n, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length).  The resulting polynomial is normalised. If \nlen\n is negative we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(x::PolyElem)\n\n\n\n\n\n\nReturn the reverse of the polynomial \nx\n, i.e. the leading coefficient of \nx\n becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n\nsource\n\n\nHere are some examples of reversal.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nNemo.shift_left\n \n \nMethod\n.\n\n\nshift_left(x::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted left by \nn\n terms, i.e. multiplied by \nx^n\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.shift_right\n \n \nMethod\n.\n\n\nshift_right(f::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted right by \nn\n terms, i.e. divided by \nx^n\n.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)\n\n\n\n\n\n\nModulo arithmetic\n\n\nFor polynomials over a field or residue ring, we can reduce modulo a given polynomial. This isn't always well-defined in the case of a residue ring, but when it is well-defined, we obtain the correct result. If Nemo encounters an impossible inverse, an exception will be raised.\n\n\n#\n\n\nNemo.mulmod\n \n \nMethod\n.\n\n\nmulmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T}, d::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b \\pmod{d}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::Int, d::PolyElem{T})\n\n\n\n\n\n\nReturn \na^b \\pmod{d}\n. There are no restrictions on \nb\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \nx^e \\pmod{y}\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.invmod\n \n \nMethod\n.\n\n\ninvmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na^{-1} \\pmod{d}\n.\n\n\n\n\nsource\n\n\nHere are some examples of modular arithmetic.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S, \ny\n)\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)\n\n\n\n\n\n\nEuclidean division\n\n\nFor polynomials over a field, we have a euclidean domain, and in many cases for polynomials over a residue ring things behave as though we had a euclidean domain so long as we don't hit an impossible inverse. For such rings we define euclidean division of polynomials. If an impossible inverse is hit, we raise an exception.\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod{T \n: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn \nf \\pmod{g}\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.divrem\n \n \nMethod\n.\n\n\ndivrem{T \n: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(q, r)\n such that \nf = qg + r\n where \nq\n is the euclidean quotient of \nf\n by \ng\n.\n\n\n\n\nsource\n\n\nHere are some examples of euclidean division.\n\n\nR = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T, \ny\n)\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)\n\n\n\n\n\n\nPseudodivision\n\n\nGiven two polynomials \na, b\n, pseudodivision computes polynomials \nq\n and \nr\n with length\n(r) <\n length\n(b)\n such that \nL^d a = bq + r,\n where \nd =\n length\n(a) -\n length\n(b) + 1\n and \nL\n is the leading coefficient of \nb\n.\n\n\nWe call \nq\n the pseudoquotient and \nr\n the pseudoremainder.\n\n\n#\n\n\nNemo.pseudorem\n \n \nMethod\n.\n\n\npseudorem{T \n: RingElem}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn the pseudoremainder of \na\n divided by \nb\n. If \nb = 0\n we throw a  \nDivideError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.pseudodivrem\n \n \nMethod\n.\n\n\npseudodivrem{T \n: RingElem}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(q, r)\n consisting of the pseudoquotient and pseudoremainder  of \na\n divided by \nb\n. If \nb = 0\n we throw a \nDivideError()\n.\n\n\n\n\nsource\n\n\nHere are some examples of pseudodivision.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)\n\n\n\n\n\n\nContent, primitive part, GCD and LCM\n\n\nIn Nemo, we allow computation of the greatest common divisor of polynomials over any ring. This is enabled by making use of pseudoremainders when we aren't working over a euclidean domain or something mimicking such a domain. In certain cases this allows us to return a greatest common divisor when it otherwise wouldn't be possible. However, a greatest common divisor is not necessarily unique, or even well-defined.\n\n\nIf an impossible inverse is encountered whilst computing the greatest common divisor, an exception is thrown.\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a greatest common divisor of \na\n and \nb\n if it exists.\n\n\n\n\nsource\n\n\n#\n\n\nBase.lcm\n \n \nMethod\n.\n\n\nlcm{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a least common multiple of \na\n and \nb\n if it exists.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.content\n \n \nMethod\n.\n\n\ncontent(a::PolyElem)\n\n\n\n\n\n\nReturn the content of \na\n, i.e. the greatest common divisor of its coefficients.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.primpart\n \n \nMethod\n.\n\n\nprimpart(a::PolyElem)\n\n\n\n\n\n\nReturn the primitive part of \na\n, i.e. the polynomial divided by its content.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcdx\n \n \nMethod\n.\n\n\ngcdx{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(r, s, t)\n such that \nr\n is the resultant of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcdx\n \n \nMethod\n.\n\n\ngcdx{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(g, s, t)\n such that \ng\n is the greatest common divisor of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gcdinv\n \n \nMethod\n.\n\n\ngcdinv{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(g, s)\n such that \ng\n is the greatest common divisor of \na\n and \nb\n and such that \ns = a^{-1} \\pmod{b}\n. This function is useful for inverting modulo a polynomial and checking that it really was invertible.\n\n\n\n\nsource\n\n\nHere are some examples of content, primitive part and GCD.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nk = x*y^2 + (x + 1)*y + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1\n\nn = content(k)\np = primpart(k*(x^2 + 1))\nq = gcd(k*m, l*m)\nr = lcm(k*m, l*m)\n\nR, x = PolynomialRing(QQ, \nx\n)\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T, \nz\n)\n\ng = z^3 + 2z + 1\nh = z^5 + 1\n\nr, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)\n\n\n\n\n\n\nEvaluation, composition and substitution\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate(a::PolyElem, b::Integer)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n\n\nRemove and valuation\n\n\n#\n\n\nNemo.remove\n \n \nMethod\n.\n\n\nremove{T \n: RingElem}(z::PolyElem{T}, p::PolyElem{T})\n\n\n\n\n\n\nComputes the valuation of \nz\n at \np\n, that is, the largest \nk\n such that \np^k\n divides \nz\n. Additionally, \nz/p^k\n is returned as well.\n\n\nSee also \nvaluation\n, which only returns the valuation.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.valuation\n \n \nMethod\n.\n\n\nvaluation{T \n: RingElem}(z::PolyElem{T}, p::PolyElem{T})\n\n\n\n\n\n\nComputes the valuation of \nz\n at \np\n, that is, the largest \nk\n such that \np^k\n divides \nz\n.\n\n\nSee also \nremove\n, which also returns \nz/p^k\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divides\n \n \nMethod\n.\n\n\ndivides{T \n: RingElem}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturns a pair consisting of a flag which is set to \ntrue\n if \nf\n divides \ng\n and \nfalse\n otherwise, and a polynomial \nh\n such that \nf = gh\n if such a polynomial exists. If not, the value of \nh\n is undetermined.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divides\n \n \nMethod\n.\n\n\ndivides{T \n: RingElem}(f::PolyElem{T}, g::T)\n\n\n\n\n\n\nReturns a pair consisting of a flag which is set to \ntrue\n if \ng\n divides \nf\n and \nfalse\n otherwise, and a polynomial \nh\n such that \nf = gh\n if such a polynomial exists. If not, the value of \nh\n is undetermined.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::arb_poly, y::Integer)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::arb_poly, y::Float64)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::arb_poly, y::fmpz)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::arb_poly, y::fmpq)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::arb_poly, y::arb)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::arb_poly, y::acb)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::acb_poly, y::Integer)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::acb_poly, y::Float64)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::acb_poly, y::fmpq)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::acb_poly, y::fmpq)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::acb_poly, y::arb)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate2\n \n \nMethod\n.\n\n\nevaluate2(x::acb_poly, y::acb)\n\n\n\n\n\n\nReturn a tuple \np, q\n consisting of the polynomial \nx\n evaluated at \ny\n and its derivative evaluated at \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.compose\n \n \nMethod\n.\n\n\ncompose(a::PolyElem, b::PolyElem)\n\n\n\n\n\n\nCompose the polynomial \na\n with the polynomial \nb\n and return the result, i.e. return \na\\circ b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.subst\n \n \nMethod\n.\n\n\nsubst{T \n: RingElem}(f::PolyElem{T}, a::Any)\n\n\n\n\n\n\nEvaluate the polynomial \nf\n at \na\n. Note that \na\n can be anything, whether a ring element or not.\n\n\n\n\nsource\n\n\nWe also overload the functional notation so that the polynomial \nf\n can be evaluated at \na\n by writing \nf(a)\n. This feature is only available with  Julia 0.5 however.\n\n\nHere are some examples of polynomial evaluation, composition and substitution.\n\n\nRR = RealField(64)\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(RR, \nz\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nh = z^2 + 2z + 1\nM = R[x + 1 2x; x - 3 2x - 1]\n\nk = evaluate(f, 3)\nm = evaluate(f, x^2 + 2x + 1)\nn = compose(f, g)\np = subst(f, M)\nq = f(M)\nr = f(23)\ns, t = evaluate2(h, RR(\n2.0 +/- 0.1\n))\n\n\n\n\n\n\nDerivative and integral\n\n\n#\n\n\nNemo.derivative\n \n \nMethod\n.\n\n\nderivative(a::PolyElem)\n\n\n\n\n\n\nReturn the derivative of the polynomial \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.integral\n \n \nMethod\n.\n\n\nintegral{T \n: Union{ResElem, FieldElem}}(x::PolyElem{T})\n\n\n\n\n\n\nReturn the integral of the polynomial \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of integral and derivative.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(QQ, \nz\n)\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U, \nw\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)   \n\n\n\n\n\n\nResultant and discriminant\n\n\n#\n\n\nNemo.resultant\n \n \nMethod\n.\n\n\nresultant{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn the resultant of the \na\n and \nb\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.discriminant\n \n \nMethod\n.\n\n\ndiscriminant(a::PolyElem)\n\n\n\n\n\n\nReturn the discrimnant of the given polynomial.\n\n\n\n\nsource\n\n\nHere are some examples of computing the resultant and discriminant.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)\n\n\n\n\n\n\nNewton representation\n\n\n#\n\n\nNemo.monomial_to_newton!\n \n \nMethod\n.\n\n\nmonomial_to_newton!{T \n: RingElem}(P::Array{T, 1}, roots::Array{T, 1})\n\n\n\n\n\n\nConverts a polynomial \np\n, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots \nr_0, r_1, \\ldots, r_{n-2}\n. In other words, this determines output coefficients \nc_i\n such that \nc_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})\n is equal to the input polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.newton_to_monomial!\n \n \nMethod\n.\n\n\nnewton_to_monomial!{T \n: RingElem}(P::Array{T, 1}, roots::Array{T, 1})\n\n\n\n\n\n\nConverts a polynomial \np\n, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots \nr_0, r_1, \\ldots, r_{n-2}\n to the standard monomial basis. In other words, this evaluates \nc_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})\n where \nc_i\n are the input coefficients given by \np\n.\n\n\n\n\nsource\n\n\nHere are some examples of conversion to and from Newton representation.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)\n\n\n\n\n\n\nMultipoint evaluation and interpolation\n\n\n#\n\n\nNemo.interpolate\n \n \nMethod\n.\n\n\ninterpolate{T \n: RingElem}(S::PolyRing, x::Array{T, 1}, y::Array{T, 1})\n\n\n\n\n\n\nGiven two arrays of values \nxs\n and \nys\n of the same length \nn\n, find the polynomial \nf\n in the polynomial ring \nR\n of length at most \nn\n such that \nf\n has the value \nys\n at the points \nxs\n. The values in the arrays \nxs\n and \nys\n must belong to the base ring of the polynomial ring \nR\n.\n\n\n\n\nsource\n\n\nHere is an example of interpolation.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nxs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]\n\nf = interpolate(S, xs, ys)\n\n\n\n\n\n\nSignature\n\n\nSignature is only available for certain coefficient rings.\n\n\n#\n\n\nNemo.signature\n \n \nMethod\n.\n\n\nsignature(f::fmpz_poly)\n\n\n\n\n\n\nReturn the signature of the polynomial \nf\n, i.e. a tuple \n(r, s)\n such that \nr\n is the number of real roots of \nf\n and \ns\n is half the number of complex roots.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.signature\n \n \nMethod\n.\n\n\nsignature(f::fmpq_poly)\n\n\n\n\n\n\nReturn the signature of \nf\n, i.e. a tuple \n(r, s)\n where \nr\n is the number of real roots of \nf\n and \ns\n is half the number of complex roots.\n\n\n\n\nsource\n\n\nHere is an example of signature.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)\n\n\n\n\n\n\nRoot finding\n\n\n#\n\n\nNemo.roots\n \n \nMethod\n.\n\n\nroots(x::acb_poly; target=0, isolate_real=false, initial_prec=0, max_prec=0, max_iter=0)\n\n\n\n\n\n\nAttempts to isolate the complex roots of the complex polynomial \nx\n by iteratively refining balls in which they lie.\n\n\nThis is done by increasing the working precision, starting at \ninitial_prec\n. The maximal number of iterations can be set using \nmax_iter\n and the maximal precision can be set using \nmax_prec\n.\n\n\nIf \nisolate_real\n is set and \nx\n is strictly real, then the real roots will be isolated from the non-real roots. Every root will have either zero, positive or negative real part.\n\n\nIt is assumed that \nx\n is squarefree.\n\n\n\n\nsource\n\n\nHere is an example of finding complex roots.\n\n\nCC = ComplexField(64)\nC, y = PolynomialRing(CC, \ny\n)\n\nm = y^2 + 2y + 3\nn = m + CC(\n0 +/- 0.0001\n, \n0 +/- 0.0001\n)\n\nr = roots(n)\n\np = y^7 - 1\n\nr = roots(n, isolate_real = true)\n\n\n\n\n\n\nConstruction from roots\n\n\n#\n\n\nNemo.from_roots\n \n \nMethod\n.\n\n\nfrom_roots(R::ArbPolyRing, b::Array{arb, 1})\n\n\n\n\n\n\nConstruct a polynomial in the given polynomial ring from a list of its roots.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.from_roots\n \n \nMethod\n.\n\n\nfrom_roots(R::AcbPolyRing, b::Array{acb, 1})\n\n\n\n\n\n\nConstruct a polynomial in the given polynomial ring from a list of its roots.\n\n\n\n\nsource\n\n\nHere are some examples of constructing polynomials from their roots.\n\n\nRR = RealField(64)\nR, x = PolynomialRing(RR, \nx\n)\n\nxs = arb[inv(RR(i)) for i=1:5]\nf = from_roots(R, xs)\n\n\n\n\n\n\nLifting\n\n\nWhen working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from \n\\mathbb{Z}/n\\mathbb{Z}\n to \n\\mathbb{Z}\n.\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nfunction lift(R::FmpzPolyRing, y::nmod_poly)\n\n\n\n\n\n\nLift from a polynomial over \n\\mathbb{Z}/n\\mathbb{Z}\n to a polynomial over \n\\mathbb{Z}\n with minimal reduced nonnegative coefficients. The ring \nR\n specifies the ring to lift into.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nfunction lift(R::FmpzPolyRing, y::fmpz_mod_poly)\n\n\n\n\n\n\nLift from a polynomial over \n\\mathbb{Z}/n\\mathbb{Z}\n to a polynomial over \n\\mathbb{Z}\n with minimal reduced nonnegative coefficients. The ring \nR\n specifies the ring to lift into.\n\n\n\n\nsource\n\n\nHere is an example of lifting.\n\n\nR = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R, \nx\n)\nT, y = PolynomialRing(ZZ, \ny\n)\n\nf = x^2 + 2x + 1\n\na = lift(T, f)\n\n\n\n\n\n\nOverlapping and containment\n\n\nOccasionally it is useful to be able to tell when inexact polynomials overlap or contain other exact or inexact polynomials. The following functions are provided for this purpose.\n\n\n#\n\n\nNemo.overlaps\n \n \nMethod\n.\n\n\noverlaps(x::arb_poly, y::arb_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient balls of \nx\n overlap the coefficient balls of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.overlaps\n \n \nMethod\n.\n\n\noverlaps(x::acb_poly, y::acb_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient boxes of \nx\n overlap the coefficient boxes of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb_poly, y::arb_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient balls of \nx\n contain the corresponding coefficient balls of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb_poly, y::acb_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient boxes of \nx\n contain the corresponding coefficient boxes of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb_poly, y::fmpz_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient balls of \nx\n contain the corresponding exact coefficients of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb_poly, y::fmpq_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient balls of \nx\n contain the corresponding exact coefficients of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb_poly, y::fmpz_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient boxes of \nx\n contain the corresponding exact coefficients of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb_poly, y::fmpq_poly)\n\n\n\n\n\n\nReturn \ntrue\n if the coefficient boxes of \nx\n contain the corresponding exact coefficients of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nIt is sometimes also useful to be able to determine if there is a unique integer contained in the coefficient of an inexact constant polynomial.\n\n\n#\n\n\nNemo.unique_integer\n \n \nMethod\n.\n\n\nunique_integer(x::arb_poly)\n\n\n\n\n\n\nReturn a tuple \n(t, z)\n where \nt\n is \ntrue\n if there is a unique integer contained in each of the coefficients of \nx\n, otherwise sets \nt\n to \nfalse\n. In the former case, \nz\n is set to the integer polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.unique_integer\n \n \nMethod\n.\n\n\nunique_integer(x::acb_poly)\n\n\n\n\n\n\nReturn a tuple \n(t, z)\n where \nt\n is \ntrue\n if there is a unique integer contained in the (constant) polynomial \nx\n, along with that integer \nz\n in case it is, otherwise sets \nt\n to \nfalse\n.\n\n\n\n\nsource\n\n\nWe also have the following functions.\n\n\n#\n\n\nBase.isreal\n \n \nMethod\n.\n\n\nisreal(x::acb_poly)\n\n\n\n\n\n\nReturn \ntrue\n if all the coefficients of \nx\n are real, i.e. have exact zero imaginary parts.\n\n\n\n\nsource\n\n\nHere are some examples of overlapping and containment.\n\n\nRR = RealField(64)\nCC = ComplexField(64)\nR, x = PolynomialRing(RR, \nx\n)\nC, y = PolynomialRing(CC, \ny\n)\nZx, zx = PolynomialRing(ZZ, \nx\n)\nQx, qx = PolynomialRing(QQ, \nx\n)\n\nf = x^2 + 2x + 1\nh = f + RR(\n0 +/- 0.0001\n)\nk = f + RR(\n0 +/- 0.0001\n) * x^4\nm = y^2 + 2y + 1\nn = m + CC(\n0 +/- 0.0001\n, \n0 +/- 0.0001\n)\n\ncontains(h, f)\noverlaps(f, k)\ncontains(n, m)\nt, z = unique_integer(k)\nisreal(n)\n\n\n\n\n\n\nFactorisation\n\n\nPolynomials can only be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.\n\n\n#\n\n\nNemo.isirreducible\n \n \nMethod\n.\n\n\nisirreducible(x::nmod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is irreducible, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isirreducible\n \n \nMethod\n.\n\n\nisirreducible(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is irreducible, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issquarefree\n \n \nMethod\n.\n\n\nissquarefree(x::nmod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is squarefree, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issquarefree\n \n \nMethod\n.\n\n\nissquarefree(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is squarefree, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.factor\n \n \nMethod\n.\n\n\nfactor(x::fmpz_poly)\n\n\n\n\n\n\nReturns the factorization of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.factor\n \n \nMethod\n.\n\n\nfactor(x::nmod_poly)\n\n\n\n\n\n\nReturn the factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.factor\n \n \nMethod\n.\n\n\nfactor(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_squarefree\n \n \nMethod\n.\n\n\nfactor_squarefree(x::nmod_poly)\n\n\n\n\n\n\nReturn the squarefree factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_squarefree\n \n \nMethod\n.\n\n\nfactor_squarefree(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the squarefree factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_distinct_deg\n \n \nMethod\n.\n\n\nfactor_distinct_deg(x::nmod_poly)\n\n\n\n\n\n\nReturn the distinct degree factorisation of a squarefree polynomial \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_distinct_deg\n \n \nMethod\n.\n\n\nfactor_distinct_deg(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the distinct degree factorisation of a squarefree polynomial \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of factorisation.\n\n\nR = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R, \nx\n)\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))\n\n\n\n\n\n\nSpecial functions\n\n\nThe following special functions can be computed for any polynomial ring. Typically one uses the generator \nx\n of a polynomial ring to get the respective special polynomials expressed in terms of that generator.\n\n\n#\n\n\nNemo.chebyshev_t\n \n \nMethod\n.\n\n\nchebyshev_t(n::Int, x::PolyElem)\n\n\n\n\n\n\nReturn the Chebyshev polynomial of the first kind \nT_n(x)\n, defined by  \nT_n(x) = \\cos(n \\cos^{-1}(x))\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chebyshev_u\n \n \nMethod\n.\n\n\nchebyshev_u(n::Int, x::PolyElem)\n\n\n\n\n\n\nReturn the Chebyshev polynomial of the first kind \nU_n(x)\n, defined by  \n(n+1) U_n(x) = T'_{n+1}(x)\n.\n\n\n\n\nsource\n\n\nThe following special polynomials are only available for certain base rings.\n\n\n#\n\n\nNemo.cyclotomic\n \n \nMethod\n.\n\n\ncyclotomic(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nn\nth cyclotomic polynomial, defined as \n\\Phi_n(x) = \\prod_{\\omega} (x-\\omega),\n where \n\\omega\n runs over all the  \nn\nth primitive roots of unity.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.swinnerton_dyer\n \n \nMethod\n.\n\n\nswinnerton_dyer(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the Swinnerton-Dyer polynomial \nS_n\n, defined as the integer  polynomial \nS_n = \\prod (x \\pm \\sqrt{2} \\pm \\sqrt{3} \\pm \\sqrt{5} \\pm \\ldots \\pm \\sqrt{p_n})\n  where \np_n\n denotes the \nn\n-th prime number and all combinations of signs are taken. This polynomial has degree \n2^n\n and is irreducible over the integers (it is the minimal polynomial of \n\\sqrt{2} + \\ldots + \\sqrt{p_n}\n).\n\n\n\n\nsource\n\n\n#\n\n\nNemo.cos_minpoly\n \n \nMethod\n.\n\n\ncos_minpoly(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the minimal polynomial of \n2 \\cos(2 \\pi / n)\n. For suitable choice of  \nn\n, this gives the minimal polynomial of \n2 \\cos(a \\pi)\n or \n2 \\sin(a \\pi)\n for any rational \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.theta_qexp\n \n \nMethod\n.\n\n\ntheta_qexp(e::Int, n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nq\n-expansion to length \nn\n of the Jacobi theta function raised to the power \nr\n, i.e. \n\\vartheta(q)^r\n where  \n\\vartheta(q) = 1 + \\sum_{k=1}^{\\infty} q^{k^2}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.eta_qexp\n \n \nMethod\n.\n\n\neta_qexp(e::Int, n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nq\n-expansion to length \nn\n of the Dedekind eta function (without  the leading factor \nq^{1/24}\n) raised to the power \nr\n, i.e. \n(q^{-1/24} \\eta(q))^r = \\prod_{k=1}^{\\infty} (1 - q^k)^r\n. In particular, \nr = -1\n gives the generating function of the partition function \np(k)\n, and \nr = 24\n gives, after multiplication by \nq\n, the modular discriminant \n\\Delta(q)\n which generates the Ramanujan tau function \n\\tau(k)\n.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Univariate polynomials"
        }, 
        {
            "location": "/polynomial/#introduction", 
            "text": "Nemo allow the creation of dense, univariate polynomials over any computable ring  R . There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.  The following table shows each of the polynomial types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenPoly{T}  GenPolyRing{T}     \\mathbb{Z}   Flint  fmpz_poly  FmpzPolyRing     \\mathbb{Z}/n\\mathbb{Z}  (small  n )  Flint  nmod_poly  NmodPolyRing     \\mathbb{Z}/n\\mathbb{Z}  (large  n )  Flint  fmpz_mod_poly  FmpzModPolyRing     \\mathbb{Q}   Flint  fmpq_poly  FmpqPolyRing     \\mathbb{F}_{p^n}  (small  n )  Flint  fq_nmod_poly  FqNmodPolyRing     \\mathbb{F}_{p^n}  (large  n )  Flint  fq_poly  FqPolyRing     \\mathbb{R}   Arb  arb_poly  ArbPolyRing     \\mathbb{C}   Arb  acb_poly  AcbPolyRing     The string representation of the variable and the base ring  R  of a generic polynomial is stored in its parent object.   All polynomial element types belong to the abstract type  PolyElem  and all of the polynomial ring types belong to the abstract type  PolyRing . This enables one to write generic functions that can accept any Nemo polynomial type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/polynomial/#polynomial-ring-constructors", 
            "text": "In order to construct polynomials in Nemo, one must first construct the polynomial ring itself. This is accomplished with the following constructor.  PolynomialRing(::Ring, ::AbstractString, ::Bool)  A shorthand version of this function is provided: given a base ring  R , we abbreviate the constructor as follows.  R[ x ]  Here are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = QQ[ z ]\n\nf = R()\ng = R(123)\nh = S(ZZ(1234))\nk = S(x + 1)\nm = T(z + 1)", 
            "title": "Polynomial ring constructors"
        }, 
        {
            "location": "/polynomial/#polynomial-element-constructors", 
            "text": "Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.  The easiest way is simply using the generator returned by the  PolynomialRing  constructor and and build up the polynomial using basic arithmetic. Julia has quite flexible notation for the construction of polynomials in this way.  In addition we provide the following functions for constructing certain useful polynomials.  #  Base.zero     Method .  zero(R::PolyRing)   Return the zero polynomial in the given polynomial ring.   source  #  Base.one     Method .  one(R::PolyRing)   Return the constant polynomial  1  in the given polynomial ring.   source  #  Nemo.gen     Method .  gen(R::PolyRing)   Return the generator of the given polynomial ring.   source  Here are some examples of constructing polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1\n\nh = zero(S)\nk = one(R)\nm = gen(S)", 
            "title": "Polynomial element constructors"
        }, 
        {
            "location": "/polynomial/#basic-functionality", 
            "text": "All univariate polynomial modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own polynomial module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom univariate polynomial types in Nemo.   We write  U  for the type of the polynomials in the polynomial ring and  T  for the type of elements of the coefficient ring.  All of these functions are provided for all existing polynomial types in Nemo.  parent_type{U  : PolyElem}(::Type{U})  Given the type of polynomial elements, should return the type of the corresponding parent object.  elem_type(R::PolyRing)  Given a parent object for the polynomial ring, return the type of elements of the polynomial ring.  Base.hash(a::PolyElem, h::UInt)  Return a  UInt  hexadecimal hash of the polynomial  a . This should be xor'd with a fixed random hexadecimal specific to the polynomial type. The hash of each coefficient should be xor'd with the supplied parameter  h  as part of computing the hash.  fit!(a::PolyElem, n::Int)  By reallocating if necessary, ensure that the given polynomial has space for at least  n  coefficients. This function does not change the length of the polynomial and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.  normalise(a::PolyElem, n::Int)  Return the normalised length of the given polynomial, assuming its current length is  n . Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the polynomial. That can be done with a subsequent call to  set_length!  using the length returned by  normalise .  set_length!(a::PolyElem, n::Int)  Set the length of an existing polynomial that has sufficient space allocated, i.e. a polynomial for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial type has a field,  length , which corresponds to the current length of the polynomial, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.  length(a::PolyElem)  Return the current length (not the number of allocated coefficients), of the given polynomial. Note that this function only needs to be provided by a developer for a custom polynomial type if the Julia type definition for polynomial elements doesn't contain a field  length  corresponding to the current length of the polynomial. Otherwise the supplied generic implementation will work.  coeff(a::PolyElem, n::Int)  Return the degree  n  coefficient of the given polynomial. Note coefficients are numbered from  n = 0  for the constant coefficient. If  n  is bigger then the degree of the polynomial, the function returns a zero coefficient. We require  n \\geq 0 .   setcoeff!{T  : RingElem}(a::PolyElem{T}, n::Int, c::T)  Set the coefficient of the degree  n  term of the given polynomial to the given value  a . The polynomial is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.  deepcopy(a::PolyElem)  Construct a copy of the given polynomial and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo polynomials are mutable and so returning shallow copies is not sufficient.  mul!(c::PolyElem, a::PolyElem, b::PolyElem)  Multiply  a  by  b  and set the existing polynomial  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::PolyElem, a::PolyElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a polynomial ring, the following coercion functions are provided to coerce various elements into the polynomial ring. Developers provide these by overloading the  call  operator for the polynomial parent objects.  S()  Coerce zero into the ring  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the polynomial ring  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(A::Array{T, 1})  Take an array of elements in the base ring, of type  T  and construct the polynomial with those coefficients, starting with the constant coefficient.  S(f::PolyElem)  Take a polynomial that is already in the ring  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the polynomial ring. This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom polynomials must ensure the parent object of a polynomial type constains a field  base_ring  specifying the base ring, a field  S  containing a symbol (not a string) representing the variable name of the polynomial ring. They must also ensure that each polynomial element contains a field  parent  specifying the parent object of the polynomial.  Typically a developer will also overload the  PolynomialRing  generic function to create polynomials of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/polynomial/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(R::PolyRing)   Return the base ring of the given polynomial ring.   source  #  Nemo.base_ring     Method .  base_ring(a::PolyElem)   Return the base ring of the polynomial ring of the given polynomial.   source  #  Base.parent     Method .  parent(a::PolyElem)   Return the parent of the given polynomial.   source  #  Base.var     Method .  var(a::PolyRing)   Return the internal name of the generator of the polynomial ring. Note that this is returned as a  Symbol  not a  String .   source  #  Nemo.vars     Method .  vars(a::PolyRing)   Return an array of the variable names for the polynomial ring. Note that this is returned as an array of  Symbol  not  String .   source  #  Nemo.degree     Method .  degree(a::PolyElem)   Return the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.   source  #  Nemo.modulus     Method .  modulus{T  : ResElem}(a::PolyElem{T})   Return the modulus of the coefficients of the given polynomial.   source  #  Nemo.lead     Method .  lead(x::PolyElem)   Return the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.   source  #  Nemo.trail     Method .  trail(x::PolyElem)   Return the trailing coefficient of the given polynomial. This will be the nonzero coefficient of the term with lowest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.   source  #  Nemo.iszero     Method .  iszero(a::PolyElem)   Return  true  if the given polynomial is zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::PolyElem)   Return  true  if the given polynomial is the constant polynomial  1 , otherwise return  false .   source  #  Nemo.isgen     Method .  isgen(a::PolyElem)   Return  true  if the given polynomial is the constant generator of its polynomial ring, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::PolyElem)   Return  true  if the given polynomial is a unit in its polynomial ring, otherwise return  false .   source  #  Nemo.ismonomial     Method .  ismonomial(a::PolyElem)   Return  true  if the given polynomial is a monomial. This function is recursive, with all scalar types returning true.   source  #  Base.den     Method .  den(a::fmpq_poly)   Return the least common denominator of the coefficients of the polynomial  a .   source  Here are some examples of basic manipulation of polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(QQ,  z )\n\na = zero(S)\nb = one(S)\n\nc = ZZ(1)//2*z^2 + ZZ(1)//3\nd = x*y^2 + (x + 1)*y + 3\n\nU = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)\n\nf = lead(d)\n\ng = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/polynomial/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo polynomials. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  The following standard operators and functions are provided.     Function  Operation      -(a::PolyElem)  unary minus    +{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})  addition    -{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})  subtraction    *{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})  multiplication    divexact{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})  exact division     The following ad hoc operators and functions are also provided.     Function  Operation      +(a::Integer, b::PolyElem)  addition    +(a::PolyElem, b::Integer)  addition    +(a::fmpz, b::PolyElem)  addition    +(a::PolyElem, b::fmpz)  addition    +{T  : RingElem}(a::T, b::PolyElem{T})  addition    +{T  : RingElem}(a::PolyElem{T}, b::T)  addition    -(a::Integer, b::PolyElem)  subtraction    -(a::PolyElem, b::Integer)  subtraction    -(a::fmpz, b::PolyElem)  subtraction    -(a::PolyElem, b::fmpz)  subtraction    -{T  : RingElem}(a::T, b::PolyElem{T})  subtraction    -{T  : RingElem}(a::PolyElem{T}, b::T)  subtraction    *(a::Integer, b::PolyElem)  multiplication    *(a::PolyElem, b::Integer)  multiplication    *(a::fmpz, b::PolyElem)  multiplication    *(a::PolyElem, b::fmpz)  multiplication    *{T  : RingElem}(a::T, b::PolyElem{T})  multiplication    *{T  : RingElem}(a::PolyElem{T}, b::T)  multiplication    divexact(a::PolyElem, b::Integer)  exact division    divexact(a::PolyElem, b::fmpz)  exact division    divexact{T  : RingElem}(a::PolyElem{T}, b::T)  exact division    ^(a::PolyElem, n::Int)  powering     If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/polynomial/#comparison-operators", 
            "text": "The following comparison operators are implemented for polynomials in Nemo. Julia provides the corresponding  !=  operator automatically.", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/polynomial/#function", 
            "text": "isequal{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   =={T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})  The  isequal  operation returns  true  if and only if all the coefficients of the polynomial are precisely equal as compared by  isequal . This is a stronger form of equality, used for comparing inexact coefficients, such as elements of a power series ring, the  p -adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal.   We also have the following ad hoc comparison operators.", 
            "title": "Function"
        }, 
        {
            "location": "/polynomial/#function_1", 
            "text": "=={T  : RingElem}(a::PolyElem{T}, b::T)   =={T  : RingElem}(a::T, b::PolyElem{T})   ==(a::PolyElem, b::Integer)   ==(a::Integer, b::PolyElem)   ==(a::PolyElem, b::fmpz)   ==(a::fmpz, b::PolyElem)  Here are some examples of comparisons.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)", 
            "title": "Function"
        }, 
        {
            "location": "/polynomial/#truncation", 
            "text": "#  Base.truncate     Method .  truncate(a::PolyElem, n::Int)   Return  a  truncated to  n  terms.   source  #  Nemo.mullow     Method .  mullow{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T}, n::Int)   Return  a\\times b  truncated to  n  terms.   source  Here are some examples of truncated operations.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)", 
            "title": "Truncation"
        }, 
        {
            "location": "/polynomial/#reversal", 
            "text": "#  Base.reverse     Method .  reverse(x::PolyElem, len::Int)   Return the reverse of the polynomial  x , thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length).  The resulting polynomial is normalised. If  len  is negative we throw a  DomainError() .   source  #  Base.reverse     Method .  reverse(x::PolyElem)   Return the reverse of the polynomial  x , i.e. the leading coefficient of  x  becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.   source  Here are some examples of reversal.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)", 
            "title": "Reversal"
        }, 
        {
            "location": "/polynomial/#shifting", 
            "text": "#  Nemo.shift_left     Method .  shift_left(x::PolyElem, n::Int)   Return the polynomial  f  shifted left by  n  terms, i.e. multiplied by  x^n .   source  #  Nemo.shift_right     Method .  shift_right(f::PolyElem, n::Int)   Return the polynomial  f  shifted right by  n  terms, i.e. divided by  x^n .   source  Here are some examples of shifting.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)", 
            "title": "Shifting"
        }, 
        {
            "location": "/polynomial/#modulo-arithmetic", 
            "text": "For polynomials over a field or residue ring, we can reduce modulo a given polynomial. This isn't always well-defined in the case of a residue ring, but when it is well-defined, we obtain the correct result. If Nemo encounters an impossible inverse, an exception will be raised.  #  Nemo.mulmod     Method .  mulmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T}, d::PolyElem{T})   Return  a\\times b \\pmod{d} .   source  #  Nemo.powmod     Method .  powmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::Int, d::PolyElem{T})   Return  a^b \\pmod{d} . There are no restrictions on  b .   source  #  Nemo.powmod     Method .  powmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)   Return  x^e \\pmod{y} .   source  #  Base.invmod     Method .  invmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return  a^{-1} \\pmod{d} .   source  Here are some examples of modular arithmetic.  R, x = PolynomialRing(QQ,  x )\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S,  y )\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)", 
            "title": "Modulo arithmetic"
        }, 
        {
            "location": "/polynomial/#euclidean-division", 
            "text": "For polynomials over a field, we have a euclidean domain, and in many cases for polynomials over a residue ring things behave as though we had a euclidean domain so long as we don't hit an impossible inverse. For such rings we define euclidean division of polynomials. If an impossible inverse is hit, we raise an exception.  #  Base.mod     Method .  mod{T  : Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})   Return  f \\pmod{g} .   source  #  Base.divrem     Method .  divrem{T  : Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})   Return a tuple  (q, r)  such that  f = qg + r  where  q  is the euclidean quotient of  f  by  g .   source  Here are some examples of euclidean division.  R = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T,  y )\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)", 
            "title": "Euclidean division"
        }, 
        {
            "location": "/polynomial/#pseudodivision", 
            "text": "Given two polynomials  a, b , pseudodivision computes polynomials  q  and  r  with length (r) <  length (b)  such that  L^d a = bq + r,  where  d =  length (a) -  length (b) + 1  and  L  is the leading coefficient of  b .  We call  q  the pseudoquotient and  r  the pseudoremainder.  #  Nemo.pseudorem     Method .  pseudorem{T  : RingElem}(f::PolyElem{T}, g::PolyElem{T})   Return the pseudoremainder of  a  divided by  b . If  b = 0  we throw a   DivideError() .   source  #  Nemo.pseudodivrem     Method .  pseudodivrem{T  : RingElem}(f::PolyElem{T}, g::PolyElem{T})   Return a tuple  (q, r)  consisting of the pseudoquotient and pseudoremainder  of  a  divided by  b . If  b = 0  we throw a  DivideError() .   source  Here are some examples of pseudodivision.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)", 
            "title": "Pseudodivision"
        }, 
        {
            "location": "/polynomial/#content-primitive-part-gcd-and-lcm", 
            "text": "In Nemo, we allow computation of the greatest common divisor of polynomials over any ring. This is enabled by making use of pseudoremainders when we aren't working over a euclidean domain or something mimicking such a domain. In certain cases this allows us to return a greatest common divisor when it otherwise wouldn't be possible. However, a greatest common divisor is not necessarily unique, or even well-defined.  If an impossible inverse is encountered whilst computing the greatest common divisor, an exception is thrown.  #  Base.gcd     Method .  gcd{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a greatest common divisor of  a  and  b  if it exists.   source  #  Base.lcm     Method .  lcm{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a least common multiple of  a  and  b  if it exists.   source  #  Nemo.content     Method .  content(a::PolyElem)   Return the content of  a , i.e. the greatest common divisor of its coefficients.   source  #  Nemo.primpart     Method .  primpart(a::PolyElem)   Return the primitive part of  a , i.e. the polynomial divided by its content.   source  #  Base.gcdx     Method .  gcdx{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (r, s, t)  such that  r  is the resultant of  a  and  b  and such that  r = a\\times s + b\\times t .   source  #  Base.gcdx     Method .  gcdx{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (g, s, t)  such that  g  is the greatest common divisor of  a  and  b  and such that  r = a\\times s + b\\times t .   source  #  Nemo.gcdinv     Method .  gcdinv{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (g, s)  such that  g  is the greatest common divisor of  a  and  b  and such that  s = a^{-1} \\pmod{b} . This function is useful for inverting modulo a polynomial and checking that it really was invertible.   source  Here are some examples of content, primitive part and GCD.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nk = x*y^2 + (x + 1)*y + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1\n\nn = content(k)\np = primpart(k*(x^2 + 1))\nq = gcd(k*m, l*m)\nr = lcm(k*m, l*m)\n\nR, x = PolynomialRing(QQ,  x )\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T,  z )\n\ng = z^3 + 2z + 1\nh = z^5 + 1\n\nr, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)", 
            "title": "Content, primitive part, GCD and LCM"
        }, 
        {
            "location": "/polynomial/#evaluation-composition-and-substitution", 
            "text": "#  Nemo.evaluate     Method .  evaluate{T  : RingElem}(a::PolyElem{T}, b::T)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.evaluate     Method .  evaluate(a::PolyElem, b::Integer)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.evaluate     Method .  evaluate(a::PolyElem, b::fmpz)   Evaluate the polynomial  a  at the value  b  and return the result.   source", 
            "title": "Evaluation, composition and substitution"
        }, 
        {
            "location": "/polynomial/#remove-and-valuation", 
            "text": "#  Nemo.remove     Method .  remove{T  : RingElem}(z::PolyElem{T}, p::PolyElem{T})   Computes the valuation of  z  at  p , that is, the largest  k  such that  p^k  divides  z . Additionally,  z/p^k  is returned as well.  See also  valuation , which only returns the valuation.   source  #  Nemo.valuation     Method .  valuation{T  : RingElem}(z::PolyElem{T}, p::PolyElem{T})   Computes the valuation of  z  at  p , that is, the largest  k  such that  p^k  divides  z .  See also  remove , which also returns  z/p^k .   source  #  Nemo.divides     Method .  divides{T  : RingElem}(f::PolyElem{T}, g::PolyElem{T})   Returns a pair consisting of a flag which is set to  true  if  f  divides  g  and  false  otherwise, and a polynomial  h  such that  f = gh  if such a polynomial exists. If not, the value of  h  is undetermined.   source  #  Nemo.divides     Method .  divides{T  : RingElem}(f::PolyElem{T}, g::T)   Returns a pair consisting of a flag which is set to  true  if  g  divides  f  and  false  otherwise, and a polynomial  h  such that  f = gh  if such a polynomial exists. If not, the value of  h  is undetermined.   source  #  Nemo.evaluate2     Method .  evaluate2(x::arb_poly, y::Integer)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::arb_poly, y::Float64)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::arb_poly, y::fmpz)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::arb_poly, y::fmpq)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::arb_poly, y::arb)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::arb_poly, y::acb)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::acb_poly, y::Integer)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::acb_poly, y::Float64)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::acb_poly, y::fmpq)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::acb_poly, y::fmpq)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::acb_poly, y::arb)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.evaluate2     Method .  evaluate2(x::acb_poly, y::acb)   Return a tuple  p, q  consisting of the polynomial  x  evaluated at  y  and its derivative evaluated at  y .   source  #  Nemo.compose     Method .  compose(a::PolyElem, b::PolyElem)   Compose the polynomial  a  with the polynomial  b  and return the result, i.e. return  a\\circ b .   source  #  Nemo.subst     Method .  subst{T  : RingElem}(f::PolyElem{T}, a::Any)   Evaluate the polynomial  f  at  a . Note that  a  can be anything, whether a ring element or not.   source  We also overload the functional notation so that the polynomial  f  can be evaluated at  a  by writing  f(a) . This feature is only available with  Julia 0.5 however.  Here are some examples of polynomial evaluation, composition and substitution.  RR = RealField(64)\nR, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(RR,  z )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nh = z^2 + 2z + 1\nM = R[x + 1 2x; x - 3 2x - 1]\n\nk = evaluate(f, 3)\nm = evaluate(f, x^2 + 2x + 1)\nn = compose(f, g)\np = subst(f, M)\nq = f(M)\nr = f(23)\ns, t = evaluate2(h, RR( 2.0 +/- 0.1 ))", 
            "title": "Remove and valuation"
        }, 
        {
            "location": "/polynomial/#derivative-and-integral", 
            "text": "#  Nemo.derivative     Method .  derivative(a::PolyElem)   Return the derivative of the polynomial  a .   source  #  Nemo.integral     Method .  integral{T  : Union{ResElem, FieldElem}}(x::PolyElem{T})   Return the integral of the polynomial  a .   source  Here are some examples of integral and derivative.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(QQ,  z )\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U,  w )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)", 
            "title": "Derivative and integral"
        }, 
        {
            "location": "/polynomial/#resultant-and-discriminant", 
            "text": "#  Nemo.resultant     Method .  resultant{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return the resultant of the  a  and  b .   source  #  Nemo.discriminant     Method .  discriminant(a::PolyElem)   Return the discrimnant of the given polynomial.   source  Here are some examples of computing the resultant and discriminant.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)", 
            "title": "Resultant and discriminant"
        }, 
        {
            "location": "/polynomial/#newton-representation", 
            "text": "#  Nemo.monomial_to_newton!     Method .  monomial_to_newton!{T  : RingElem}(P::Array{T, 1}, roots::Array{T, 1})   Converts a polynomial  p , given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots  r_0, r_1, \\ldots, r_{n-2} . In other words, this determines output coefficients  c_i  such that  c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})  is equal to the input polynomial.   source  #  Nemo.newton_to_monomial!     Method .  newton_to_monomial!{T  : RingElem}(P::Array{T, 1}, roots::Array{T, 1})   Converts a polynomial  p , given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots  r_0, r_1, \\ldots, r_{n-2}  to the standard monomial basis. In other words, this evaluates  c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})  where  c_i  are the input coefficients given by  p .   source  Here are some examples of conversion to and from Newton representation.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)", 
            "title": "Newton representation"
        }, 
        {
            "location": "/polynomial/#multipoint-evaluation-and-interpolation", 
            "text": "#  Nemo.interpolate     Method .  interpolate{T  : RingElem}(S::PolyRing, x::Array{T, 1}, y::Array{T, 1})   Given two arrays of values  xs  and  ys  of the same length  n , find the polynomial  f  in the polynomial ring  R  of length at most  n  such that  f  has the value  ys  at the points  xs . The values in the arrays  xs  and  ys  must belong to the base ring of the polynomial ring  R .   source  Here is an example of interpolation.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nxs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]\n\nf = interpolate(S, xs, ys)", 
            "title": "Multipoint evaluation and interpolation"
        }, 
        {
            "location": "/polynomial/#signature", 
            "text": "Signature is only available for certain coefficient rings.  #  Nemo.signature     Method .  signature(f::fmpz_poly)   Return the signature of the polynomial  f , i.e. a tuple  (r, s)  such that  r  is the number of real roots of  f  and  s  is half the number of complex roots.   source  #  Nemo.signature     Method .  signature(f::fmpq_poly)   Return the signature of  f , i.e. a tuple  (r, s)  where  r  is the number of real roots of  f  and  s  is half the number of complex roots.   source  Here is an example of signature.  R, x = PolynomialRing(ZZ,  x )\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)", 
            "title": "Signature"
        }, 
        {
            "location": "/polynomial/#root-finding", 
            "text": "#  Nemo.roots     Method .  roots(x::acb_poly; target=0, isolate_real=false, initial_prec=0, max_prec=0, max_iter=0)   Attempts to isolate the complex roots of the complex polynomial  x  by iteratively refining balls in which they lie.  This is done by increasing the working precision, starting at  initial_prec . The maximal number of iterations can be set using  max_iter  and the maximal precision can be set using  max_prec .  If  isolate_real  is set and  x  is strictly real, then the real roots will be isolated from the non-real roots. Every root will have either zero, positive or negative real part.  It is assumed that  x  is squarefree.   source  Here is an example of finding complex roots.  CC = ComplexField(64)\nC, y = PolynomialRing(CC,  y )\n\nm = y^2 + 2y + 3\nn = m + CC( 0 +/- 0.0001 ,  0 +/- 0.0001 )\n\nr = roots(n)\n\np = y^7 - 1\n\nr = roots(n, isolate_real = true)", 
            "title": "Root finding"
        }, 
        {
            "location": "/polynomial/#construction-from-roots", 
            "text": "#  Nemo.from_roots     Method .  from_roots(R::ArbPolyRing, b::Array{arb, 1})   Construct a polynomial in the given polynomial ring from a list of its roots.   source  #  Nemo.from_roots     Method .  from_roots(R::AcbPolyRing, b::Array{acb, 1})   Construct a polynomial in the given polynomial ring from a list of its roots.   source  Here are some examples of constructing polynomials from their roots.  RR = RealField(64)\nR, x = PolynomialRing(RR,  x )\n\nxs = arb[inv(RR(i)) for i=1:5]\nf = from_roots(R, xs)", 
            "title": "Construction from roots"
        }, 
        {
            "location": "/polynomial/#lifting", 
            "text": "When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from  \\mathbb{Z}/n\\mathbb{Z}  to  \\mathbb{Z} .  #  Nemo.lift     Method .  function lift(R::FmpzPolyRing, y::nmod_poly)   Lift from a polynomial over  \\mathbb{Z}/n\\mathbb{Z}  to a polynomial over  \\mathbb{Z}  with minimal reduced nonnegative coefficients. The ring  R  specifies the ring to lift into.   source  #  Nemo.lift     Method .  function lift(R::FmpzPolyRing, y::fmpz_mod_poly)   Lift from a polynomial over  \\mathbb{Z}/n\\mathbb{Z}  to a polynomial over  \\mathbb{Z}  with minimal reduced nonnegative coefficients. The ring  R  specifies the ring to lift into.   source  Here is an example of lifting.  R = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R,  x )\nT, y = PolynomialRing(ZZ,  y )\n\nf = x^2 + 2x + 1\n\na = lift(T, f)", 
            "title": "Lifting"
        }, 
        {
            "location": "/polynomial/#overlapping-and-containment", 
            "text": "Occasionally it is useful to be able to tell when inexact polynomials overlap or contain other exact or inexact polynomials. The following functions are provided for this purpose.  #  Nemo.overlaps     Method .  overlaps(x::arb_poly, y::arb_poly)   Return  true  if the coefficient balls of  x  overlap the coefficient balls of  y , otherwise return  false .   source  #  Nemo.overlaps     Method .  overlaps(x::acb_poly, y::acb_poly)   Return  true  if the coefficient boxes of  x  overlap the coefficient boxes of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb_poly, y::arb_poly)   Return  true  if the coefficient balls of  x  contain the corresponding coefficient balls of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb_poly, y::acb_poly)   Return  true  if the coefficient boxes of  x  contain the corresponding coefficient boxes of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb_poly, y::fmpz_poly)   Return  true  if the coefficient balls of  x  contain the corresponding exact coefficients of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb_poly, y::fmpq_poly)   Return  true  if the coefficient balls of  x  contain the corresponding exact coefficients of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb_poly, y::fmpz_poly)   Return  true  if the coefficient boxes of  x  contain the corresponding exact coefficients of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb_poly, y::fmpq_poly)   Return  true  if the coefficient boxes of  x  contain the corresponding exact coefficients of  y , otherwise return  false .   source  It is sometimes also useful to be able to determine if there is a unique integer contained in the coefficient of an inexact constant polynomial.  #  Nemo.unique_integer     Method .  unique_integer(x::arb_poly)   Return a tuple  (t, z)  where  t  is  true  if there is a unique integer contained in each of the coefficients of  x , otherwise sets  t  to  false . In the former case,  z  is set to the integer polynomial.   source  #  Nemo.unique_integer     Method .  unique_integer(x::acb_poly)   Return a tuple  (t, z)  where  t  is  true  if there is a unique integer contained in the (constant) polynomial  x , along with that integer  z  in case it is, otherwise sets  t  to  false .   source  We also have the following functions.  #  Base.isreal     Method .  isreal(x::acb_poly)   Return  true  if all the coefficients of  x  are real, i.e. have exact zero imaginary parts.   source  Here are some examples of overlapping and containment.  RR = RealField(64)\nCC = ComplexField(64)\nR, x = PolynomialRing(RR,  x )\nC, y = PolynomialRing(CC,  y )\nZx, zx = PolynomialRing(ZZ,  x )\nQx, qx = PolynomialRing(QQ,  x )\n\nf = x^2 + 2x + 1\nh = f + RR( 0 +/- 0.0001 )\nk = f + RR( 0 +/- 0.0001 ) * x^4\nm = y^2 + 2y + 1\nn = m + CC( 0 +/- 0.0001 ,  0 +/- 0.0001 )\n\ncontains(h, f)\noverlaps(f, k)\ncontains(n, m)\nt, z = unique_integer(k)\nisreal(n)", 
            "title": "Overlapping and containment"
        }, 
        {
            "location": "/polynomial/#factorisation", 
            "text": "Polynomials can only be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.  #  Nemo.isirreducible     Method .  isirreducible(x::nmod_poly)   Return  true  if  x  is irreducible, otherwise return  false .   source  #  Nemo.isirreducible     Method .  isirreducible(x::fmpz_mod_poly)   Return  true  if  x  is irreducible, otherwise return  false .   source  #  Nemo.issquarefree     Method .  issquarefree(x::nmod_poly)   Return  true  if  x  is squarefree, otherwise return  false .   source  #  Nemo.issquarefree     Method .  issquarefree(x::fmpz_mod_poly)   Return  true  if  x  is squarefree, otherwise return  false .   source  #  Base.factor     Method .  factor(x::fmpz_poly)   Returns the factorization of  x .   source  #  Base.factor     Method .  factor(x::nmod_poly)   Return the factorisation of  x .   source  #  Base.factor     Method .  factor(x::fmpz_mod_poly)   Return the factorisation of  x .   source  #  Nemo.factor_squarefree     Method .  factor_squarefree(x::nmod_poly)   Return the squarefree factorisation of  x .   source  #  Nemo.factor_squarefree     Method .  factor_squarefree(x::fmpz_mod_poly)   Return the squarefree factorisation of  x .   source  #  Nemo.factor_distinct_deg     Method .  factor_distinct_deg(x::nmod_poly)   Return the distinct degree factorisation of a squarefree polynomial  x .   source  #  Nemo.factor_distinct_deg     Method .  factor_distinct_deg(x::fmpz_mod_poly)   Return the distinct degree factorisation of a squarefree polynomial  x .   source  Here are some examples of factorisation.  R = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R,  x )\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))", 
            "title": "Factorisation"
        }, 
        {
            "location": "/polynomial/#special-functions", 
            "text": "The following special functions can be computed for any polynomial ring. Typically one uses the generator  x  of a polynomial ring to get the respective special polynomials expressed in terms of that generator.  #  Nemo.chebyshev_t     Method .  chebyshev_t(n::Int, x::PolyElem)   Return the Chebyshev polynomial of the first kind  T_n(x) , defined by   T_n(x) = \\cos(n \\cos^{-1}(x)) .   source  #  Nemo.chebyshev_u     Method .  chebyshev_u(n::Int, x::PolyElem)   Return the Chebyshev polynomial of the first kind  U_n(x) , defined by   (n+1) U_n(x) = T'_{n+1}(x) .   source  The following special polynomials are only available for certain base rings.  #  Nemo.cyclotomic     Method .  cyclotomic(n::Int, x::fmpz_poly)   Return the  n th cyclotomic polynomial, defined as  \\Phi_n(x) = \\prod_{\\omega} (x-\\omega),  where  \\omega  runs over all the   n th primitive roots of unity.   source  #  Nemo.swinnerton_dyer     Method .  swinnerton_dyer(n::Int, x::fmpz_poly)   Return the Swinnerton-Dyer polynomial  S_n , defined as the integer  polynomial  S_n = \\prod (x \\pm \\sqrt{2} \\pm \\sqrt{3} \\pm \\sqrt{5} \\pm \\ldots \\pm \\sqrt{p_n})   where  p_n  denotes the  n -th prime number and all combinations of signs are taken. This polynomial has degree  2^n  and is irreducible over the integers (it is the minimal polynomial of  \\sqrt{2} + \\ldots + \\sqrt{p_n} ).   source  #  Nemo.cos_minpoly     Method .  cos_minpoly(n::Int, x::fmpz_poly)   Return the minimal polynomial of  2 \\cos(2 \\pi / n) . For suitable choice of   n , this gives the minimal polynomial of  2 \\cos(a \\pi)  or  2 \\sin(a \\pi)  for any rational  a .   source  #  Nemo.theta_qexp     Method .  theta_qexp(e::Int, n::Int, x::fmpz_poly)   Return the  q -expansion to length  n  of the Jacobi theta function raised to the power  r , i.e.  \\vartheta(q)^r  where   \\vartheta(q) = 1 + \\sum_{k=1}^{\\infty} q^{k^2} .   source  #  Nemo.eta_qexp     Method .  eta_qexp(e::Int, n::Int, x::fmpz_poly)   Return the  q -expansion to length  n  of the Dedekind eta function (without  the leading factor  q^{1/24} ) raised to the power  r , i.e.  (q^{-1/24} \\eta(q))^r = \\prod_{k=1}^{\\infty} (1 - q^k)^r . In particular,  r = -1  gives the generating function of the partition function  p(k) , and  r = 24  gives, after multiplication by  q , the modular discriminant  \\Delta(q)  which generates the Ramanujan tau function  \\tau(k) .   source  Here are some examples of special functions.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Special functions"
        }, 
        {
            "location": "/series/", 
            "text": "Introduction\n\n\nNemo allows the creation of capped relative and absolute power series over any computable ring \nR\n. Capped relative power series are power series of the form \na_jx^j + a_{j+1}x^{j+1} + \\cdots + a_{k-1}x^{k-1} + O(x^k)\n where \ni \\geq 0\n, \na_i \\in R\n and the relative precision \nk - j\n is at most equal to some specified precision \nn\n. On the other hand capped absolute power series are power series of the form \na_jx^j + a_{j+1}x^{j+1} + \\cdots + a_{n-1}x^{n-1} + O(x^n)\n where \nj \\geq 0\n, \na_j \\in R\n and the precision \nn\n is fixed.\n\n\nThere are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the relative power series types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenRelSeries{T}\n\n\nGenRelSeriesRing{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_rel_series\n\n\nFmpzRelSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_mod_rel_series\n\n\nFmpzModRelSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{Q}\n\n\n\n\nFlint\n\n\nfmpq_rel_series\n\n\nFmpqRelSerieRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (small \nn\n)\n\n\nFlint\n\n\nfq_nmod_rel_series\n\n\nFqNmodRelSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (large \nn\n)\n\n\nFlint\n\n\nfq_rel_series\n\n\nFqRelSeriesRing\n\n\n\n\n\n\n\n\nAll relative power series elements belong to the abstract type \nRelSeriesElem\n and all of the relative power series ring types belong to the abstract type \nRelSeriesRing\n.\n\n\nThe maximum relative precision, the string representation of the variable and the base ring \nR\n of a generic power series are stored in its parent object. \n\n\nHere is the corresponding table for the absolute power series types.\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenAbsSeries{T}\n\n\nGenAbsSeriesRing{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_abs_series\n\n\nFmpzAbsSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_mod_abs_series\n\n\nFmpzModAbsSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{Q}\n\n\n\n\nFlint\n\n\nfmpq_abs_series\n\n\nFmpqAbsSerieRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (small \nn\n)\n\n\nFlint\n\n\nfq_nmod_abs_series\n\n\nFqNmodAbsSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (large \nn\n)\n\n\nFlint\n\n\nfq_abs_series\n\n\nFqAbsSeriesRing\n\n\n\n\n\n\n\n\nAll absolute power series elements belong to the abstract type \nAbsSeriesElem\n and all of the absolute power series ring types belong to the abstract type \nAbsSeriesRing\n.\n\n\nThe absolute precision, the string representation of the variable and the base ring \nR\n of a generic power series are stored in its parent object. \n\n\nAll power series element types belong to the abstract type \nSeriesElem\n and all of the power series ring types belong to the abstract type \nSeriesRing\n. This enables one to write generic functions that can accept any Nemo power series type.\n\n\n\n\nCapped relative power series\n\n\nCapped relative power series have their maximum relative precision capped at some value \nprec_max\n. This means that if the leading term of a nonzero power series element is \nc_ax^a\n and the precision is \nb\n then the power series is of the form  \nc_ax^a + c_{a+1}x^{a+1} + \\ldots + O(x^{a + b})\n.\n\n\nThe zero power series is simply taken to be \n0 + O(x^b)\n.\n\n\nThe capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series \nf\n and \ng\n we have that \ndivexact(f*g), g) == f\n.\n\n\nHowever, capped relative power series are not additively stable, i.e. we do not always have \n(f + g) - g = f\n.\n\n\nIn the capped relative model we say that two power series are equal if they agree up to the minimum \nabsolute\n precision of the two power series. Thus, for example, \nx^5 + O(x^{10}) == 0 + O(x^5)\n, since the minimum absolute precision is \n5\n.\n\n\nDuring computations, it is possible for power series to lose relative precision due to cancellation. For example if \nf = x^3 + x^5 + O(x^8)\n and \ng = x^3 + x^6 + O(x^8)\n then \nf - g = x^5 - x^6 + O(x^8)\n which now has relative precision \n3\n instead of relative precision \n5\n.\n\n\nAmongst other things, this means that equality is not transitive. For example \nx^6 + O(x^{11}) == 0 + O(x^5)\n and \nx^7 + O(x^{12}) == 0 + O(x^5)\n but \nx^6 + O(x^{11}) \\neq x^7 + O(x^{12})\n.\n\n\nSometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the \nisequal\n function.\n\n\nFor example, if \nf = x^2 + O(x^7)\n and \ng = x^2 + O(x^8)\n and \nh = 0 + O(x^2)\n then \nf == g\n, \nf == h\n and \ng == h\n, but \nisequal(f, g)\n, \nisequal(f, h)\n and \nisequal(g, h)\n would all return \nfalse\n. However, if \nk = x^2 + O(x^7)\n then \nisequal(f, k)\n would return \ntrue\n.\n\n\nThere are further difficulties if we construct polynomial over power series. For example, consider the polynomial in \ny\n over the power series ring in \nx\n over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of \n(0 + O(x^{10}))y + (1 + O(x^{10}))\n?\n\n\nIf one takes it to be \n(0 + O(x^{10}))\n then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.\n\n\nOn the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!\n\n\nOne should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.\n\n\nSimply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!\n\n\n\n\nCapped absolute power series\n\n\nAn absolute power series ring over a ring \nR\n with precision \np\n behaves  very much like the quotient \nR[x]/(x^p)\n of the polynomial ring over \nR\n.\n\n\n\n\nPower series ring constructors\n\n\nIn order to construct power series in Nemo, one must first construct the power series ring itself. This is accomplished with the following constructor.\n\n\n#\n\n\nNemo.PowerSeriesRing\n \n \nMethod\n.\n\n\nPowerSeriesRing(R::Ring, prec::Int, s::AbstractString; cached=true, model=:capped_relative)\n\n\n\n\nReturn a tuple \n(S, x)\n consisting of the parent object \nS\n of a power series ring over the given base ring and a generator \nx\n for the power series ring. The maximum precision of power series in the ring is set to \nprec\n. If the model is set to \n:capped_relative\n this is taken as a maximum relative precision, and if it is set to \n:capped_absolute\n this is take to be a  maximum absolute precision. The supplied string \ns\n specifies the way the generator of the power series ring will be printed. By default, the parent object \nS\n will be cached so that supplying the same base ring, string and precision in future will return the same parent object and generator. If caching of the parent object is not required, \ncached\n can be set to \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of creating a power series ring using the constructor and using the resulting parent object to coerce various elements into the power series ring.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = S(x)\nb = S(t + 1)\nc = S(1)\nd = S(ZZ(2))\nf = S()\n\n\n\n\n\n\nPower series element constructors\n\n\nOnce a power series ring is constructed, there are various ways to construct power series in that ring.\n\n\nThe easiest way is simply using the generator returned by the \nPowerSeriesRing\n constructor and and build up the power series using basic arithmetic. The absolute precision of a power series can be set using the following function.\n\n\nO{T}(a::SeriesElem{T})\n\n\n\n\nIn addition we provide the following functions for constructing certain useful polynomials.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::SeriesRing)\n\n\n\n\n\n\nReturn \n0 + O(x^n)\n where \nn\n is the maximum precision of the power series ring \nR\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\nzero(R::SeriesRing)\n\n\n\n\n\n\nReturn \n1 + O(x^n)\n where \nn\n is the maximum precision of the power series ring \nR\n.\n\n\n\n\nsource\n\n\ngen(::SeriesRing)\n\n\n\n\nHere are some examples of constructing power series.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = x^3 + 2x + 1\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\nc = zero(S)\nd = one(S)\nf = gen(S)\n\n\n\n\n\n\nBasic functionality\n\n\nAll power series modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own power series module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom power series types in Nemo. \n\n\nWe write \nU\n for the type of the power series in the power series ring and \nT\n for the type of elements of the coefficient ring.\n\n\nAll of these functions are provided for all existing power series types in Nemo.\n\n\nparent_type{U \n: SeriesElem}(::Type{U})\n\n\n\n\nGiven the type of power series elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::SeriesRing)\n\n\n\n\nGiven a parent object for the power series ring, return the type of elements of the power series ring.\n\n\nBase.hash(a::SeriesElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the power series \na\n. This should be xor'd with a fixed random hexadecimal specific to the power series type. The hash of each coefficient should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\nfit!(a::SeriesElem, n::Int)\n\n\n\n\nBy reallocating if necessary, ensure that the polynomial underlying the given power series has space for at least \nn\n coefficients. This function does not change the length of the power series and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.\n\n\nnormalise(a::SeriesElem, n::Int)\n\n\n\n\nReturn the normalised length of the polynomial underlying the given power series, assuming its current length is \nn\n. Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the power series. That can be done with a subsequent call to \nset_length!\n using the length returned by \nnormalise\n.\n\n\nset_length!(a::SeriesElem, n::Int)\n\n\n\n\nSet the length of the polynomial underlying a power series assuming it has sufficient space allocated, i.e. a power series for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial power series type has a field, \nlength\n, which corresponds to the current length of the polynomial underlying a power series, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.\n\n\npol_length(a::SeriesElem)\n\n\n\n\nReturn the current length (not the number of allocated coefficients), of the polynomial underlying the given power series. Note that this function only needs to be provided by a developer for a custom power series type if the Julia type definition the power series type doesn't contain a field \nlength\n corresponding to the current length of the polynomial underlying the power series. Otherwise the supplied generic implementation will work.\n\n\nset_prec!(a::SeriesElem, n::Int)\n\n\n\n\nSet the precision of the given power series to \nn\n. Note this function only needs to be provided by a developer for a custom power series type if the Julia type definition of the power series type doesn't contain a field \nprec\n corresponding to the current precision of the power series. Otherwise the supplied generic implementation will work.\n\n\nprecision(a::SeriesElem)\n\n\n\n\nReturn the current precision of the given power series. This function does not have to be provided by a developer of a custom power series type if the Julia type definition of the power series type contains a field \nprec\n corresponding to the current precision of the power series. In this case the supplied generic implementation will work. Note that for convenience, the precision is stored as an absolute precision.\n\n\ncoeff(a::SeriesElem, n::Int)\n\n\n\n\nReturn the degree \nn\n coefficient of the given power series. Note coefficients are numbered from \nn = 0\n for the constant coefficient. If \nn\n exceeds the current precision of the power series, the function returns a zero coefficient. We require \nn \\geq 0\n. \n\n\nsetcoeff!{T \n: RingElem}(a::SeriesElem{T}, n::Int, c::T)\n\n\n\n\nSet the coefficient of the degree \nn\n term of the given power series to the given value \na\n. The polynomial underlying the power series is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.\n\n\ndeepcopy(a::SeriesElem)\n\n\n\n\nConstruct a copy of the given power series and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo power series are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::SeriesElem, a::SeriesElem, b::SeriesElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing power series \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::SeriesElem, a::SeriesElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a power series ring, the following coercion functions are provided to coerce various elements into the power series ring. Developers provide these by overloading the \ncall\n operator for the polynomial parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the ring \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the power series ring \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(A::Array{T, 1}, len::Int, prec::Int)\n\n\n\n\nTake an array of elements in the base ring, of type \nT\n and construct the power series with those coefficients. The length of the underlying polynomial and the precision of the power series will be set to the given values.\n\n\nS(f::SeriesElem)\n\n\n\n\nTake a power series that is already in the ring \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the power series ring. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom power series must ensure the parent object of a power series type constains a field \nbase_ring\n specifying the base ring, a field \nS\n containing a symbol (not a string) representing the variable name of the power series ring and a field \nmax_prec\n specifying the maximum relative precision of the power series. They must also ensure that each power series element contains a field \nparent\n specifying the parent object of the power series.\n\n\nTypically a developer will also overload the \nPowerSeriesRing\n generic function to create power series of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(R::SeriesRing)\n\n\n\n\n\n\nReturn the base ring of the given power series ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::SeriesElem)\n\n\n\n\n\n\nReturn the base ring of the power series ring of the given power series.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::SeriesElem)\n\n\n\n\n\n\nReturn the parent of the given power series.\n\n\n\n\nsource\n\n\n#\n\n\nBase.var\n \n \nMethod\n.\n\n\nvar(a::SeriesRing)\n\n\n\n\n\n\nReturn the internal name of the generator of the power series ring. Note that this is returned as a \nSymbol\n not a \nString\n.\n\n\n\n\nsource\n\n\nvaluation(::SeriesElem)\n\n\n\n\n#\n\n\nNemo.max_precision\n \n \nMethod\n.\n\n\nmax_precision(R::SeriesRing)\n\n\n\n\n\n\nReturn the maximum relative precision of power series in the given power series ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus{T \n: ResElem}(a::SeriesElem{T})\n\n\n\n\n\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::SeriesElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given power series is arithmetically equal to zero to its current precision, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nisone(::SeriesElem)\n\n\n\n\nisgen(::SeriesElem)\n\n\n\n\nisunit(::SeriesElem)\n\n\n\n\nHere are some examples of basic manipulation of power series.\n\n\nR, t = PowerSeriesRing(QQ, 10, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = O(x^4)\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\n\nc = gen(R)\nd = zero(R)\nf = one(S)\n\ng = iszero(d)\nh = isone(f)\nk = isgen(c)\nm = isunit(-1 + x + 2x^2)\nn = valuation(a)\np = valuation(b)\ns = var(S)\nU = base_ring(S)\nV = base_ring(t)\nW = parent(t + 1)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo power series. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\nThe following operators and functions are provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::SeriesElem)\n\n\nunary minus\n\n\n\n\n\n\n+{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\naddition\n\n\n\n\n\n\n-{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\nmultiplication\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\nexact division\n\n\n\n\n\n\n\n\nThe following ad hoc operators are also provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::Integer, b::SeriesElem)\n\n\naddition\n\n\n\n\n\n\n+(a::SeriesElem, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::SeriesElem)\n\n\naddition\n\n\n\n\n\n\n+(a::SeriesElem, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\naddition\n\n\n\n\n\n\n-(a::Integer, b::SeriesElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::SeriesElem, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::SeriesElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::SeriesElem, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::Integer, b::SeriesElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::SeriesElem, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::SeriesElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::SeriesElem, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::SeriesElem, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::SeriesElem, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\nexact division\n\n\n\n\n\n\n^(a::SeriesElem, n::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on power series.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = x^2 + 3x^3 - x^4\n\nf = -a\ng = a + b\nh = a - c\nk = b*c\nm = a*c\nn = a*d\np = 2a\nq = fmpz(3)*b\nr = c*2\ns = d*fmpz(3)\nt = a^12\nu = divexact(b, c)\nv = divexact(a, 7)\nw = divexact(b, fmpz(11))\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for power series in Nemo. Julia provides the corresponding \n!=\n function automatically.\n\n\n\n\nFunction\n\n\nisequal{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n \n=={T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\nThe \nisequal\n function is a stronger notion of equality. It requires that the precision of the power series is identical as well as the power series being arithmetically equal. Coefficients are also compared using \nisequal\n recursively. The \n==\n function notionally truncates both power series to the lower of the two (absolute) precisions, and then compares arithmetically.\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n\n\nFunction\n\n\n=={T \n: RingElem}(a::SeriesElem{T}, b::T)\n \n=={T \n: RingElem}(a::T, b::SeriesElem{T})\n \n==(a::SeriesElem, b::Integer)\n \n==(a::Integer, b::SeriesElem)\n \n==(a::SeriesElem, b::fmpz)\n \n==(a::fmpz, b::SeriesElem)\n\n\nHere are some examples of comparisons.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^3)\nc = 1 + x + 3x^2 + O(x^5)\nd = 3x^3 - x^4\n\na == 2x + x^3\nb == d\nc != d\nisequal(b, d)\nd == 3\nc == fmpz(1)\nfmpz(0) != a\n2 == b\nfmpz(1) == c\n\n\n\n\n\n\nShifting\n\n\nshift_left(::SeriesElem, ::Int)\n\n\n\n\nshift_right(::SeriesElem, ::Int)\n\n\n\n\nHere are some examples of shifting.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = shift_left(a, 2)\ng = shift_left(b, 2)\nh = shift_right(c, 1)\nk = shift_right(d, 3)\n\n\n\n\n\n\nTruncation\n\n\ntruncate(::SeriesElem, ::Int)\n\n\n\n\nHere are some examples of truncation.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = truncate(a, 3)\ng = truncate(b, 2)\nh = truncate(c, 7)\nk = truncate(d, 5)\n\n\n\n\n\n\nInverse\n\n\ninv(a::SeriesElem)\n\n\n\n\nHere are some examples of taking the inverse.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 1 + x + 2x^2 + O(x^5)\nb = S(-1)\n\nc = inv(a)\nd = inv(b)\n\n\n\n\n\n\nSpecial functions\n\n\nexp(a::SeriesElem)\n\n\n\n\nThe following special functions are only available for certain rings.\n\n\n#\n\n\nBase.log\n \n \nMethod\n.\n\n\nlog(a::fmpq_rel_series)\n\n\n\n\nReturn log\n(a)\n. Requires the constant term to be one.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sqrt\n \n \nMethod\n.\n\n\nsqrt(a::fmpq_rel_series)\n\n\n\n\nReturn the power series square root of \na\n. Requires a constant term equal to one.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tan\n \n \nMethod\n.\n\n\ntan(a::fmpq_rel_series)\n\n\n\n\nReturn tan\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tanh\n \n \nMethod\n.\n\n\ntanh(a::fmpq_rel_series)\n\n\n\n\nReturn tanh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sin\n \n \nMethod\n.\n\n\nsin(a::fmpq_rel_series)\n\n\n\n\nReturn sin\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sinh\n \n \nMethod\n.\n\n\nsinh(a::fmpq_rel_series)\n\n\n\n\nReturn sinh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cos\n \n \nMethod\n.\n\n\ncos(a::fmpq_rel_series)\n\n\n\n\nReturn cos\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cosh\n \n \nMethod\n.\n\n\ncosh(a::fmpq_rel_series)\n\n\n\n\nReturn cosh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.asin\n \n \nMethod\n.\n\n\nasin(a::fmpq_rel_series)\n\n\n\n\nReturn asin\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.asinh\n \n \nMethod\n.\n\n\nasinh(a::fmpq_rel_series)\n\n\n\n\nReturn asinh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.atan\n \n \nMethod\n.\n\n\natan(a::fmpq_rel_series)\n\n\n\n\nReturn atan\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.atanh\n \n \nMethod\n.\n\n\natanh(a::fmpq_rel_series)\n\n\n\n\nReturn atanh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\nT, z = PowerSeriesRing(QQ, 30, \nz\n)\n\na = 1 + z + 3z^2 + O(z^5)\nb = z + 2z^2 + 5z^3 + O(z^5)\n\nc = exp(x + O(x^40))\nd = divexact(x, exp(x + O(x^40)) - 1)\nf = exp(b)\ng = log(a)\nh = sqrt(a)\nk = sin(b)\nm = atanh(b)", 
            "title": "Capped relative power series"
        }, 
        {
            "location": "/series/#introduction", 
            "text": "Nemo allows the creation of capped relative and absolute power series over any computable ring  R . Capped relative power series are power series of the form  a_jx^j + a_{j+1}x^{j+1} + \\cdots + a_{k-1}x^{k-1} + O(x^k)  where  i \\geq 0 ,  a_i \\in R  and the relative precision  k - j  is at most equal to some specified precision  n . On the other hand capped absolute power series are power series of the form  a_jx^j + a_{j+1}x^{j+1} + \\cdots + a_{n-1}x^{n-1} + O(x^n)  where  j \\geq 0 ,  a_j \\in R  and the precision  n  is fixed.  There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.  The following table shows each of the relative power series types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenRelSeries{T}  GenRelSeriesRing{T}     \\mathbb{Z}   Flint  fmpz_rel_series  FmpzRelSeriesRing     \\mathbb{Z}/n\\mathbb{Z}   Flint  fmpz_mod_rel_series  FmpzModRelSeriesRing     \\mathbb{Q}   Flint  fmpq_rel_series  FmpqRelSerieRing     \\mathbb{F}_{p^n}  (small  n )  Flint  fq_nmod_rel_series  FqNmodRelSeriesRing     \\mathbb{F}_{p^n}  (large  n )  Flint  fq_rel_series  FqRelSeriesRing     All relative power series elements belong to the abstract type  RelSeriesElem  and all of the relative power series ring types belong to the abstract type  RelSeriesRing .  The maximum relative precision, the string representation of the variable and the base ring  R  of a generic power series are stored in its parent object.   Here is the corresponding table for the absolute power series types.     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenAbsSeries{T}  GenAbsSeriesRing{T}     \\mathbb{Z}   Flint  fmpz_abs_series  FmpzAbsSeriesRing     \\mathbb{Z}/n\\mathbb{Z}   Flint  fmpz_mod_abs_series  FmpzModAbsSeriesRing     \\mathbb{Q}   Flint  fmpq_abs_series  FmpqAbsSerieRing     \\mathbb{F}_{p^n}  (small  n )  Flint  fq_nmod_abs_series  FqNmodAbsSeriesRing     \\mathbb{F}_{p^n}  (large  n )  Flint  fq_abs_series  FqAbsSeriesRing     All absolute power series elements belong to the abstract type  AbsSeriesElem  and all of the absolute power series ring types belong to the abstract type  AbsSeriesRing .  The absolute precision, the string representation of the variable and the base ring  R  of a generic power series are stored in its parent object.   All power series element types belong to the abstract type  SeriesElem  and all of the power series ring types belong to the abstract type  SeriesRing . This enables one to write generic functions that can accept any Nemo power series type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/series/#capped-relative-power-series", 
            "text": "Capped relative power series have their maximum relative precision capped at some value  prec_max . This means that if the leading term of a nonzero power series element is  c_ax^a  and the precision is  b  then the power series is of the form   c_ax^a + c_{a+1}x^{a+1} + \\ldots + O(x^{a + b}) .  The zero power series is simply taken to be  0 + O(x^b) .  The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series  f  and  g  we have that  divexact(f*g), g) == f .  However, capped relative power series are not additively stable, i.e. we do not always have  (f + g) - g = f .  In the capped relative model we say that two power series are equal if they agree up to the minimum  absolute  precision of the two power series. Thus, for example,  x^5 + O(x^{10}) == 0 + O(x^5) , since the minimum absolute precision is  5 .  During computations, it is possible for power series to lose relative precision due to cancellation. For example if  f = x^3 + x^5 + O(x^8)  and  g = x^3 + x^6 + O(x^8)  then  f - g = x^5 - x^6 + O(x^8)  which now has relative precision  3  instead of relative precision  5 .  Amongst other things, this means that equality is not transitive. For example  x^6 + O(x^{11}) == 0 + O(x^5)  and  x^7 + O(x^{12}) == 0 + O(x^5)  but  x^6 + O(x^{11}) \\neq x^7 + O(x^{12}) .  Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the  isequal  function.  For example, if  f = x^2 + O(x^7)  and  g = x^2 + O(x^8)  and  h = 0 + O(x^2)  then  f == g ,  f == h  and  g == h , but  isequal(f, g) ,  isequal(f, h)  and  isequal(g, h)  would all return  false . However, if  k = x^2 + O(x^7)  then  isequal(f, k)  would return  true .  There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in  y  over the power series ring in  x  over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of  (0 + O(x^{10}))y + (1 + O(x^{10})) ?  If one takes it to be  (0 + O(x^{10}))  then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.  On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!  One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.  Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!", 
            "title": "Capped relative power series"
        }, 
        {
            "location": "/series/#capped-absolute-power-series", 
            "text": "An absolute power series ring over a ring  R  with precision  p  behaves  very much like the quotient  R[x]/(x^p)  of the polynomial ring over  R .", 
            "title": "Capped absolute power series"
        }, 
        {
            "location": "/series/#power-series-ring-constructors", 
            "text": "In order to construct power series in Nemo, one must first construct the power series ring itself. This is accomplished with the following constructor.  #  Nemo.PowerSeriesRing     Method .  PowerSeriesRing(R::Ring, prec::Int, s::AbstractString; cached=true, model=:capped_relative)   Return a tuple  (S, x)  consisting of the parent object  S  of a power series ring over the given base ring and a generator  x  for the power series ring. The maximum precision of power series in the ring is set to  prec . If the model is set to  :capped_relative  this is taken as a maximum relative precision, and if it is set to  :capped_absolute  this is take to be a  maximum absolute precision. The supplied string  s  specifies the way the generator of the power series ring will be printed. By default, the parent object  S  will be cached so that supplying the same base ring, string and precision in future will return the same parent object and generator. If caching of the parent object is not required,  cached  can be set to  false .   source  Here are some examples of creating a power series ring using the constructor and using the resulting parent object to coerce various elements into the power series ring.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = S(x)\nb = S(t + 1)\nc = S(1)\nd = S(ZZ(2))\nf = S()", 
            "title": "Power series ring constructors"
        }, 
        {
            "location": "/series/#power-series-element-constructors", 
            "text": "Once a power series ring is constructed, there are various ways to construct power series in that ring.  The easiest way is simply using the generator returned by the  PowerSeriesRing  constructor and and build up the power series using basic arithmetic. The absolute precision of a power series can be set using the following function.  O{T}(a::SeriesElem{T})  In addition we provide the following functions for constructing certain useful polynomials.  #  Base.zero     Method .  zero(R::SeriesRing)   Return  0 + O(x^n)  where  n  is the maximum precision of the power series ring  R .   source  #  Base.one     Method .  zero(R::SeriesRing)   Return  1 + O(x^n)  where  n  is the maximum precision of the power series ring  R .   source  gen(::SeriesRing)  Here are some examples of constructing power series.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = x^3 + 2x + 1\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\nc = zero(S)\nd = one(S)\nf = gen(S)", 
            "title": "Power series element constructors"
        }, 
        {
            "location": "/series/#basic-functionality", 
            "text": "All power series modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own power series module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom power series types in Nemo.   We write  U  for the type of the power series in the power series ring and  T  for the type of elements of the coefficient ring.  All of these functions are provided for all existing power series types in Nemo.  parent_type{U  : SeriesElem}(::Type{U})  Given the type of power series elements, should return the type of the corresponding parent object.  elem_type(R::SeriesRing)  Given a parent object for the power series ring, return the type of elements of the power series ring.  Base.hash(a::SeriesElem, h::UInt)  Return a  UInt  hexadecimal hash of the power series  a . This should be xor'd with a fixed random hexadecimal specific to the power series type. The hash of each coefficient should be xor'd with the supplied parameter  h  as part of computing the hash.  fit!(a::SeriesElem, n::Int)  By reallocating if necessary, ensure that the polynomial underlying the given power series has space for at least  n  coefficients. This function does not change the length of the power series and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.  normalise(a::SeriesElem, n::Int)  Return the normalised length of the polynomial underlying the given power series, assuming its current length is  n . Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the power series. That can be done with a subsequent call to  set_length!  using the length returned by  normalise .  set_length!(a::SeriesElem, n::Int)  Set the length of the polynomial underlying a power series assuming it has sufficient space allocated, i.e. a power series for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial power series type has a field,  length , which corresponds to the current length of the polynomial underlying a power series, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.  pol_length(a::SeriesElem)  Return the current length (not the number of allocated coefficients), of the polynomial underlying the given power series. Note that this function only needs to be provided by a developer for a custom power series type if the Julia type definition the power series type doesn't contain a field  length  corresponding to the current length of the polynomial underlying the power series. Otherwise the supplied generic implementation will work.  set_prec!(a::SeriesElem, n::Int)  Set the precision of the given power series to  n . Note this function only needs to be provided by a developer for a custom power series type if the Julia type definition of the power series type doesn't contain a field  prec  corresponding to the current precision of the power series. Otherwise the supplied generic implementation will work.  precision(a::SeriesElem)  Return the current precision of the given power series. This function does not have to be provided by a developer of a custom power series type if the Julia type definition of the power series type contains a field  prec  corresponding to the current precision of the power series. In this case the supplied generic implementation will work. Note that for convenience, the precision is stored as an absolute precision.  coeff(a::SeriesElem, n::Int)  Return the degree  n  coefficient of the given power series. Note coefficients are numbered from  n = 0  for the constant coefficient. If  n  exceeds the current precision of the power series, the function returns a zero coefficient. We require  n \\geq 0 .   setcoeff!{T  : RingElem}(a::SeriesElem{T}, n::Int, c::T)  Set the coefficient of the degree  n  term of the given power series to the given value  a . The polynomial underlying the power series is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.  deepcopy(a::SeriesElem)  Construct a copy of the given power series and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo power series are mutable and so returning shallow copies is not sufficient.  mul!(c::SeriesElem, a::SeriesElem, b::SeriesElem)  Multiply  a  by  b  and set the existing power series  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::SeriesElem, a::SeriesElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a power series ring, the following coercion functions are provided to coerce various elements into the power series ring. Developers provide these by overloading the  call  operator for the polynomial parent objects.  S()  Coerce zero into the ring  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the power series ring  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(A::Array{T, 1}, len::Int, prec::Int)  Take an array of elements in the base ring, of type  T  and construct the power series with those coefficients. The length of the underlying polynomial and the precision of the power series will be set to the given values.  S(f::SeriesElem)  Take a power series that is already in the ring  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the power series ring. This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom power series must ensure the parent object of a power series type constains a field  base_ring  specifying the base ring, a field  S  containing a symbol (not a string) representing the variable name of the power series ring and a field  max_prec  specifying the maximum relative precision of the power series. They must also ensure that each power series element contains a field  parent  specifying the parent object of the power series.  Typically a developer will also overload the  PowerSeriesRing  generic function to create power series of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/series/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(R::SeriesRing)   Return the base ring of the given power series ring.   source  #  Nemo.base_ring     Method .  base_ring(a::SeriesElem)   Return the base ring of the power series ring of the given power series.   source  #  Base.parent     Method .  parent(a::SeriesElem)   Return the parent of the given power series.   source  #  Base.var     Method .  var(a::SeriesRing)   Return the internal name of the generator of the power series ring. Note that this is returned as a  Symbol  not a  String .   source  valuation(::SeriesElem)  #  Nemo.max_precision     Method .  max_precision(R::SeriesRing)   Return the maximum relative precision of power series in the given power series ring.   source  #  Nemo.modulus     Method .  modulus{T  : ResElem}(a::SeriesElem{T})   Return the modulus of the coefficients of the given polynomial.   source  #  Nemo.iszero     Method .  iszero(a::SeriesElem)   Return  true  if the given power series is arithmetically equal to zero to its current precision, otherwise return  false .   source  isone(::SeriesElem)  isgen(::SeriesElem)  isunit(::SeriesElem)  Here are some examples of basic manipulation of power series.  R, t = PowerSeriesRing(QQ, 10,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = O(x^4)\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\n\nc = gen(R)\nd = zero(R)\nf = one(S)\n\ng = iszero(d)\nh = isone(f)\nk = isgen(c)\nm = isunit(-1 + x + 2x^2)\nn = valuation(a)\np = valuation(b)\ns = var(S)\nU = base_ring(S)\nV = base_ring(t)\nW = parent(t + 1)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/series/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo power series. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  The following operators and functions are provided.     Function  Operation      -(a::SeriesElem)  unary minus    +{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})  addition    -{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})  subtraction    *{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})  multiplication    divexact{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})  exact division     The following ad hoc operators are also provided.     Function  Operation      +(a::Integer, b::SeriesElem)  addition    +(a::SeriesElem, b::Integer)  addition    +(a::fmpz, b::SeriesElem)  addition    +(a::SeriesElem, b::fmpz)  addition    +{T  : RingElem}(a::T, b::SeriesElem{T})  addition    +{T  : RingElem}(a::SeriesElem{T}, b::T)  addition    -(a::Integer, b::SeriesElem)  subtraction    -(a::SeriesElem, b::Integer)  subtraction    -(a::fmpz, b::SeriesElem)  subtraction    -(a::SeriesElem, b::fmpz)  subtraction    -{T  : RingElem}(a::T, b::SeriesElem{T})  subtraction    -{T  : RingElem}(a::SeriesElem{T}, b::T)  subtraction    *(a::Integer, b::SeriesElem)  multiplication    *(a::SeriesElem, b::Integer)  multiplication    *(a::fmpz, b::SeriesElem)  multiplication    *(a::SeriesElem, b::fmpz)  multiplication    *{T  : RingElem}(a::T, b::SeriesElem{T})  multiplication    *{T  : RingElem}(a::SeriesElem{T}, b::T)  multiplication    divexact(a::SeriesElem, b::Integer)  exact division    divexact(a::SeriesElem, b::fmpz)  exact division    divexact{T  : RingElem}(a::SeriesElem{T}, b::T)  exact division    ^(a::SeriesElem, n::Int)  powering     If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on power series.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = x^2 + 3x^3 - x^4\n\nf = -a\ng = a + b\nh = a - c\nk = b*c\nm = a*c\nn = a*d\np = 2a\nq = fmpz(3)*b\nr = c*2\ns = d*fmpz(3)\nt = a^12\nu = divexact(b, c)\nv = divexact(a, 7)\nw = divexact(b, fmpz(11))", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/series/#comparison-operators", 
            "text": "The following comparison operators are implemented for power series in Nemo. Julia provides the corresponding  !=  function automatically.", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/series/#function", 
            "text": "isequal{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})   =={T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})  The  isequal  function is a stronger notion of equality. It requires that the precision of the power series is identical as well as the power series being arithmetically equal. Coefficients are also compared using  isequal  recursively. The  ==  function notionally truncates both power series to the lower of the two (absolute) precisions, and then compares arithmetically.  In addition we have the following ad hoc comparison operators.", 
            "title": "Function"
        }, 
        {
            "location": "/series/#function_1", 
            "text": "=={T  : RingElem}(a::SeriesElem{T}, b::T)   =={T  : RingElem}(a::T, b::SeriesElem{T})   ==(a::SeriesElem, b::Integer)   ==(a::Integer, b::SeriesElem)   ==(a::SeriesElem, b::fmpz)   ==(a::fmpz, b::SeriesElem)  Here are some examples of comparisons.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^3)\nc = 1 + x + 3x^2 + O(x^5)\nd = 3x^3 - x^4\n\na == 2x + x^3\nb == d\nc != d\nisequal(b, d)\nd == 3\nc == fmpz(1)\nfmpz(0) != a\n2 == b\nfmpz(1) == c", 
            "title": "Function"
        }, 
        {
            "location": "/series/#shifting", 
            "text": "shift_left(::SeriesElem, ::Int)  shift_right(::SeriesElem, ::Int)  Here are some examples of shifting.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = shift_left(a, 2)\ng = shift_left(b, 2)\nh = shift_right(c, 1)\nk = shift_right(d, 3)", 
            "title": "Shifting"
        }, 
        {
            "location": "/series/#truncation", 
            "text": "truncate(::SeriesElem, ::Int)  Here are some examples of truncation.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = truncate(a, 3)\ng = truncate(b, 2)\nh = truncate(c, 7)\nk = truncate(d, 5)", 
            "title": "Truncation"
        }, 
        {
            "location": "/series/#inverse", 
            "text": "inv(a::SeriesElem)  Here are some examples of taking the inverse.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 1 + x + 2x^2 + O(x^5)\nb = S(-1)\n\nc = inv(a)\nd = inv(b)", 
            "title": "Inverse"
        }, 
        {
            "location": "/series/#special-functions", 
            "text": "exp(a::SeriesElem)  The following special functions are only available for certain rings.  #  Base.log     Method .  log(a::fmpq_rel_series)   Return log (a) . Requires the constant term to be one.   source  #  Base.sqrt     Method .  sqrt(a::fmpq_rel_series)   Return the power series square root of  a . Requires a constant term equal to one.   source  #  Base.tan     Method .  tan(a::fmpq_rel_series)   Return tan (a) . Requires a zero constant term.   source  #  Base.tanh     Method .  tanh(a::fmpq_rel_series)   Return tanh (a) . Requires a zero constant term.   source  #  Base.sin     Method .  sin(a::fmpq_rel_series)   Return sin (a) . Requires a zero constant term.   source  #  Base.sinh     Method .  sinh(a::fmpq_rel_series)   Return sinh (a) . Requires a zero constant term.   source  #  Base.cos     Method .  cos(a::fmpq_rel_series)   Return cos (a) . Requires a zero constant term.   source  #  Base.cosh     Method .  cosh(a::fmpq_rel_series)   Return cosh (a) . Requires a zero constant term.   source  #  Base.asin     Method .  asin(a::fmpq_rel_series)   Return asin (a) . Requires a zero constant term.   source  #  Base.asinh     Method .  asinh(a::fmpq_rel_series)   Return asinh (a) . Requires a zero constant term.   source  #  Base.atan     Method .  atan(a::fmpq_rel_series)   Return atan (a) . Requires a zero constant term.   source  #  Base.atanh     Method .  atanh(a::fmpq_rel_series)   Return atanh (a) . Requires a zero constant term.   source  Here are some examples of special functions.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\nT, z = PowerSeriesRing(QQ, 30,  z )\n\na = 1 + z + 3z^2 + O(z^5)\nb = z + 2z^2 + 5z^3 + O(z^5)\n\nc = exp(x + O(x^40))\nd = divexact(x, exp(x + O(x^40)) - 1)\nf = exp(b)\ng = log(a)\nh = sqrt(a)\nk = sin(b)\nm = atanh(b)", 
            "title": "Special functions"
        }, 
        {
            "location": "/residue/", 
            "text": "Introduction\n\n\nNemo allows the creation of residue rings of the form \nR/(a)\n for an element \na\n of a ring \nR\n.\n\n\nWe don't require \n(a)\n to be a prime or maximal ideal. Instead, we allow the creation of the residue ring \nR/(a)\n for any nonzero \na\n and simply raise an exception if an impossible inverse is encountered during computations  involving elements of \nR/(a)\n.\n\n\nThere is a generic implementation of residue rings of this form in Nemo, which accepts any ring \nR\n as base ring. The associated types of parent object and elements in such residue rings are given in the following table.\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenRes{T}\n\n\nGeResRing{T}\n\n\n\n\n\n\n\n\nThe modulus \na\n of a residue ring is stored in its parent object.\n\n\nAll residue element types belong to the abstract type \nResElem\n and all the residue ring parent object types belong to the abstract type \nResRing\n. This enables one to write generic functions that accept any Nemo residue type.\n\n\n\n\nResidue ring constructors\n\n\nIn order to construct residues in Nemo, one must first construct the residue ring itself. This is accomplished with the following constructor.\n\n\n#\n\n\nNemo.ResidueRing\n \n \nMethod\n.\n\n\nResidueRing{T \n: RingElem}(R::Ring, a::T; cached=true)\n\n\n\n\n\n\nCreate the residue ring \nR/(a)\n where \na\n is an element of the ring \nR\n. We require \na \\neq 0\n. If \ncached == true\n (the default) then the resulting residue ring parent object is cached and returned for any subsequent calls to the constructor with the same base ring \nR\n and element \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into those rings.\n\n\nR = ResidueRing(ZZ, 17)\nS, x = PolynomialRing(QQ, \nx\n)\nT = ResidueRing(S, x^2 + 1)\n\na = R(11)\nb = T(x)\nc = T(ZZ(3))\n\n\n\n\n\n\nResidue element constructors\n\n\nOnce a residue ring is constructed, there are various ways to construct residues in that ring.\n\n\nApart from coercing elements into the residue ring as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::ResRing)\n\n\n\n\n\n\nReturn the zero element of the given residue ring, i.e. \n0 \\pmod{a}\n where \na\n is the modulus of the residue ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\nzero(R::ResRing)\n\n\n\n\n\n\nReturn \n1 \\pmod{a}\n where \na\n is the modulus of the residue ring.\n\n\n\n\nsource\n\n\nHere are some examples of constructing residues.\n\n\nR = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)\n\n\n\n\n\n\nBasic functionality\n\n\nAll residue ring modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own residue ring module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom residue ring types in Nemo. \n\n\nWe write \nU\n for the type of residue elements in the residue ring and \nT\n for the type of elements of the base ring.\n\n\nAll of these functions are provided for all existing residue types in Nemo.\n\n\nparent_type{U \n: ResElem}(::Type{U})\n\n\n\n\nGiven the type of residue elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::ResRing)\n\n\n\n\nGiven a parent object for the residue ring, return the type of elements of the residue ring.\n\n\nBase.hash(a::ResElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the residue \na\n. This should be xor'd with a fixed random hexadecimal specific to the residue type. The hash of the data associated with a residue should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndata(a::ResElem)\n\n\n\n\nReturn the data of the given residue element, i.e. for \nc \\pmod{a}\n in the ring \nR/(a)\n return the value \nc\n as an element of the ring \nR\n.\n\n\ndeepcopy(a::ResElem)\n\n\n\n\nConstruct a copy of the given residue and return it. This function must recursively construct copies of all of the internal data in the given residue. Nemo residues are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::ResElem, a::ResElem, b::ResElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing residue \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::ResElem, a::ResElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a residue ring, the following coercion functions are provided to coerce various elements into the residue ring. Developers provide these by overloading the \ncall\n operator for the residue ring parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the ring \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the residue ring \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(f::ResElem)\n\n\n\n\nTake a residue that is already in the ring \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the residue ring. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom residues must ensure the parent object of a residue type constains a field \nbase_ring\n specifying the base ring, a field \nmodulus\n containing the modulus \na\n of the residue ring \nR/(a)\n. They must also ensure that each residue element contains a field \nparent\n specifying the parent object of the residue.\n\n\nTypically a developer will also overload the \nResidueRing\n generic function to create residues of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate residues. Also see the section on basic functionality above.\n\n\nbase_ring(::ResRing)\n\n\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(r::ResElem)\n\n\n\n\n\n\nReturn the base ring \nR\n of the residue ring \nR/(a)\n that the supplied element \nr\n belongs to.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::ResElem)\n\n\n\n\n\n\nReturn the parent object of the given residue element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus(R::ResRing)\n\n\n\n\n\n\nReturn the modulus \na\n of the given residue ring \nS = R/(a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus(R::ResRing)\n\n\n\n\n\n\nReturn the modulus \na\n of the residue ring \nS = R/(a)\n that the supplied residue \nr\n belongs to.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is zero in the residue ring it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is one in the residue ring it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\niszero(a::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is invertible in the residue ring it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of residues.\n\n\nR = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)\n\na = modulus(R)\nb = modulus(T(x + 1))\nc = isunit(h)\nd = isone(h)\nf = iszero(g)\nU = parent(g)\nV = base_ring(R)\nW = base_ring(T(x + 1))\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo residues. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\nThe following operators and functions are provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::ResElem)\n\n\nunary minus\n\n\n\n\n\n\n+{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\naddition\n\n\n\n\n\n\n-{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n*{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\nmultiplication\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\nexact division\n\n\n\n\n\n\n\n\nThe following ad hoc operators are also provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::Integer, b::ResElem)\n\n\naddition\n\n\n\n\n\n\n+(a::ResElem, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::ResElem)\n\n\naddition\n\n\n\n\n\n\n+(a::ResElem, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::T, b::ResElem{T})\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\naddition\n\n\n\n\n\n\n-(a::Integer, b::ResElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::ResElem, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::ResElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::ResElem, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::T, b::ResElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::Integer, b::ResElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::ResElem, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::ResElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::ResElem, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::T, b::ResElem{T})\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\nmultiplication\n\n\n\n\n\n\n^(a::ResElem, n::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on residues.\n\n\nR = ResidueRing(ZZ, 16453889)\n\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\nf = R(4)\ng = R(6)\nn = T(x^5 + 1)\np = T(x^2 + 2x + 1)\n\na = -R(12345)\nb = -T(x^5 + 1)\nc = f + g\nd = f - g\nh = f*g\nk = n + p\nl = n - p\nm = n*p\nq = divexact(a*b, a)\nr = divexact(n*p, p)\ns = f + 3\nt = 3 - g\nu = 5g\nv = n + 4\nw = 4 - p\ny = n*5\nz = p^12\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for residues in Nemo. Julia provides the corresponding \n!=\n operator automatically.\n\n\n\n\nFunction\n\n\nisequal{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n \n=={T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\nThe \nisequal\n operation returns \ntrue\n if and only if residues are precisely equal as compared by \nisequal\n. This is a stronger form of equality, used for comparing inexact ring elements, such as elements of a power series ring, the \np\n-adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal. \n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n\n\nFunction\n\n\n=={T \n: RingElem}(a::ResElem{T}, b::T)\n \n=={T \n: RingElem}(a::T, b::ResElem{T})\n \n==(a::ResElem, b::Integer)\n \n==(a::Integer, b::ResElem)\n \n==(a::ResElem, b::fmpz)\n \n==(a::fmpz, b::ResElem)\n\n\nHere are some examples of comparisons.\n\n\nR = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(3)\nb = a\nc = R(2)\nf = T(x^5 + 1)\ng = 8f\nh = f + g\n\nb == a\nc != a\nf == g\nh != g\nisequal(f, g)\na == 3\n4 != a\nf != 5\n\n\n\n\n\n\nInversion\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(a::ResElem)\n\n\n\n\n\n\nReturn the inverse of the element \na\n in the residue ring. If an impossible inverse is encountered, an exception is raised.\n\n\n\n\nsource\n\n\nHere are some examples of computing inverses.\n\n\nR = ResidueRing(ZZ, 49)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(5)\nf = T(x^5 + 1)\n\nb = inv(a)\ng = inv(f)\n\n\n\n\n\n\nGreatest common divisor\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn a greatest common divisor of \na\n and \nb\n if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.\n\n\n\n\nsource\n\n\nHere are some examples of computing a greatest common divisor.\n\n\nR = ResidueRing(ZZ, 43)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 - 2x + 1)\n\na = R(5)\nb = R(7)\nc = T(x^5 + 1)\nd = T(x^2 + x)\n\nf = gcd(a, b)\ng = gcd(c, d)", 
            "title": "Residue rings"
        }, 
        {
            "location": "/residue/#introduction", 
            "text": "Nemo allows the creation of residue rings of the form  R/(a)  for an element  a  of a ring  R .  We don't require  (a)  to be a prime or maximal ideal. Instead, we allow the creation of the residue ring  R/(a)  for any nonzero  a  and simply raise an exception if an impossible inverse is encountered during computations  involving elements of  R/(a) .  There is a generic implementation of residue rings of this form in Nemo, which accepts any ring  R  as base ring. The associated types of parent object and elements in such residue rings are given in the following table.     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenRes{T}  GeResRing{T}     The modulus  a  of a residue ring is stored in its parent object.  All residue element types belong to the abstract type  ResElem  and all the residue ring parent object types belong to the abstract type  ResRing . This enables one to write generic functions that accept any Nemo residue type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/residue/#residue-ring-constructors", 
            "text": "In order to construct residues in Nemo, one must first construct the residue ring itself. This is accomplished with the following constructor.  #  Nemo.ResidueRing     Method .  ResidueRing{T  : RingElem}(R::Ring, a::T; cached=true)   Create the residue ring  R/(a)  where  a  is an element of the ring  R . We require  a \\neq 0 . If  cached == true  (the default) then the resulting residue ring parent object is cached and returned for any subsequent calls to the constructor with the same base ring  R  and element  a .   source  Here are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into those rings.  R = ResidueRing(ZZ, 17)\nS, x = PolynomialRing(QQ,  x )\nT = ResidueRing(S, x^2 + 1)\n\na = R(11)\nb = T(x)\nc = T(ZZ(3))", 
            "title": "Residue ring constructors"
        }, 
        {
            "location": "/residue/#residue-element-constructors", 
            "text": "Once a residue ring is constructed, there are various ways to construct residues in that ring.  Apart from coercing elements into the residue ring as above, we offer the following functions.  #  Base.zero     Method .  zero(R::ResRing)   Return the zero element of the given residue ring, i.e.  0 \\pmod{a}  where  a  is the modulus of the residue ring.   source  #  Base.one     Method .  zero(R::ResRing)   Return  1 \\pmod{a}  where  a  is the modulus of the residue ring.   source  Here are some examples of constructing residues.  R = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)", 
            "title": "Residue element constructors"
        }, 
        {
            "location": "/residue/#basic-functionality", 
            "text": "All residue ring modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own residue ring module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom residue ring types in Nemo.   We write  U  for the type of residue elements in the residue ring and  T  for the type of elements of the base ring.  All of these functions are provided for all existing residue types in Nemo.  parent_type{U  : ResElem}(::Type{U})  Given the type of residue elements, should return the type of the corresponding parent object.  elem_type(R::ResRing)  Given a parent object for the residue ring, return the type of elements of the residue ring.  Base.hash(a::ResElem, h::UInt)  Return a  UInt  hexadecimal hash of the residue  a . This should be xor'd with a fixed random hexadecimal specific to the residue type. The hash of the data associated with a residue should be xor'd with the supplied parameter  h  as part of computing the hash.  data(a::ResElem)  Return the data of the given residue element, i.e. for  c \\pmod{a}  in the ring  R/(a)  return the value  c  as an element of the ring  R .  deepcopy(a::ResElem)  Construct a copy of the given residue and return it. This function must recursively construct copies of all of the internal data in the given residue. Nemo residues are mutable and so returning shallow copies is not sufficient.  mul!(c::ResElem, a::ResElem, b::ResElem)  Multiply  a  by  b  and set the existing residue  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::ResElem, a::ResElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a residue ring, the following coercion functions are provided to coerce various elements into the residue ring. Developers provide these by overloading the  call  operator for the residue ring parent objects.  S()  Coerce zero into the ring  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the residue ring  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(f::ResElem)  Take a residue that is already in the ring  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the residue ring. This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom residues must ensure the parent object of a residue type constains a field  base_ring  specifying the base ring, a field  modulus  containing the modulus  a  of the residue ring  R/(a) . They must also ensure that each residue element contains a field  parent  specifying the parent object of the residue.  Typically a developer will also overload the  ResidueRing  generic function to create residues of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/residue/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate residues. Also see the section on basic functionality above.  base_ring(::ResRing)  #  Nemo.base_ring     Method .  base_ring(r::ResElem)   Return the base ring  R  of the residue ring  R/(a)  that the supplied element  r  belongs to.   source  #  Base.parent     Method .  parent(a::ResElem)   Return the parent object of the given residue element.   source  #  Nemo.modulus     Method .  modulus(R::ResRing)   Return the modulus  a  of the given residue ring  S = R/(a) .   source  #  Nemo.modulus     Method .  modulus(R::ResRing)   Return the modulus  a  of the residue ring  S = R/(a)  that the supplied residue  r  belongs to.   source  #  Nemo.iszero     Method .  iszero(a::ResElem)   Return  true  if the supplied element  a  is zero in the residue ring it belongs to, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::ResElem)   Return  true  if the supplied element  a  is one in the residue ring it belongs to, otherwise return  false .   source  #  Nemo.isunit     Method .  iszero(a::ResElem)   Return  true  if the supplied element  a  is invertible in the residue ring it belongs to, otherwise return  false .   source  Here are some examples of basic manipulation of residues.  R = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)\n\na = modulus(R)\nb = modulus(T(x + 1))\nc = isunit(h)\nd = isone(h)\nf = iszero(g)\nU = parent(g)\nV = base_ring(R)\nW = base_ring(T(x + 1))", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/residue/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo residues. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  The following operators and functions are provided.     Function  Operation      -(a::ResElem)  unary minus    +{T  : RingElem}(a::ResElem{T}, b::ResElem{T})  addition    -{T  : RingElem}(a::ResElem{T}, b::ResElem{T})  subtraction    *{T  : RingElem}(a::ResElem{T}, b::ResElem{T})  multiplication    divexact{T  : RingElem}(a::ResElem{T}, b::ResElem{T})  exact division     The following ad hoc operators are also provided.     Function  Operation      +(a::Integer, b::ResElem)  addition    +(a::ResElem, b::Integer)  addition    +(a::fmpz, b::ResElem)  addition    +(a::ResElem, b::fmpz)  addition    +{T  : RingElem}(a::T, b::ResElem{T})  addition    +{T  : RingElem}(a::ResElem{T}, b::T)  addition    -(a::Integer, b::ResElem)  subtraction    -(a::ResElem, b::Integer)  subtraction    -(a::fmpz, b::ResElem)  subtraction    -(a::ResElem, b::fmpz)  subtraction    -{T  : RingElem}(a::T, b::ResElem{T})  subtraction    -{T  : RingElem}(a::ResElem{T}, b::T)  subtraction    *(a::Integer, b::ResElem)  multiplication    *(a::ResElem, b::Integer)  multiplication    *(a::fmpz, b::ResElem)  multiplication    *(a::ResElem, b::fmpz)  multiplication    *{T  : RingElem}(a::T, b::ResElem{T})  multiplication    *{T  : RingElem}(a::ResElem{T}, b::T)  multiplication    ^(a::ResElem, n::Int)  powering     If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on residues.  R = ResidueRing(ZZ, 16453889)\n\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\nf = R(4)\ng = R(6)\nn = T(x^5 + 1)\np = T(x^2 + 2x + 1)\n\na = -R(12345)\nb = -T(x^5 + 1)\nc = f + g\nd = f - g\nh = f*g\nk = n + p\nl = n - p\nm = n*p\nq = divexact(a*b, a)\nr = divexact(n*p, p)\ns = f + 3\nt = 3 - g\nu = 5g\nv = n + 4\nw = 4 - p\ny = n*5\nz = p^12", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/residue/#comparison-operators", 
            "text": "The following comparison operators are implemented for residues in Nemo. Julia provides the corresponding  !=  operator automatically.", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/residue/#function", 
            "text": "isequal{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   =={T  : RingElem}(a::ResElem{T}, b::ResElem{T})  The  isequal  operation returns  true  if and only if residues are precisely equal as compared by  isequal . This is a stronger form of equality, used for comparing inexact ring elements, such as elements of a power series ring, the  p -adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal.   In addition we have the following ad hoc comparison operators.", 
            "title": "Function"
        }, 
        {
            "location": "/residue/#function_1", 
            "text": "=={T  : RingElem}(a::ResElem{T}, b::T)   =={T  : RingElem}(a::T, b::ResElem{T})   ==(a::ResElem, b::Integer)   ==(a::Integer, b::ResElem)   ==(a::ResElem, b::fmpz)   ==(a::fmpz, b::ResElem)  Here are some examples of comparisons.  R = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(3)\nb = a\nc = R(2)\nf = T(x^5 + 1)\ng = 8f\nh = f + g\n\nb == a\nc != a\nf == g\nh != g\nisequal(f, g)\na == 3\n4 != a\nf != 5", 
            "title": "Function"
        }, 
        {
            "location": "/residue/#inversion", 
            "text": "#  Base.inv     Method .  inv(a::ResElem)   Return the inverse of the element  a  in the residue ring. If an impossible inverse is encountered, an exception is raised.   source  Here are some examples of computing inverses.  R = ResidueRing(ZZ, 49)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(5)\nf = T(x^5 + 1)\n\nb = inv(a)\ng = inv(f)", 
            "title": "Inversion"
        }, 
        {
            "location": "/residue/#greatest-common-divisor", 
            "text": "#  Base.gcd     Method .  gcd{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return a greatest common divisor of  a  and  b  if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.   source  Here are some examples of computing a greatest common divisor.  R = ResidueRing(ZZ, 43)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 - 2x + 1)\n\na = R(5)\nb = R(7)\nc = T(x^5 + 1)\nd = T(x^2 + x)\n\nf = gcd(a, b)\ng = gcd(c, d)", 
            "title": "Greatest common divisor"
        }, 
        {
            "location": "/fraction/", 
            "text": "Introduction\n\n\nNemo allows the creation of fraction fields over any ring \nR\n. We don't require \nR\n to be an integral domain, however no attempt is made to deal with the general case. Two fractions \na/b\n and \nc/d\n are equal in Nemo iff \nad = bc\n. Thus, in practice, a greatest common divisor function is currently required for the ring \nR\n.\n\n\nIn order to make the representation \na/b\n unique for printing, we have a notion of canonical unit for elements of a ring \nR\n. When canonicalising \na/b\n, each of the elements \na\n and \nb\n is first divided by the canonical unit of \nb\n.\n\n\nThe \ncanonical_unit\n function is defined for elements of every Nemo ring. It must have the properties\n\n\ncanonical_unit(u) == u\ncanonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)\n\n\n\n\nfor any unit \nu\n of the ring in question, and \na\n and \nb\n arbitrary elements of the ring.\n\n\nFor example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.\n\n\nThe canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.\n\n\nThere are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists, and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the fraction types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenFrac{T}\n\n\nGenFracField{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpq\n\n\nFlintRationalField\n\n\n\n\n\n\n\n\nAll fraction element types belong to the abstract type \nFracElem\n and all of the fraction field types belong to the abstract type \nFracField\n. This enables one to write generic functions that can accept any Nemo fraction type.\n\n\n\n\nFraction field constructors\n\n\nIn order to construct fractions in Nemo, one must first construct the fraction field itself. This can be accomplished manually with the following constructor.\n\n\nFractionField(::Ring, ::Bool)\n\n\n\n\nNote: it is also possible to construct fractions directly in Nemo without manually constructing the fraction field. In such cases, Nemo creates the relevant fraction field internally.\n\n\nFor convenience, the rational fraction field is constructed automatically in Nemo. We have the definition\n\n\nQQ = FractionField(ZZ)\n\n\n\n\nHere are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into those fields.\n\n\nR = FractionField(ZZ)\nS, x = PolynomialRing(ZZ, \nx\n)\nT = FractionField(S)\n\na = R(1)\nb = T(fmpz(3))\nc = T(x)\nd = QQ(11)\n\n\n\n\n\n\nFraction constructors\n\n\nOnce a fraction field is constructed, there are various ways to construct fractions in that field.\n\n\nApart from coercing elements into the fraction field as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::FracField)\n\n\n\n\n\n\nReturn \n0/1\n in the given fraction field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::FracField)\n\n\n\n\n\n\nReturn \n1/1\n in the given fraction field.\n\n\n\n\nsource\n\n\nIt is also possible to construct fractions directly in Nemo, without first manually constructing the relevant fraction field. For this purpose we overload Julia's fraction operator \n//\n.\n\n\nHere are some examples of constructing fractions.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\nT = FractionField(S)\n\na = zero(T)\nb = one(T)\nc = (x + 3)//(x^2 + 2)\n\n\n\n\n\n\nBasic functionality\n\n\nAll fraction field modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own fraction field module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom fraction field types in Nemo. \n\n\nWe write \nU\n for the type of fraction elements in the fraction field and \nT\n for the type of elements of the base ring.\n\n\nAll of these functions are provided for all existing fraction types in Nemo.\n\n\nparent_type{U \n: FracElem}(::Type{U})\n\n\n\n\nGiven the type of fraction elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::FracField)\n\n\n\n\nGiven a parent object for the fraction field, return the type of elements of the fraction field.\n\n\nBase.hash(a::FracElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the fraction \na\n. This should be xor'd with a fixed random hexadecimal specific to the fraction type. The hash of the numerator and denominator of a fraction should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\nnum(a::FracElem)\n\n\n\n\nReturn the numerator of the given fraction element, i.e. for \na = b/c\n return \nb\n. The returned numerator will be divided by the canonical unit of the denominator.\n\n\nden(a::FracElem)\n\n\n\n\nReturn the denominator of the given fraction element, i.e. for \na = b/c\n return \nc\n. The returned denominator will be divided by the canonical unit of the denominator.\n\n\ndeepcopy(a::FracElem)\n\n\n\n\nConstruct a copy of the given fraction and return it. This function must recursively construct copies of all of the internal data in the given fraction. Nemo fractions are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::FracElem, a::FracElem, b::FracElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing fraction \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::FracElem, a::FracElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a fraction field, the following coercion functions are provided to coerce various elements into the fraction field.  Developers provide these by overloading the \ncall\n operator for the fraction field parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the field \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the fraction field \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(f::FracElem)\n\n\n\n\nTake a fraction that is already in the field \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the fraction field. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nThere are also the followin constructors for creatinf fracions from a numerator and denominator.\n\n\nS(n::T, d::T)\nS(n::Integer, d::T)\nS(n::T, d::Integer)\n\n\n\n\nCreate the fraction \nn/d\n in the fraction field \nS\n.\n\n\nIn addition to the above, developers of custom fractions must ensure the parent object of a fraction type constains a field \nbase_ring\n specifying the base ring. They must also ensure that each fraction element contains a field \nparent\n specifying the parent object of the fraction.\n\n\nTypically a developer will also overload the \nFractionField\n generic function to create fractions of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate fractions. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring{T}(S::FracField{T})\n\n\n\n\n\n\nReturn the base ring \nR\n of the given fraction field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring{T}(r::FracElem)\n\n\n\n\n\n\nReturn the base ring \nR\n of the fraction field that the supplied element \na\n belongs to.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::FracElem)\n\n\n\n\n\n\nReturn the parent object of the given fraction element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is zero in the fraction field it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is one in the fraction field it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is invertible in the fraction field it belongs to, i.e. the numerator is nonzero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nSome functions are only available for certain rings.\n\n\n#\n\n\nBase.abs\n \n \nMethod\n.\n\n\nabs(a::fmpq)\n\n\n\n\n\n\nReturn the absolute value of \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.height\n \n \nMethod\n.\n\n\nheight(a::fmpq)\n\n\n\n\n\n\nReturn the height of the fraction \na\n, namely the largest of the absolute values of the numerator and denominator.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.height_bits\n \n \nMethod\n.\n\n\nheight_bits(a::fmpq)\n\n\n\n\n\n\nReturn the number of bits of the height of the fraction \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.:\n \n \nMethod\n.\n\n\n(a::fmpq, b::Int)\n\n\n\n\n\n\nReturn \n2^b\\times a\n.\n\n\n\n\nsource\n\n\n\n\nBase.:\n \n \nMethod\n.\n\n\n(a::fmpq, b::Int)\n\n\n\n\n\n\nReturn \n2^b/a\n.\n\n\n\n\nsource\n\n\nRational fractions can be compared with each other and with integers. Julia provides the full range of operators \n<, >, \\leq, \\geq\n which depend on the following functions.\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpq, b::fmpq)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::Integer, b::fmpq)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpq, b::Integer)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpq, b::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpz, b::fmpq)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of fractions.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\nf = zero(S)\ng = one(S)\n\na = isunit((x + 1)//(-x^2 + 1))\nb = iszero(f)\nc = isone(g)\nd = abs(ZZ(11)//3)\nU = base_ring(S)\nV = base_ring((x + 1)//(-x^2 + 1))\nW = parent(S(x))\n4 \n= ZZ(7)//ZZ(3)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo fractions. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\nThe following operators and functions are provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::FracElem)\n\n\nunary minus\n\n\n\n\n\n\n+{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\naddition\n\n\n\n\n\n\n-{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n*{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\nmultiplication\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\nexact division\n\n\n\n\n\n\n\n\nThe following ad hoc operators are also provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::Integer, b::FracElem)\n\n\naddition\n\n\n\n\n\n\n+(a::FracElem, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::FracElem)\n\n\naddition\n\n\n\n\n\n\n+(a::FracElem, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::T, b::FracElem{T})\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\naddition\n\n\n\n\n\n\n-(a::Integer, b::FracElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::FracElem, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::FracElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::FracElem, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::T, b::FracElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::Integer, b::FracElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::FracElem, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::FracElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::FracElem, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::T, b::FracElem{T})\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::Integer, b::FracElem)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::FracElem, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::fmpz, b::FracElem)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::FracElem, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::T, b::FracElem{T})\n\n\nexact division\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\nexact division\n\n\n\n\n\n\n^(a::FracElem, n::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on fractions.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = -((x + 1)//(-x^2 + 1))\nb = -(x + 3)//(x + 1) + (2x + 3)//(x^2 + 4)\nc = (x + 1)//(-x^2 + 1) - x//(2x + 1)\nd = ((x^2 + 3x)//(5x))*((x + 1)//(2x^2 + 2))\nf = a + 2\ng = 3 - a\nh = b*(x + 1)\nk = divexact(a, b)\nm = divexact(a, x + 1)\nn = divexact(b, 23)\np = divexact(ZZ(2), b)\nq = a^3\n\n\n\n\n\n\nRemove and valuation\n\n\nIn case the base ring supports the functions \nremove\n and \nvaluation\n, the same is true for fractions.\n\n\nremove{T \n: RingElem}(::T, ::T)\nvaluation{T \n: RingElem}(::T, ::T)\n\n\n\n\nHere is an example:\n\n\na = QQ(2, 3)\nb = ZZ(3)\nremove(a, b)\nvaluation(a, b)\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for fractions in Nemo. Julia provides the corresponding \n!=\n operator automatically.\n\n\n\n\nFunction\n\n\nisequal{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n \n=={T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\nThe \nisequal\n operation returns \ntrue\n if and only if numerator and denominator of the fraction are precisely equal as compared by \nisequal\n. This is a stronger form of equality, used for comparing inexact ring elements, such as elements of a power series ring, the \np\n-adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal. \n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n\n\nFunction\n\n\n=={T \n: RingElem}(a::FracElem{T}, b::T)\n \n=={T \n: RingElem}(a::T, b::FracElem{T})\n \n==(a::FracElem, b::Integer)\n \n==(a::Integer, b::FracElem)\n \n==(a::FracElem, b::fmpz)\n \n==(a::fmpz, b::FracElem)\n\n\nHere are some examples of comparisons.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = -(ZZ(4)//ZZ(6))\nb = -((x + 1)//(-x^2 + 1))\n\na == -ZZ(2)//ZZ(3)\nb == 1//(x - 1)\na == 4\nZZ(2) == b\nb == x + 1\n\n\n\n\n\n\nInversion\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(a::FracElem)\n\n\n\n\n\n\nReturn the inverse of the fraction \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing inverses.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = (x + 1)//(-x^2 + 1)\n\nb = inv(a)\n\n\n\n\n\n\nGreatest common divisor\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn a greatest common divisor of \na\n and \nb\n if one exists. N.B: we define the GCD of \na/b\n and \nc/d\n to be gcd\n(ad, bc)/bd\n, reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.\n\n\n\n\nsource\n\n\nHere are some examples of computing a greatest common divisor.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = -x//(2x + 1)\n\nf = gcd(a, (x + 1)//(x - 1))\n\n\n\n\n\n\nModular arithmetic\n\n\nThe following functions are available for rationals.\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod(a::fmpq, b::fmpz)\n\n\n\n\n\n\nReturn \na \\pmod{b}\n where \nb\n is an integer coprime to the denominator of \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod(a::fmpq, b::Integer)\n\n\n\n\n\n\nReturn \na \\pmod{b}\n where \nb\n is an integer coprime to the denominator of \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of modular arithmetic.\n\n\na = -fmpz(2)//3\nb = fmpz(1)//2\n\nc = mod(a, 7)\nd = mod(b, fmpz(5))\n\n\n\n\n\n\nRational Reconstruction\n\n\nRational reconstruction is available for rational numbers.\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::fmpz, b::fmpz)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::fmpz, b::Integer)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::Integer, b::fmpz)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::Integer, b::Integer)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\nHere are some examples of rational reconstruction.\n\n\na = reconstruct(7, 13)\nb = reconstruct(fmpz(15), 31)\nc = reconstruct(fmpz(123), fmpz(237))\n\n\n\n\n\n\nRational enumeration\n\n\nVarious methods exist to enumerator rationals.\n\n\n#\n\n\nNemo.next_minimal\n \n \nMethod\n.\n\n\nnext_minimal(a::fmpq)\n\n\n\n\n\n\nGiven \nx\n, returns the next rational number in the sequence obtained by enumerating all positive denominators \nq\n, and for each \nq\n enumerating the numerators \n1 \\le p < q\n in order and generating both \np/q\n and \nq/p\n, but skipping all gcd\n(p,q) \\neq 1\n. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being \n0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, \\ldots\n. This enumeration produces the rational numbers in order of minimal height.  It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If \nx < 0\n we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.next_signed_minimal\n \n \nMethod\n.\n\n\nnext_signed_minimal(a::fmpq)\n\n\n\n\n\n\nGiven a signed rational number \nx\n assumed to be in canonical form,  returns the next element in the minimal-height sequence generated by  \nnext_minimal\n but with negative numbers interleaved. The sequence begins \n0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots\n. Starting with zero, this generates every rational number once and only once, in order of minimal height.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.next_calkin_wilf\n \n \nMethod\n.\n\n\nnext_calkin_wilf(a::fmpq)\n\n\n\n\n\n\nGiven \nx\n return the next number in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being \n0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \\ldots\n. Despite the appearance of the initial entries, the Calkin-Wilf enumeration  does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.next_signed_calkin_wilf\n \n \nMethod\n.\n\n\nnext_signed_calkin_wilf(a::fmpq)\n\n\n\n\n\n\nGiven a signed rational number \nx\n returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins \n0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots\n. Starting with zero, this generates every rational number once and only once, but not in order of minimal height.\n\n\n\n\nsource\n\n\nHere are some examples of rational enumeration.\n\n\nnext_minimal(fmpz(2)//3)\nnext_signed_minimal(-fmpz(21)//31)\nnext_calkin_wilf(fmpz(321)//113)\nnext_signed_calkin_wilf(-fmpz(51)//(17))\n\n\n\n\n\n\nSpecial functions\n\n\nThe following special functions are available for specific rings in Nemo.\n\n\n#\n\n\nNemo.harmonic\n \n \nMethod\n.\n\n\nharmonic(n::Int)\n\n\n\n\n\n\nComputes the harmonic number \nH_n = 1 + 1/2 + 1/3 + \\cdots + 1/n\n. Table lookup is used for \nH_n\n whose numerator and denominator  fit in a single limb. For larger \nn\n, a divide and conquer strategy is used.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bernoulli\n \n \nMethod\n.\n\n\nbernoulli(n::Int)\n\n\n\n\n\n\nComputes the Bernoulli number \nB_n\n for nonnegative \nn\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bernoulli_cache\n \n \nMethod\n.\n\n\nbernoulli_cache(n::Int)\n\n\n\n\n\n\nPrecomputes and caches all the Bernoulli numbers up to \nB_n\n. This is much faster than repeatedly calling \nbernoulli(k)\n. Once cached, subsequent calls to \nbernoulli(k)\n for any \nk \\le n\n will read from the cache, making them virtually free.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::fmpz, k::fmpz)\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::fmpz, k::Integer)\n\n\n\n\n\n\nComputes the Dedekind sum \ns(h,k)\n for arbitrary \nh\n and \nk\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::Integer, k::fmpz)\n\n\n\n\n\n\nComputes the Dedekind sum \ns(h,k)\n for arbitrary \nh\n and \nk\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::Integer, k::Integer)\n\n\n\n\n\n\nComputes the Dedekind sum \ns(h,k)\n for arbitrary \nh\n and \nk\n.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\na = harmonic(12)\n\nb = dedekind_sum(12, 13)\nc = dedekind_sum(-120, fmpz(1305))\n\nd = bernoulli(12)\n\nbernoulli_cache(100)\ne = bernoulli(100)", 
            "title": "Fraction fields"
        }, 
        {
            "location": "/fraction/#introduction", 
            "text": "Nemo allows the creation of fraction fields over any ring  R . We don't require  R  to be an integral domain, however no attempt is made to deal with the general case. Two fractions  a/b  and  c/d  are equal in Nemo iff  ad = bc . Thus, in practice, a greatest common divisor function is currently required for the ring  R .  In order to make the representation  a/b  unique for printing, we have a notion of canonical unit for elements of a ring  R . When canonicalising  a/b , each of the elements  a  and  b  is first divided by the canonical unit of  b .  The  canonical_unit  function is defined for elements of every Nemo ring. It must have the properties  canonical_unit(u) == u\ncanonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)  for any unit  u  of the ring in question, and  a  and  b  arbitrary elements of the ring.  For example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.  The canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.  There are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists, and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.  The following table shows each of the fraction types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenFrac{T}  GenFracField{T}     \\mathbb{Z}   Flint  fmpq  FlintRationalField     All fraction element types belong to the abstract type  FracElem  and all of the fraction field types belong to the abstract type  FracField . This enables one to write generic functions that can accept any Nemo fraction type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/fraction/#fraction-field-constructors", 
            "text": "In order to construct fractions in Nemo, one must first construct the fraction field itself. This can be accomplished manually with the following constructor.  FractionField(::Ring, ::Bool)  Note: it is also possible to construct fractions directly in Nemo without manually constructing the fraction field. In such cases, Nemo creates the relevant fraction field internally.  For convenience, the rational fraction field is constructed automatically in Nemo. We have the definition  QQ = FractionField(ZZ)  Here are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into those fields.  R = FractionField(ZZ)\nS, x = PolynomialRing(ZZ,  x )\nT = FractionField(S)\n\na = R(1)\nb = T(fmpz(3))\nc = T(x)\nd = QQ(11)", 
            "title": "Fraction field constructors"
        }, 
        {
            "location": "/fraction/#fraction-constructors", 
            "text": "Once a fraction field is constructed, there are various ways to construct fractions in that field.  Apart from coercing elements into the fraction field as above, we offer the following functions.  #  Base.zero     Method .  zero(R::FracField)   Return  0/1  in the given fraction field.   source  #  Base.one     Method .  one(R::FracField)   Return  1/1  in the given fraction field.   source  It is also possible to construct fractions directly in Nemo, without first manually constructing the relevant fraction field. For this purpose we overload Julia's fraction operator  // .  Here are some examples of constructing fractions.  S, x = PolynomialRing(ZZ,  x )\nT = FractionField(S)\n\na = zero(T)\nb = one(T)\nc = (x + 3)//(x^2 + 2)", 
            "title": "Fraction constructors"
        }, 
        {
            "location": "/fraction/#basic-functionality", 
            "text": "All fraction field modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own fraction field module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom fraction field types in Nemo.   We write  U  for the type of fraction elements in the fraction field and  T  for the type of elements of the base ring.  All of these functions are provided for all existing fraction types in Nemo.  parent_type{U  : FracElem}(::Type{U})  Given the type of fraction elements, should return the type of the corresponding parent object.  elem_type(R::FracField)  Given a parent object for the fraction field, return the type of elements of the fraction field.  Base.hash(a::FracElem, h::UInt)  Return a  UInt  hexadecimal hash of the fraction  a . This should be xor'd with a fixed random hexadecimal specific to the fraction type. The hash of the numerator and denominator of a fraction should be xor'd with the supplied parameter  h  as part of computing the hash.  num(a::FracElem)  Return the numerator of the given fraction element, i.e. for  a = b/c  return  b . The returned numerator will be divided by the canonical unit of the denominator.  den(a::FracElem)  Return the denominator of the given fraction element, i.e. for  a = b/c  return  c . The returned denominator will be divided by the canonical unit of the denominator.  deepcopy(a::FracElem)  Construct a copy of the given fraction and return it. This function must recursively construct copies of all of the internal data in the given fraction. Nemo fractions are mutable and so returning shallow copies is not sufficient.  mul!(c::FracElem, a::FracElem, b::FracElem)  Multiply  a  by  b  and set the existing fraction  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::FracElem, a::FracElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a fraction field, the following coercion functions are provided to coerce various elements into the fraction field.  Developers provide these by overloading the  call  operator for the fraction field parent objects.  S()  Coerce zero into the field  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the fraction field  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(f::FracElem)  Take a fraction that is already in the field  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the fraction field. This only succeeds if  c  can be coerced into the base ring.  There are also the followin constructors for creatinf fracions from a numerator and denominator.  S(n::T, d::T)\nS(n::Integer, d::T)\nS(n::T, d::Integer)  Create the fraction  n/d  in the fraction field  S .  In addition to the above, developers of custom fractions must ensure the parent object of a fraction type constains a field  base_ring  specifying the base ring. They must also ensure that each fraction element contains a field  parent  specifying the parent object of the fraction.  Typically a developer will also overload the  FractionField  generic function to create fractions of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/fraction/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate fractions. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring{T}(S::FracField{T})   Return the base ring  R  of the given fraction field.   source  #  Nemo.base_ring     Method .  base_ring{T}(r::FracElem)   Return the base ring  R  of the fraction field that the supplied element  a  belongs to.   source  #  Base.parent     Method .  parent(a::FracElem)   Return the parent object of the given fraction element.   source  #  Nemo.iszero     Method .  iszero(a::FracElem)   Return  true  if the supplied element  a  is zero in the fraction field it belongs to, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::FracElem)   Return  true  if the supplied element  a  is one in the fraction field it belongs to, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::FracElem)   Return  true  if the supplied element  a  is invertible in the fraction field it belongs to, i.e. the numerator is nonzero, otherwise return  false .   source  Some functions are only available for certain rings.  #  Base.abs     Method .  abs(a::fmpq)   Return the absolute value of  a .   source  #  Nemo.height     Method .  height(a::fmpq)   Return the height of the fraction  a , namely the largest of the absolute values of the numerator and denominator.   source  #  Nemo.height_bits     Method .  height_bits(a::fmpq)   Return the number of bits of the height of the fraction  a .   source  #  Base.:     Method .  (a::fmpq, b::Int)   Return  2^b\\times a .   source   Base.:     Method .  (a::fmpq, b::Int)   Return  2^b/a .   source  Rational fractions can be compared with each other and with integers. Julia provides the full range of operators  <, >, \\leq, \\geq  which depend on the following functions.  #  Base.isless     Method .  isless(a::fmpq, b::fmpq)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::Integer, b::fmpq)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::fmpq, b::Integer)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::fmpq, b::fmpz)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::fmpz, b::fmpq)   Return  true  if  a < b , otherwise return  false .   source  Here are some examples of basic manipulation of fractions.  S, x = PolynomialRing(ZZ,  x )\n\nf = zero(S)\ng = one(S)\n\na = isunit((x + 1)//(-x^2 + 1))\nb = iszero(f)\nc = isone(g)\nd = abs(ZZ(11)//3)\nU = base_ring(S)\nV = base_ring((x + 1)//(-x^2 + 1))\nW = parent(S(x))\n4  = ZZ(7)//ZZ(3)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/fraction/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo fractions. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  The following operators and functions are provided.     Function  Operation      -(a::FracElem)  unary minus    +{T  : RingElem}(a::FracElem{T}, b::FracElem{T})  addition    -{T  : RingElem}(a::FracElem{T}, b::FracElem{T})  subtraction    *{T  : RingElem}(a::FracElem{T}, b::FracElem{T})  multiplication    divexact{T  : RingElem}(a::FracElem{T}, b::FracElem{T})  exact division     The following ad hoc operators are also provided.     Function  Operation      +(a::Integer, b::FracElem)  addition    +(a::FracElem, b::Integer)  addition    +(a::fmpz, b::FracElem)  addition    +(a::FracElem, b::fmpz)  addition    +{T  : RingElem}(a::T, b::FracElem{T})  addition    +{T  : RingElem}(a::FracElem{T}, b::T)  addition    -(a::Integer, b::FracElem)  subtraction    -(a::FracElem, b::Integer)  subtraction    -(a::fmpz, b::FracElem)  subtraction    -(a::FracElem, b::fmpz)  subtraction    -{T  : RingElem}(a::T, b::FracElem{T})  subtraction    -{T  : RingElem}(a::FracElem{T}, b::T)  subtraction    *(a::Integer, b::FracElem)  multiplication    *(a::FracElem, b::Integer)  multiplication    *(a::fmpz, b::FracElem)  multiplication    *(a::FracElem, b::fmpz)  multiplication    *{T  : RingElem}(a::T, b::FracElem{T})  multiplication    *{T  : RingElem}(a::FracElem{T}, b::T)  multiplication    divexact(a::Integer, b::FracElem)  exact division    divexact(a::FracElem, b::Integer)  exact division    divexact(a::fmpz, b::FracElem)  exact division    divexact(a::FracElem, b::fmpz)  exact division    divexact{T  : RingElem}(a::T, b::FracElem{T})  exact division    divexact{T  : RingElem}(a::FracElem{T}, b::T)  exact division    ^(a::FracElem, n::Int)  powering     If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on fractions.  S, x = PolynomialRing(ZZ,  x )\n\na = -((x + 1)//(-x^2 + 1))\nb = -(x + 3)//(x + 1) + (2x + 3)//(x^2 + 4)\nc = (x + 1)//(-x^2 + 1) - x//(2x + 1)\nd = ((x^2 + 3x)//(5x))*((x + 1)//(2x^2 + 2))\nf = a + 2\ng = 3 - a\nh = b*(x + 1)\nk = divexact(a, b)\nm = divexact(a, x + 1)\nn = divexact(b, 23)\np = divexact(ZZ(2), b)\nq = a^3", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/fraction/#remove-and-valuation", 
            "text": "In case the base ring supports the functions  remove  and  valuation , the same is true for fractions.  remove{T  : RingElem}(::T, ::T)\nvaluation{T  : RingElem}(::T, ::T)  Here is an example:  a = QQ(2, 3)\nb = ZZ(3)\nremove(a, b)\nvaluation(a, b)", 
            "title": "Remove and valuation"
        }, 
        {
            "location": "/fraction/#comparison-operators", 
            "text": "The following comparison operators are implemented for fractions in Nemo. Julia provides the corresponding  !=  operator automatically.", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/fraction/#function", 
            "text": "isequal{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   =={T  : RingElem}(a::FracElem{T}, b::FracElem{T})  The  isequal  operation returns  true  if and only if numerator and denominator of the fraction are precisely equal as compared by  isequal . This is a stronger form of equality, used for comparing inexact ring elements, such as elements of a power series ring, the  p -adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal.   In addition we have the following ad hoc comparison operators.", 
            "title": "Function"
        }, 
        {
            "location": "/fraction/#function_1", 
            "text": "=={T  : RingElem}(a::FracElem{T}, b::T)   =={T  : RingElem}(a::T, b::FracElem{T})   ==(a::FracElem, b::Integer)   ==(a::Integer, b::FracElem)   ==(a::FracElem, b::fmpz)   ==(a::fmpz, b::FracElem)  Here are some examples of comparisons.  S, x = PolynomialRing(ZZ,  x )\n\na = -(ZZ(4)//ZZ(6))\nb = -((x + 1)//(-x^2 + 1))\n\na == -ZZ(2)//ZZ(3)\nb == 1//(x - 1)\na == 4\nZZ(2) == b\nb == x + 1", 
            "title": "Function"
        }, 
        {
            "location": "/fraction/#inversion", 
            "text": "#  Base.inv     Method .  inv(a::FracElem)   Return the inverse of the fraction  a .   source  Here are some examples of computing inverses.  S, x = PolynomialRing(ZZ,  x )\n\na = (x + 1)//(-x^2 + 1)\n\nb = inv(a)", 
            "title": "Inversion"
        }, 
        {
            "location": "/fraction/#greatest-common-divisor", 
            "text": "#  Base.gcd     Method .  gcd{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return a greatest common divisor of  a  and  b  if one exists. N.B: we define the GCD of  a/b  and  c/d  to be gcd (ad, bc)/bd , reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.   source  Here are some examples of computing a greatest common divisor.  S, x = PolynomialRing(ZZ,  x )\n\na = -x//(2x + 1)\n\nf = gcd(a, (x + 1)//(x - 1))", 
            "title": "Greatest common divisor"
        }, 
        {
            "location": "/fraction/#modular-arithmetic", 
            "text": "The following functions are available for rationals.  #  Base.mod     Method .  mod(a::fmpq, b::fmpz)   Return  a \\pmod{b}  where  b  is an integer coprime to the denominator of  a .   source  #  Base.mod     Method .  mod(a::fmpq, b::Integer)   Return  a \\pmod{b}  where  b  is an integer coprime to the denominator of  a .   source  Here are some examples of modular arithmetic.  a = -fmpz(2)//3\nb = fmpz(1)//2\n\nc = mod(a, 7)\nd = mod(b, fmpz(5))", 
            "title": "Modular arithmetic"
        }, 
        {
            "location": "/fraction/#rational-reconstruction", 
            "text": "Rational reconstruction is available for rational numbers.  #  Nemo.reconstruct     Method .  reconstruct(a::fmpz, b::fmpz)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  #  Nemo.reconstruct     Method .  reconstruct(a::fmpz, b::Integer)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  #  Nemo.reconstruct     Method .  reconstruct(a::Integer, b::fmpz)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  #  Nemo.reconstruct     Method .  reconstruct(a::Integer, b::Integer)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  Here are some examples of rational reconstruction.  a = reconstruct(7, 13)\nb = reconstruct(fmpz(15), 31)\nc = reconstruct(fmpz(123), fmpz(237))", 
            "title": "Rational Reconstruction"
        }, 
        {
            "location": "/fraction/#rational-enumeration", 
            "text": "Various methods exist to enumerator rationals.  #  Nemo.next_minimal     Method .  next_minimal(a::fmpq)   Given  x , returns the next rational number in the sequence obtained by enumerating all positive denominators  q , and for each  q  enumerating the numerators  1 \\le p < q  in order and generating both  p/q  and  q/p , but skipping all gcd (p,q) \\neq 1 . Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being  0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, \\ldots . This enumeration produces the rational numbers in order of minimal height.  It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If  x < 0  we throw a  DomainError() .   source  #  Nemo.next_signed_minimal     Method .  next_signed_minimal(a::fmpq)   Given a signed rational number  x  assumed to be in canonical form,  returns the next element in the minimal-height sequence generated by   next_minimal  but with negative numbers interleaved. The sequence begins  0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots . Starting with zero, this generates every rational number once and only once, in order of minimal height.   source  #  Nemo.next_calkin_wilf     Method .  next_calkin_wilf(a::fmpq)   Given  x  return the next number in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being  0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \\ldots . Despite the appearance of the initial entries, the Calkin-Wilf enumeration  does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.   source  #  Nemo.next_signed_calkin_wilf     Method .  next_signed_calkin_wilf(a::fmpq)   Given a signed rational number  x  returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins  0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots . Starting with zero, this generates every rational number once and only once, but not in order of minimal height.   source  Here are some examples of rational enumeration.  next_minimal(fmpz(2)//3)\nnext_signed_minimal(-fmpz(21)//31)\nnext_calkin_wilf(fmpz(321)//113)\nnext_signed_calkin_wilf(-fmpz(51)//(17))", 
            "title": "Rational enumeration"
        }, 
        {
            "location": "/fraction/#special-functions", 
            "text": "The following special functions are available for specific rings in Nemo.  #  Nemo.harmonic     Method .  harmonic(n::Int)   Computes the harmonic number  H_n = 1 + 1/2 + 1/3 + \\cdots + 1/n . Table lookup is used for  H_n  whose numerator and denominator  fit in a single limb. For larger  n , a divide and conquer strategy is used.   source  #  Nemo.bernoulli     Method .  bernoulli(n::Int)   Computes the Bernoulli number  B_n  for nonnegative  n .   source  #  Nemo.bernoulli_cache     Method .  bernoulli_cache(n::Int)   Precomputes and caches all the Bernoulli numbers up to  B_n . This is much faster than repeatedly calling  bernoulli(k) . Once cached, subsequent calls to  bernoulli(k)  for any  k \\le n  will read from the cache, making them virtually free.   source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::fmpz, k::fmpz)  source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::fmpz, k::Integer)   Computes the Dedekind sum  s(h,k)  for arbitrary  h  and  k .   source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::Integer, k::fmpz)   Computes the Dedekind sum  s(h,k)  for arbitrary  h  and  k .   source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::Integer, k::Integer)   Computes the Dedekind sum  s(h,k)  for arbitrary  h  and  k .   source  Here are some examples of special functions.  a = harmonic(12)\n\nb = dedekind_sum(12, 13)\nc = dedekind_sum(-120, fmpz(1305))\n\nd = bernoulli(12)\n\nbernoulli_cache(100)\ne = bernoulli(100)", 
            "title": "Special functions"
        }, 
        {
            "location": "/matrix/", 
            "text": "Introduction\n\n\nNemo allow the creation of dense matricses over any computable ring \nR\n. There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of matrices over numerous specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the matrix types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of matrix (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenMat{T}\n\n\nGenMatSpace{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_mat\n\n\nFmpzMatSpace\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n (small \nn\n)\n\n\nFlint\n\n\nnmod_mat\n\n\nNmodMatSpace\n\n\n\n\n\n\n\n\n\\mathbb{Q}\n\n\n\n\nFlint\n\n\nfmpq_mat\n\n\nFmpqMatSpace\n\n\n\n\n\n\n\n\n\\mathbb{R}\n\n\n\n\nArb\n\n\narb_mat\n\n\nArbMatSpace\n\n\n\n\n\n\n\n\n\\mathbb{C}\n\n\n\n\nArb\n\n\nacb_mat\n\n\nAcbMatSpace\n\n\n\n\n\n\n\n\nThe dimensions and base ring \nR\n of a generic matrix are stored in its parent object. \n\n\nAll matrix element types belong to the abstract type \nMatElem\n and all of the matrix space types belong to the abstract type \nMatSpace\n. This enables one to write generic functions that can accept any Nemo matrix type.\n\n\n\n\nMatrix space constructors\n\n\nIn Nemo we have the concept of a matrix space. This is the collection of matrices with specified dimensions and base ring.\n\n\nIn order to construct matrices in Nemo, one usually first constructs the matrix space itself. This is accomplished with the following constructor.\n\n\nMatrixSpace(::Ring, ::Int, ::Int, ::Bool)\n\n\n\n\nWe also allow matrices over a given base ring to be constructed directly. In such cases, Nemo automatically constructs the matrix space internally. See the matrix element constructors below for examples. However, note that there may be a small peformance disadvantage to doing it that way, since the matrix space needs to be looked up internally every time a matrix is constructed.\n\n\nHere are some examples of creating matrix spaces and making use of the resulting parent objects to coerce various elements into the matrix space.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S()\nB = S(12)\nC = S(R(11))\n\n\n\n\n\n\nMatrix element constructors\n\n\nOnce a matrix space is constructed, there are various ways to construct matrices in that space.\n\n\nIn addition to coercing elements into the matrix space as above, we provide the following functions for constructing certain useful matrices.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(a::MatSpace)\n\n\n\n\n\n\nConstruct the zero matrix in the given matrix space.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(a::MatSpace)\n\n\n\n\n\n\nConstruct the matrix in the given matrix space with ones down the diagonal and zeroes elsewhere.\n\n\n\n\nsource\n\n\nIn addition, there are various shorthand notations for constructing matrices over a given base ring without first constructing the matrix space parent object.\n\n\nR[a b c...;...]\n\n\n\n\nCreate the matrix over the base ring \nR\n consisting of the given rows (separated by semicolons). Each entry is coerced into \nR\n  automatically. Note that parentheses may be placed around individual entries if the lists would otherwise be ambiguous, e.g. \nR[1 2; 2 (-3)]\n.\n\n\nBeware that this syntax does not support the creation of column vectors. See the notation below for creating those.\n\n\nR[a b c...]\n\n\n\n\nCreate the row vector with entries in \nR\n consisting of the given entries (separated by spaces). Each entry is coerced into \nR\n automatically. Note that parentheses may be placed around individual entries if the list would otherwise be ambiguous, e.g. \nR[1 2 (-3)]\n.\n\n\nR[a b c...]'\n\n\n\n\nCreate the column vector with entries in \nR\n consisting of the given entries (separated by spaces). Each entry is coerced into \nR\n automatically. Observe the dash that is used to transpose the row vector notation (for free) to turn it into a column vector. Note that parentheses may be placed around individual entries if the list would otherwise be ambiguous, e.g. \nR[1 2 (-3)]'\n.\n\n\nHere are some examples of constructing matrices.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = zero(S)\nB = one(S)\n\nC = R[t + 1 1; t^2 0]\nD = R[t + 1 2 t]\nF = R[1 2 t]'\n\n\n\n\n\n\nBasic functionality\n\n\nAll matric modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own matrix module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom matrix types in Nemo. \n\n\nWe write \nU\n for the type of the matrices in the matrix space and \nT\n for the type of elements of the base ring.\n\n\nAll of these functions are provided for all existing matrix types in Nemo.\n\n\nparent_type{U \n: MatElem}(::Type{U})\n\n\n\n\nGiven the type of matrix elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::MatSpace)\n\n\n\n\nGiven a parent object for the matrix space, return the type of elements of the matrix space.\n\n\nBase.hash(a::MatElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the matrix \na\n. This should be xor'd with a fixed random hexadecimal specific to the matrix type. The hash of each entry should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndeepcopy(a::MatElem)\n\n\n\n\nConstruct a copy of the given matrix and return it. This function must recursively construct copies of all of the internal data in the given matrix. Nemo matricess are mutable and so returning shallow copies is not sufficient.\n\n\nTo access entries of a Nemo matrix, we overload the square bracket notation.\n\n\nM[r::Int, c::Int]\n\n\n\n\nOne can both assign to and access a given entry at row \nr\n and column \nc\n of a matrix \nM\n with this notation. Note that Julia and Nemo matrices are \n1\n-indexed, i.e. the first row has index \n1\n, not \n0\n, etc. This is in accordance with many papers on matrices and with systems such as Pari/GP.\n\n\nGiven a parent object \nS\n for a matrix space, the following coercion functions are provided to coerce various elements into the matrix space. Developers provide these by overloading the \ncall\n operator for the matrix parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the space \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nReturn the diagonal matrix with the given integer along the diagonal and zeroes elsewhere.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(A::Array{T, 2})\n\n\n\n\nTake a Julia two dimensional array of elements in the base ring, of type \nT\n and construct the matrix with those entries.\n\n\nS(f::MatElem)\n\n\n\n\nTake a matrix that is already in the space \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the matrix space (as a diagonal matrix). This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom matrices must ensure the parent object of a matrix type constains a field \nbase_ring\n specifying the base ring, and fields \nrows\n and \ncols\n to specify the dimensions. They must also ensure that each matrix element contains a field \nparent\n specifying the parent object of the matrix, or that there is at least a function \nparent(a::MatElem)\n which returns the parent of the given matrix.\n\n\nTypically a developer will also overload the \nMatrixSpace\n generic function to create matrices of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate matricess and to set and retrieve entries and other basic data associated with the matrices. Also see the section on basic functionality above.\n\n\nbase_ring(::MatSpace)\n\n\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(r::MatElem)\n\n\n\n\n\n\nReturn the base ring \nR\n of the matrix space that the supplied matrix \nr\n belongs to.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::MatElem)\n\n\n\n\n\n\nReturn the parent object of the given matrix.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.rows\n \n \nMethod\n.\n\n\nrows(a::MatElem)\n\n\n\n\n\n\nReturn the number of rows of the given matrix.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.cols\n \n \nMethod\n.\n\n\ncols(a::MatElem)\n\n\n\n\n\n\nReturn the number of columns of the given matrix.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::MatElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied matrix \na\n is the zero matrix, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::MatElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied matrix \na\n is diagonal with ones along the diagonal, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of matrices.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nC = zero(S)\nD = one(S)\n\nf = iszero(C)\ng = isone(D)\nr = rows(B)\nc = cols(B)\nU = base_ring(C)\nV = base_ring(S)\nW = parent(D)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo matrices. Note that Julia uses the single slash for floating point division. Therefore to perform exact division by a constant we use \ndivexact\n. \n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::MatElem)\n\n\nunary minus\n\n\n\n\n\n\n+{T \n: RingElem}(a::MatElem{T}, b::MatElem{T})\n\n\naddition\n\n\n\n\n\n\n-{T \n: RingElem}(a::MatElem{T}, b::MatElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n*{T \n: RingElem}(a::MatElem{T}, b::MatElem{T})\n\n\nmultiplication\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::MatElem{T}, b::MatElem{T})\n\n\nexact division\n\n\n\n\n\n\n\n\nAn exception is raised if the matrix dimensions are not compatible for the given operation. The \ndivexact\n function computes \na*inv(b)\n where \ninv(b)\n is the inverse of the matrix \nb\n. This assumes that \nb\n can be inverted.\n\n\nThe following ad hoc operators are also provided.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::Integer, b::MatElem)\n\n\naddition\n\n\n\n\n\n\n+(a::MatElem, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::MatElem)\n\n\naddition\n\n\n\n\n\n\n+(a::MatElem, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::T, b::MatElem{T})\n\n\naddition\n\n\n\n\n\n\n+{T \n: RingElem}(a::MatElem{T}, b::T)\n\n\naddition\n\n\n\n\n\n\n-(a::Integer, b::MatElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::MatElem, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::MatElem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::MatElem, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::T, b::MatElem{T})\n\n\nsubtraction\n\n\n\n\n\n\n-{T \n: RingElem}(a::MatElem{T}, b::T)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::Integer, b::MatElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::MatElem, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::MatElem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::MatElem, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::T, b::MatElem{T})\n\n\nmultiplication\n\n\n\n\n\n\n*{T \n: RingElem}(a::MatElem{T}, b::T)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::MatElem, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::MatElem, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\ndivexact{T \n: RingElem}(a::MatElem{T}, b::T)\n\n\nexact division\n\n\n\n\n\n\n^(a::MatElem, n::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nThe following function is also provided.\n\n\n#\n\n\nNemo.powers\n \n \nMethod\n.\n\n\npowers{T \n: RingElem}(a::MatElem{T}, d::Int)\n\n\n\n\n\n\nReturn an array of matrices \nM\n wher \nM[i + 1] = a^i\n for \ni = 0..d\n\n\n\n\n\n\nsource\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on matrices.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nC = -A\nD = A + B\nF = A - B\nG = A*B\nH = 3*A\nK = B + 2\nM = fmpz(3) - B\nN = t - A\nP = A^3\nQ = powers(A, 3)\nR = divexact(A*3, 3)\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for matrices in Nemo.\n\n\n\n\nFunction\n\n\nisequal{T \n: RingElem}(a::MatElem{T}, b::MatElem{T})\n \n=={T \n: RingElem}(a::MatElem{T}, b::MatElem{T})\n\n\nThe \nisequal\n operation returns \ntrue\n if and only if all the entries of the matrix are precisely equal as compared by \nisequal\n. This is a stronger form of equality, used for comparing inexact coefficients, such as elements of a power series ring, the \np\n-adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal. \n\n\n#\n\n\nNemo.overlaps\n \n \nMethod\n.\n\n\noverlaps(x::arb_mat, y::arb_mat)\n\n\n\n\n\n\nReturns \ntrue\n if all entries of \nx\n overlap with the corresponding entry of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.overlaps\n \n \nMethod\n.\n\n\noverlaps(x::acb_mat, y::acb_mat)\n\n\n\n\n\n\nReturns \ntrue\n if all entries of \nx\n overlap with the corresponding entry of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb_mat, y::arb_mat)\n\n\n\n\n\n\nReturns \ntrue\n if all entries of \nx\n contain the corresponding entry of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb_mat, y::acb_mat)\n\n\n\n\n\n\nReturns \ntrue\n if all entries of \nx\n contain the corresponding entry of \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n\n\nFunction\n\n\n=={T \n: RingElem}(a::MatElem{T}, b::T)\n \n=={T \n: RingElem}(a::T, b::MatElem{T})\n \n==(a::MatElem, b::Integer)\n \n==(a::Integer, b::MatElem)\n \n==(a::MatElem, b::fmpz)\n \n==(a::fmpz, b::MatElem)\n\n\nHere are some examples of comparisons.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nA != B\nA == deepcopy(A)\nA != 12\nfmpz(11) != A\nB != t\nS(11) == 11\n\nC = RR[1 2; 3 4]\nD = RR[\n1 +/- 0.1\n \n2 +/- 0.1\n; \n3 +/- 0.1\n \n4 +/- 0.1\n]\noverlaps(C, D)\ncontains(D, C)\n\n\n\n\n\n\nScaling\n\n\n#\n\n\nBase.:\n \n \nMethod\n.\n\n\n(x::fmpz_mat, y::Int)\n\n\n\n\n\n\nReturn \n2^yx\n.\n\n\n\n\nsource\n\n\n\n\nBase.:\n \n \nMethod\n.\n\n\n(x::fmpz_mat, y::Int)\n\n\n\n\n\n\nReturn \nx/2^y\n where rounding is towards zero.\n\n\n\n\nsource\n\n\nHere are some examples of scaling matrices.\n\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nB = A\n5\nC = B\n2\n\n\n\n\n\n\nTranspose\n\n\n#\n\n\nBase.transpose\n \n \nMethod\n.\n\n\ntranspose(x::MatElem)\n\n\n\n\n\n\nReturn the transpose of the given matrix.\n\n\n\n\nsource\n\n\nHere is an example of transposing a matrix.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nB = transpose(A)\n\n\n\n\n\n\nGram matrix\n\n\n#\n\n\nNemo.gram\n \n \nMethod\n.\n\n\ngram(x::MatElem)\n\n\n\n\n\n\nReturn the Gram matrix of \nx\n, i.e. if \nx\n is an \nr\\times c\n matrix return the \nr\\times r\n matrix whose entries \ni, j\n are the dot products of the \ni\n-th and \nj\n-th rows, respectively.\n\n\n\n\nsource\n\n\nHere is an example of computing the Gram matrix.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nB = gram(A)\n\n\n\n\n\n\nTrace\n\n\n#\n\n\nBase.LinAlg.trace\n \n \nMethod\n.\n\n\ntrace(x::MatElem)\n\n\n\n\n\n\nReturn the trace of the matrix \na\n, i.e. the sum of the diagonal elements. We require the matrix to be square.\n\n\n\n\nsource\n\n\nHere is an example of computing the trace.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nb = trace(A)\n\n\n\n\n\n\nContent\n\n\n#\n\n\nNemo.content\n \n \nMethod\n.\n\n\ncontent(x::MatElem)\n\n\n\n\n\n\nReturn the content of the matrix \na\n, i.e. the greatest common divisor of all its entries, assuming it exists.\n\n\n\n\nsource\n\n\nHere is an example of computing the content of a matrix.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nb = content(A)\n\n\n\n\n\n\nConcatenation\n\n\n#\n\n\nBase.hcat\n \n \nMethod\n.\n\n\nhcat(a::MatElem, b::MatElem)\n\n\n\n\n\n\nReturn the horizontal concatenation of \na\n and \nb\n. Assumes that the number of rows is the same in \na\n and \nb\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.vcat\n \n \nMethod\n.\n\n\nvcat(a::MatElem, b::MatElem)\n\n\n\n\n\n\nReturn the vertical concatenation of \na\n and \nb\n. Assumes that the number of columns is the same in \na\n and \nb\n.\n\n\n\n\nsource\n\n\nHere are some examples of concatenation.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nhcat(A, B)\nvcat(A, B)\n\n\n\n\n\n\nPermutation\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(P::perm, x::MatElem)\n\n\n\n\n\n\nApply the pemutation \nP\n to the rows of the matrix \nx\n and return the result.\n\n\n\n\nsource\n\n\nHere is an example of applying a permutation to a matrix.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS = MatrixSpace(R, 3, 3)\nG = PermGroup(3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nP = G([1, 3, 2])\n\nB = P*A\n\n\n\n\n\n\nLU factorisation\n\n\n#\n\n\nBase.LinAlg.lufact\n \n \nMethod\n.\n\n\nlufact{T \n: FieldElem}(A::MatElem{T}, P = PermGroup(rows(A)))\n\n\n\n\n\n\nReturn a tuple \nr, p, L, U\n consisting of the rank of \nA\n, a permutation \np\n of \nA\n belonging to \nP\n, a lower triangular matrix \nL\n and an upper triangular matrix \nU\n such that \np(A) = LU\n, where \np(A)\n stands for the matrix whose rows are the given permutation \np\n of the rows of \nA\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fflu\n \n \nMethod\n.\n\n\nfflu{T \n: RingElem}(A::MatElem{T}, P = PermGroup(rows(A)))\n\n\n\n\n\n\nReturn a tuple \nr, d, p, L, U\n consisting of the rank of \nA\n, a denominator \nd\n, a permutation \np\n of \nA\n belonging to \nP\n, a lower triangular matrix \nL\n and an upper triangular matrix \nU\n such that \np(A) = LD^1U\n, where \np(A)\n stands for the matrix whose rows are the given permutation \np\n of the rows of \nA\n and such that \nD\n is the diagonal matrix diag\n(p_1, p_1p_2, \\ldots, p_{n-2}p_{n-1}, p_{n-1}\n where the \np_i\n are the inverses of the diagonal entries of \nU\n. The denominator \nd\n is set to \n\\pm \\mbox{det}(S)\n where \nS\n is an appropriate submatrix of \nA\n (\nS = A\n if \nA\n is square) and the sign is decided by the parity of the permutation.\n\n\n\n\nsource\n\n\nHere are some examples of LU factorisation.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 - 2 a - 1 2a])\n\nr, P, L, U = lufact(A)\nr, d, P, L, U = fflu(A)\n\n\n\n\n\n\nReduced row-echelon form\n\n\n#\n\n\nNemo.rref\n \n \nMethod\n.\n\n\nrref{T \n: RingElem}(M::MatElem{T})\n\n\n\n\n\n\nReturns a tuple \n(r, d, A)\n consisting of the rank \nr\n of \nM\n and a denominator \nd\n in the base ring of \nM\n and a matrix \nA\n such that \nA/d\n is the reduced row echelon form of \nM\n. Note that the denominator is not usually minimal.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.rref\n \n \nMethod\n.\n\n\nrref{T \n: FieldElem}(M::MatElem{T})\n\n\n\n\n\n\nReturns a tuple \n(r, A)\n consisting of the rank \nr\n of \nM\n and a reduced row echelon form \nA\n of \nM\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isrref\n \n \nMethod\n.\n\n\nisrref{T \n: RingElem}(M::MatElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nM\n is in reduced row echelon form, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isrref\n \n \nMethod\n.\n\n\nisrref{T \n: FieldElem}(M::MatElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nM\n is in reduced row echelon form, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing reduced row echelon form.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\nS = MatrixSpace(K, 3, 3)\n\nM = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nr, d, A = rref(M)\nisrref(A)\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS = MatrixSpace(R, 3, 3)\nU = MatrixSpace(R, 3, 2)\n\nM = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n\nr, A = rref(M)\nisrref(A)\n\n\n\n\n\n\nHermite normal form\n\n\n#\n\n\nNemo.hnf\n \n \nMethod\n.\n\n\nhnf{T \n: RingElem}(A::GenMat{T}) -\n GenMat{T}\n\n\n\n\n\n\nReturn the upper right row Hermite normal form of \nA\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hnf_with_trafo\n \n \nMethod\n.\n\n\nhnf{T \n: RingElem}(A::GenMat{T}) -\n GenMaT{T}, GenMat{T}\n\n\n\n\n\n\nReturn the upper right row Hermite normal form \nH\n of \nA\n together with invertible matrix \nU\n such that \nUA = H\n.\n\n\n\n\nsource\n\n\n\n\nDeterminant\n\n\n#\n\n\nBase.LinAlg.det\n \n \nMethod\n.\n\n\ndet{T \n: RingElem}(M::MatElem{T})\n\n\n\n\n\n\nReturn the determinant of the matrix \nM\n. We assume \nM\n is square.\n\n\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.det\n \n \nMethod\n.\n\n\ndet{T \n: FieldElem}(M::MatElem{T})\n\n\n\n\n\n\nReturn the determinant of the matrix \nM\n. We assume \nM\n is square.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.det_divisor\n \n \nMethod\n.\n\n\ndet_divisor(x::fmpz_mat)\n\n\n\n\n\n\nReturn some positive divisor of the determinant of \nx\n, if the determinant is nonzero, otherwise return zero.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.det_given_divisor\n \n \nMethod\n.\n\n\ndet_given_divisor(x::fmpz_mat, d::Integer, proved=true)\n\n\n\n\n\n\nReturn the determinant of \nx\n given a positive divisor of its determinant. If \nproved == true\n (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.det_given_divisor\n \n \nMethod\n.\n\n\ndet_given_divisor(x::fmpz_mat, d::fmpz, proved=true)\n\n\n\n\n\n\nReturn the determinant of \nx\n given a positive divisor of its determinant. If \nproved == true\n (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.\n\n\n\n\nsource\n\n\nHere are some examples of computing the determinant.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nd = det(A)\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nc = det_divisor(A)\nd = det_given_divisor(A, c)\n\n\n\n\n\n\nRank\n\n\n#\n\n\nBase.LinAlg.rank\n \n \nMethod\n.\n\n\nrank{T \n: RingElem}(M::MatElem{T})\n\n\n\n\n\n\nReturn the rank of the matrix \nM\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.rank\n \n \nMethod\n.\n\n\nrank{T \n: FieldElem}(M::MatElem{T})\n\n\n\n\n\n\nReturn the rank of the matrix \nM\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing the rank of a matrix.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nd = rank(A)\n\n\n\n\n\n\nLinear solving\n\n\nsolve{T \n: RingElem}(::MatElem{T}, ::MatElem{T})\n\n\n\n\n#\n\n\nNemo.cansolve\n \n \nMethod\n.\n\n\ncansolve(a::fmpz_mat, b::fmpz_mat) -\n Bool, fmpz_mat\n\n\n\n\n\n\nReturn true and a matrix \nx\n such that \nax = b\n, or false and some matrix in case \nx\n does not exist.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.solve_rational\n \n \nMethod\n.\n\n\nsolve_rational{T \n: RingElem}(M::MatElem{T}, b::MatElem{T})\n\n\n\n\n\n\nGiven a non-singular \nn\\times n\n matrix over a ring and an \nn\\times m\n matrix over the same ring, return a tuple \nx, d\n consisting of an \nn\\times m\n matrix \nx\n and a denominator \nd\n such that \nAx = db\n. The denominator will be the determinant of \nA\n up to sign. If \nA\n is singular an exception is raised.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.solve_triu\n \n \nMethod\n.\n\n\nsolve_triu{T \n: FieldElem}(U::MatElem{T}, b::MatElem{T}, unit=false)\n\n\n\n\n\n\nGiven a non-singular \nn\\times n\n matrix over a field which is upper triangular, and an \nn\\times m\n matrix over the same field, return an \nn\\times m\n matrix \nx\n such that \nAx = b\n. If \nA\n is singular an exception is raised. If unit is true then \nU\n is assumed to have ones on its diagonal, and the diagonal will not be read.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.solve_dixon\n \n \nMethod\n.\n\n\nsolve_dixon(a::fmpz_mat, b::fmpz_mat)\n\n\n\n\n\n\nReturn a tuple \n(x, m)\n consisting of a column vector \nx\n such that \nax = b \\pmod{m}\n. The element  \nb\n must be a column vector with the same number \n of rows as \na\n and \na\n must be a square matrix. If these conditions are not met or \n(x, d)\n does not exist, an exception is raised.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.solve_dixon\n \n \nMethod\n.\n\n\nsolve_dixon(a::fmpq_mat, b::fmpq_mat)\n\n\n\n\n\n\nSolve \nax = b\n by clearing denominators and using Dixon's algorithm. This is usually faster for large systems.\n\n\n\n\nsource\n\n\nHere are some examples of linear solving.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\nS = MatrixSpace(K, 3, 3)\nU = MatrixSpace(K, 3, 1)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\nb = U([2a a + 1 (-a - 1)]')\n\nx = solve(A, b)\n\nA = S([a + 1 2a + 3 a^2 + 1; K(0) a^2 - 1 2a; K(0) K(0) a])\nb = U([2a a + 1 (-a - 1)]')\n\nx = solve_triu(A, b, false)\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS = MatrixSpace(R, 3, 3)\nU = MatrixSpace(R, 3, 2)\n\nA = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\nb = U([2x x + 1 (-x - 1); x + 1 (-x) x^2]')\n\nx, d = solve_rational(A, b)\n\nS = MatrixSpace(ZZ, 3, 3)\nT = MatrixSpace(ZZ, 3, 1)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])   \nB = T([fmpz(4), 5, 7])\n\nX, d = solve_rational(A, B)\nX, m = solve_dixon(A, B)\n\n\n\n\n\n\nInverse\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv{T \n: RingElem}(M::MatElem{T})\n\n\n\n\n\n\nGiven a non-singular \nn\\times n\n matrix over a ring the tuple \nX, d\n consisting of an \nn\\times n\n matrix \nX\n and a denominator \nd\n such that \nAX = dI_n\n, where \nI_n\n is the \nn\\times n\n identity matrix. The denominator will be the determinant of \nA\n up to sign. If \nA\n is singular an exception  is raised.\n\n\n\n\nsource\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv{T \n: FieldElem}(M::MatElem{T})\n\n\n\n\n\n\nGiven a non-singular \nn\\times n\n matrix over a field, return an \nn\\times n\n matrix \nX\n such that \nAX = I_n\n where \nI_n\n is the \nn\\times n\n identity matrix. If \nA\n is singular an exception is raised.\n\n\n\n\nsource\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(M::arb_mat)\n\n\n\n\n\n\nGiven a  \nn\\times n\n matrix of type \narb_mat\n, return an \nn\\times n\n matrix \nX\n such that \nAX\n contains the  identity matrix. If \nA\n cannot be inverted numerically an exception is raised.\n\n\n\n\nsource\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(M::acb_mat)\n\n\n\n\n\n\nGiven a \nn\\times n\n matrix of type \nacb_mat\n, return an \nn\\times n\n matrix \nX\n such that \nAX\n contains the  identity matrix. If \nA\n cannot be inverted numerically an exception is raised.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.pseudo_inv\n \n \nMethod\n.\n\n\npseudo_inv(x::fmpz_mat)\n\n\n\n\n\n\nReturn a tuple \n(z, d)\n consisting of a matrix \nz\n and denominator \nd\n such that \nz/d\n is the inverse of \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of taking the inverse of a matrix.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nX = inv(A)\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS = MatrixSpace(R, 3, 3)\n\nA = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n\nX, d = inv(A)\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([1 0 1; 2 3 1; 5 6 7])\n\nB, d = pseudo_inv(A)\n\nA = RR[1 0 1; 2 3 1; 5 6 7]\n\nX = inv(A)\n\n\n\n\n\n\nNullspace\n\n\n#\n\n\nBase.LinAlg.nullspace\n \n \nMethod\n.\n\n\nnullspace{T \n: RingElem}(M::MatElem{T})\n\n\n\n\n\n\nReturns a tuple \n(\\nu, N)\n consisting of the nullity \n\\nu\n of \nM\n and a basis \nN\n (consisting of column vectors) for the right nullspace of \nM\n, i.e. such that \nMN\n is the zero matrix. If \nM\n is an \nm\\times n\n matrix \nN\n will be an \nn\\times \\nu\n matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In Nemo we use the name ``kernel'' for a function to compute an integral kernel.\n\n\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.nullspace\n \n \nMethod\n.\n\n\nnullspace{T \n: FieldElem}(M::MatElem{T})\n\n\n\n\n\n\nReturns a tuple \n(\\nu, N)\n consisting of the nullity \n\\nu\n of \nM\n and a basis \nN\n (consisting of column vectors) for the right nullspace of \nM\n, i.e. such that \nMN\n is the zero matrix. If \nM\n is an \nm\\times n\n matrix \nN\n will be an \nn\\times \\nu\n matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In Nemo we use the name ``kernel'' for a function to compute an integral kernel.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.nullspace_right_rational\n \n \nMethod\n.\n\n\nnullspace_right_rational(x::fmpz_mat)\n\n\n\n\n\n\nReturn the right rational nullspace of \nx\n, i.e. a set of vectors over \n\\mathbb{Z}\n giving a \n\\mathbb{Q}\n-basis for the nullspace of \nx\n considered as a matrix over \n\\mathbb{Q}\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing the nullspace of a matrix.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS = MatrixSpace(R, 4, 4)\n\nM = S([-6*x^2+6*x+12 -12*x^2-21*x-15 -15*x^2+21*x+33 -21*x^2-9*x-9;\n       -8*x^2+8*x+16 -16*x^2+38*x-20 90*x^2-82*x-44 60*x^2+54*x-34;\n       -4*x^2+4*x+8 -8*x^2+13*x-10 35*x^2-31*x-14 22*x^2+21*x-15;\n       -10*x^2+10*x+20 -20*x^2+70*x-25 150*x^2-140*x-85 105*x^2+90*x-50])\n\nn, N = nullspace(M)\n\n\n\n\n\n\nHessenberg form\n\n\n#\n\n\nNemo.hessenberg\n \n \nMethod\n.\n\n\nhessenberg{T \n: RingElem}(A::MatElem{T})\n\n\n\n\n\n\nReturns the Hessenberg form of \nM\n, i.e. an upper Hessenberg matrix which is similar to \nM\n. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ishessenberg\n \n \nMethod\n.\n\n\nishessenberg{T \n: RingElem}(A::MatElem{T})\n\n\n\n\n\n\nReturns \ntrue\n if \nM\n is in Hessenberg form, otherwise returns \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing the Hessenberg form.\n\n\nR = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 4, 4)\n\nM = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n       R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n\nA = hessenberg(M)\nishessenberg(A) == true\n\n\n\n\n\n\nCharacteristic polynomial\n\n\n#\n\n\nNemo.charpoly\n \n \nMethod\n.\n\n\ncharpoly{T \n: RingElem}(V::Ring, Y::MatElem{T})\n\n\n\n\n\n\nReturns the characteristic polynomial \np\n of the matrix \nM\n. The polynomial ring \nR\n of the resulting polynomial must be supplied and the matrix is assumed to be square.\n\n\n\n\nsource\n\n\nHere are some examples of computing the characteristic polynomial.\n\n\nR = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 4, 4)\nT, x = PolynomialRing(R, \nx\n)\n\nM = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n       R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n\nA = charpoly(T, M)\n\n\n\n\n\n\nMinimal polynomial\n\n\n#\n\n\nNemo.minpoly\n \n \nMethod\n.\n\n\nminpoly{T \n: RingElem}(S::Ring, M::MatElem{T}, charpoly_only = false)\n\n\n\n\n\n\nReturns the minimal polynomial \np\n of the matrix \nM\n. The polynomial ring \nR\n of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.minpoly\n \n \nMethod\n.\n\n\nminpoly{T \n: FieldElem}(S::Ring, M::MatElem{T}, charpoly_only = false)\n\n\n\n\n\n\nReturns the minimal polynomial \np\n of the matrix \nM\n. The polynomial ring \nR\n of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n\nsource\n\n\nminpoly{T \n: RingElem}(S::Ring, M::MatElem{T}, charpoly_only = false)\n\n\n\n\n\n\nReturns the minimal polynomial \np\n of the matrix \nM\n. The polynomial ring \nR\n of the resulting polynomial must be supplied and the matrix must be square.\n\n\n\n\nsource\n\n\nHere are some examples of computing the minimal polynomial of a matrix.\n\n\nR, x = FiniteField(13, 1, \nx\n)\nT, y = PolynomialRing(R, \ny\n)\n\nM = R[7 6 1;\n      7 7 5;\n      8 12 5]\n\nA = minpoly(T, M)\n\n\n\n\n\n\nTransforms\n\n\n#\n\n\nNemo.similarity!\n \n \nMethod\n.\n\n\nsimilarity!{T \n: RingElem}(A::MatElem{T}, r::Int, d::T)\n\n\n\n\n\n\nApplies a similarity transform to the \nn\\times n\n matrix \nM\n in-place. Let \nP\n be the \nn\\times n\n identity matrix that has had all zero entries of row \nr\n replaced with \nd\n, then the transform applied is equivalent to \nM = P^{-1}MP\n. We require \nM\n to be a square matrix. A similarity transform preserves the minimal and characteristic polynomials of a matrix.\n\n\n\n\nsource\n\n\nHere is an example of applying a similarity transform to a matrix.\n\n\nR = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 4, 4)\n\nM = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n       R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n\nsimilarity!(M, 1, R(3))\n\n\n\n\n\n\nModular reduction\n\n\n#\n\n\nNemo.reduce_mod\n \n \nMethod\n.\n\n\nreduce_mod(x::fmpz_mat, y::Integer)\n\n\n\n\n\n\nReduce the entries of \nx\n modulo \ny\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.reduce_mod\n \n \nMethod\n.\n\n\nreduce_mod(x::fmpz_mat, y::fmpz)\n\n\n\n\n\n\nReduce the entries of \nx\n modulo \ny\n and return the result.\n\n\n\n\nsource\n\n\nHere are some examples of modular reduction.\n\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])\n\nreduce_mod(A, ZZ(5))\nreduce_mod(A, 2)\n\n\n\n\n\n\nLifting\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nlift(a::nmod_mat)\n\n\n\n\n\n\nReturn a lift of the matrix \na\n to a matrix over \n\\mathbb{Z}\n, i.e. where the entries of the returned matrix are those of \na\n lifted to \n\\mathbb{Z}\n.\n\n\n\n\nsource\n\n\nHere are some examples of lifting.\n\n\nR = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 3, 3)\n\na = S([4 5 6; 7 3 2; 1 4 5])\n\n b = lift(a)\n\n\n\n\n\n\nSpecial matrices\n\n\n#\n\n\nNemo.hadamard\n \n \nMethod\n.\n\n\nhadamard(R::FmpzMatSpace)\n\n\n\n\n\n\nReturn the Hadamard matrix for the given matrix space. The number of rows and columns must be equal.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ishadamard\n \n \nMethod\n.\n\n\nishadamard(x::fmpz_mat)\n\n\n\n\n\n\nReturn \ntrue\n if the given matrix is Hadamard, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hilbert\n \n \nMethod\n.\n\n\nhilbert(R::FmpqMatSpace)\n\n\n\n\n\n\nReturn the Hilbert matrix in the given matrix space. This is the matrix with entries \nH_{i,j} = 1/(i + j - 1)\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing special matrices.\n\n\nR = MatrixSpace(ZZ, 3, 3)\nS = MatrixSpace(QQ, 3, 3)\n\nA = hadamard(R)\nishadamard(A)\nB = hilbert(R)\n\n\n\n\n\n\nHermite Normal Form\n\n\n#\n\n\nNemo.hnf\n \n \nMethod\n.\n\n\nhnf(x::fmpz_mat)\n\n\n\n\n\n\nReturn the Hermite Normal Form of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hnf_with_transform\n \n \nMethod\n.\n\n\nhnf_with_transform(x::fmpz_mat)\n\n\n\n\n\n\nCompute a tuple \n(H, T)\n where \nH\n is the Hermite normal form of \nx\n and \nT\n is a transformation matrix so that \nH = Tx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hnf_modular\n \n \nMethod\n.\n\n\nhnf_modular(x::fmpz_mat, d::fmpz)\n\n\n\n\n\n\nCompute the Hermite normal form of \nx\n given that \nd\n is a multiple of the determinant of the nonzero rows of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hnf_modular_eldiv\n \n \nMethod\n.\n\n\nhnf_modular_eldiv(x::fmpz_mat, d::fmpz)\n\n\n\n\n\n\nCompute the Hermite normal form of \nx\n given that \nd\n is a multiple of the largest elementary divisor of \nx\n. The matrix \nx\n must have full rank.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ishnf\n \n \nMethod\n.\n\n\nishnf(x::fmpz_mat)\n\n\n\n\n\n\nReturn \ntrue\n if the given matrix is in Hermite Normal Form, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing the Hermite Normal Form.\n\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = hnf(A)\nH, T = hnf_with_transform(A)\nM = hnf_modular(A, fmpz(27))\nN = hnf_modular_eldiv(A, fmpz(27))\nishnf(M)\n\n\n\n\n\n\n(Weak) Popov form\n\n\nNemo provdes algorithms for computing the (weak) Popov of a matrix with entries in a univariate polynomial ring over a field.\n\n\nweak_popov{T \n: PolyElem}(::GenMat{T})\nweak_popov_with_trafo{T \n: PolyElem}(::GenMat{T})\npopov{T \n: PolyElem}(::GenMat{T})\npopov_with_trafo{T \n: PolyElem}(::GenMat{T})\ndet_popov{T \n: PolyElem}(::GenMat{T})\n\n\n\n\n\n\nLattice basis reduction\n\n\nNemo provides LLL lattice basis reduction. Optionally one can specify the setup using a context object created by the following function.\n\n\nlll_ctx(delta::Float64, eta::Float64, rep=:zbasis, gram=:approx)\n\n\n\n\nReturn a LLL context object specifying LLL parameters \n\\delta\n and \n\\eta\n and specifying the representation as either \n:zbasis\n or \n:gram\n and the Gram type as either \n:approx\n or \n:exact\n.\n\n\n#\n\n\nNemo.lll\n \n \nMethod\n.\n\n\nlll(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51))\n\n\n\n\n\n\nReturn the LLL reduction of the matrix \nx\n. By default the matrix \nx\n is a \n\\mathbb{Z}\n-basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters \n\\delta = 0.99\n and \n\\eta = 0.51\n. All of these defaults can be overridden by specifying an optional context object.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lll_with_transform\n \n \nMethod\n.\n\n\n\n\nCompute a tuple \n(L, T)\n where \nL\n is the LLL reduction of \na\n and \nT\n is a transformation matrix so that \nL = Ta\n. All the default parameters can be overridden by supplying an optional context object.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lll_gram\n \n \nMethod\n.\n\n\nlll_gram(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51, :gram))\n\n\n\n\n\n\nGiven the Gram matrix \nx\n of a matrix, compute the Gram matrix of its LLL reduction.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lll_gram_with_transform\n \n \nMethod\n.\n\n\nlll_gram_with_transform(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51, :gram))\n\n\n\n\n\n\nGiven the Gram matrix \nx\n of a matrix \nM\n, compute a tuple \n(L, T)\n where \nL\n is the gram matrix of the LLL reduction of the matrix and \nT\n is a transformation matrix so that \nL = TM\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lll_with_removal\n \n \nMethod\n.\n\n\nlll_with_removal(x::fmpz_mat, b::fmpz, ctx=lll_ctx(0.99, 0.51))\n\n\n\n\n\n\nCompute the LLL reduction of \nx\n and throw away rows whose norm exceeds the given bound \nb\n. Return a tuple \n(r, L)\n where the first \nr\n rows of \nL\n are the rows remaining after removal.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lll_with_removal_transform\n \n \nMethod\n.\n\n\nlll_with_removal_transform(x::fmpz_mat, b::fmpz, ctx=lll_ctx(0.99, 0.51))\n\n\n\n\n\n\nCompute a tuple \n(r, L, T)\n where the first \nr\n rows of \nL\n are those remaining from the LLL reduction after removal of vectors with norm exceeding the bound \nb\n and \nT\n is a transformation matrix so that \nL = Tx\n.\n\n\n\n\nsource\n\n\nHere are some examples of lattice basis reduction.\n\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nL = lll(A, lll_ctx(0.95, 0.55, :zbasis, :approx)\nL, T = lll_with_transform(A)\n\nG == lll_gram(gram(A))\nG, T = lll_gram_with_transform(gram(A))\n\nr, L = lll_with_removal(A, fmpz(100))\nr, L, T = lll_with_removal_transform(A, fmpz(100))\n\n\n\n\n\n\nSmith Normal Form\n\n\n#\n\n\nNemo.snf\n \n \nMethod\n.\n\n\nsnf(x::fmpz_mat)\n\n\n\n\n\n\nCompute the Smith normal form of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.snf_diagonal\n \n \nMethod\n.\n\n\nsnf_diagonal(x::fmpz_mat)\n\n\n\n\n\n\nGiven a diagonal matrix \nx\n compute the Smith normal form of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issnf\n \n \nMethod\n.\n\n\nissnf(x::fmpz_mat)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is in Smith normal form, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing the Smith Normal Form.\n\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = snf(A)\nissnf(B) == true\n\nB = S([fmpz(2) 0 0; 0 4 0; 0 0 7])\n\nC = snf_diagonal(B)\n\n\n\n\n\n\nStrong Echelon Form\n\n\n#\n\n\nNemo.strong_echelon_form\n \n \nMethod\n.\n\n\nstrong_echelon_form(a::nmod_mat)\n\n\n\n\n\n\nReturn the strong echeleon form of \na\n. The matrix \na\n must have at least as many rows as columns.\n\n\n\n\nsource\n\n\nHere is an example of computing the strong echelon form.\n\n\nR = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = strong_echelon_form(A)\n\n\n\n\n\n\nHowell Form\n\n\n#\n\n\nNemo.howell_form\n \n \nMethod\n.\n\n\nhowell_form(a::nmod_mat)\n\n\n\n\n\n\nReturn the Howell normal form of \na\n. The matrix \na\n must have at least as many rows as columns.\n\n\n\n\nsource\n\n\nHere is an example of computing the Howell form.\n\n\nR = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = howell_form(A)\n\n\n\n\n\n\nGram-Schmidt Orthogonalisation\n\n\n#\n\n\nNemo.gso\n \n \nMethod\n.\n\n\ngso(x::fmpq_mat)\n\n\n\n\n\n\nReturn the Gram-Schmidt Orthogonalisation of the matrix \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing the Gram-Schmidt Orthogonalisation.\n\n\nS = MatrixSpace(QQ, 3, 3)\n\nA = S([4 7 3; 2 9 1; 0 5 3])\n\nB = gso(A)\n\n\n\n\n\n\nExponential\n\n\n#\n\n\nBase.exp\n \n \nMethod\n.\n\n\nexp(x::arb_mat)\n\n\n\n\n\n\nReturns the exponential of the matrix \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.exp\n \n \nMethod\n.\n\n\nexp(x::acb_mat)\n\n\n\n\n\n\nReturns the exponential of the matrix \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing the exponential function of matrix.\n\n\nA = RR[2 0 0; 0 3 0; 0 0 1]\n\nB = exp(A)\n\n\n\n\n\n\nNorm\n\n\n#\n\n\nNemo.bound_inf_norm\n \n \nMethod\n.\n\n\nbound_inf_norm(x::arb_mat)\n\n\n\n\n\n\nReturns a nonnegative element \nz\n of type \narb\n, such that \nz\n is an upper bound for the infinity norm for every matrix in \nx\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bound_inf_norm\n \n \nMethod\n.\n\n\nbound_inf_norm(x::acb_mat)\n\n\n\n\n\n\nReturns a nonnegative element \nz\n of type \nacb\n, such that \nz\n is an upper bound for the infinity norm for every matrix in \nx\n\n\n\n\n\n\nsource\n\n\nHere are some examples of computing bounds on the infinity norm of a matrix.\n\n\nA = RR[1 2 3; 4 5 6; 7 8 9]\n\nd = bound_inf_norm(A)\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nBase.Math.ldexp\n \n \nMethod\n.\n\n\nldexp(x::acb_mat, y::Int)\n\n\n\n\n\n\nReturn \n2^yx\n. Note that \ny\n can be positive, zero or negative.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.ldexp\n \n \nMethod\n.\n\n\nldexp(x::acb_mat, y::Int)\n\n\n\n\n\n\nReturn \n2^yx\n. Note that \ny\n can be positive, zero or negative.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\nA = RR[1 2 3; 4 5 6; 7 8 9]\n\nB = ldexp(A, 4)\n\noverlaps(16*A, B)\n\n\n\n\n\n\nPredicates\n\n\n#\n\n\nBase.isreal\n \n \nMethod\n.\n\n\nisreal(M::acb_mat)\n\n\n\n\n\n\nReturns whether every entry of \nM\n has vanishing imaginary part.\n\n\n\n\nsource\n\n\nHere are some examples for predicates.\n\n\nA = CC[1 2 3; 4 5 6; 7 8 9]\n\nisreal(A)\n\nisreal(onei(CC)*A)", 
            "title": "Matrices"
        }, 
        {
            "location": "/matrix/#introduction", 
            "text": "Nemo allow the creation of dense matricses over any computable ring  R . There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of matrices over numerous specific rings, usually provided by C/C++ libraries.  The following table shows each of the matrix types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of matrix (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenMat{T}  GenMatSpace{T}     \\mathbb{Z}   Flint  fmpz_mat  FmpzMatSpace     \\mathbb{Z}/n\\mathbb{Z}  (small  n )  Flint  nmod_mat  NmodMatSpace     \\mathbb{Q}   Flint  fmpq_mat  FmpqMatSpace     \\mathbb{R}   Arb  arb_mat  ArbMatSpace     \\mathbb{C}   Arb  acb_mat  AcbMatSpace     The dimensions and base ring  R  of a generic matrix are stored in its parent object.   All matrix element types belong to the abstract type  MatElem  and all of the matrix space types belong to the abstract type  MatSpace . This enables one to write generic functions that can accept any Nemo matrix type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/matrix/#matrix-space-constructors", 
            "text": "In Nemo we have the concept of a matrix space. This is the collection of matrices with specified dimensions and base ring.  In order to construct matrices in Nemo, one usually first constructs the matrix space itself. This is accomplished with the following constructor.  MatrixSpace(::Ring, ::Int, ::Int, ::Bool)  We also allow matrices over a given base ring to be constructed directly. In such cases, Nemo automatically constructs the matrix space internally. See the matrix element constructors below for examples. However, note that there may be a small peformance disadvantage to doing it that way, since the matrix space needs to be looked up internally every time a matrix is constructed.  Here are some examples of creating matrix spaces and making use of the resulting parent objects to coerce various elements into the matrix space.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S()\nB = S(12)\nC = S(R(11))", 
            "title": "Matrix space constructors"
        }, 
        {
            "location": "/matrix/#matrix-element-constructors", 
            "text": "Once a matrix space is constructed, there are various ways to construct matrices in that space.  In addition to coercing elements into the matrix space as above, we provide the following functions for constructing certain useful matrices.  #  Base.zero     Method .  zero(a::MatSpace)   Construct the zero matrix in the given matrix space.   source  #  Base.one     Method .  one(a::MatSpace)   Construct the matrix in the given matrix space with ones down the diagonal and zeroes elsewhere.   source  In addition, there are various shorthand notations for constructing matrices over a given base ring without first constructing the matrix space parent object.  R[a b c...;...]  Create the matrix over the base ring  R  consisting of the given rows (separated by semicolons). Each entry is coerced into  R   automatically. Note that parentheses may be placed around individual entries if the lists would otherwise be ambiguous, e.g.  R[1 2; 2 (-3)] .  Beware that this syntax does not support the creation of column vectors. See the notation below for creating those.  R[a b c...]  Create the row vector with entries in  R  consisting of the given entries (separated by spaces). Each entry is coerced into  R  automatically. Note that parentheses may be placed around individual entries if the list would otherwise be ambiguous, e.g.  R[1 2 (-3)] .  R[a b c...]'  Create the column vector with entries in  R  consisting of the given entries (separated by spaces). Each entry is coerced into  R  automatically. Observe the dash that is used to transpose the row vector notation (for free) to turn it into a column vector. Note that parentheses may be placed around individual entries if the list would otherwise be ambiguous, e.g.  R[1 2 (-3)]' .  Here are some examples of constructing matrices.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = zero(S)\nB = one(S)\n\nC = R[t + 1 1; t^2 0]\nD = R[t + 1 2 t]\nF = R[1 2 t]'", 
            "title": "Matrix element constructors"
        }, 
        {
            "location": "/matrix/#basic-functionality", 
            "text": "All matric modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own matrix module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom matrix types in Nemo.   We write  U  for the type of the matrices in the matrix space and  T  for the type of elements of the base ring.  All of these functions are provided for all existing matrix types in Nemo.  parent_type{U  : MatElem}(::Type{U})  Given the type of matrix elements, should return the type of the corresponding parent object.  elem_type(R::MatSpace)  Given a parent object for the matrix space, return the type of elements of the matrix space.  Base.hash(a::MatElem, h::UInt)  Return a  UInt  hexadecimal hash of the matrix  a . This should be xor'd with a fixed random hexadecimal specific to the matrix type. The hash of each entry should be xor'd with the supplied parameter  h  as part of computing the hash.  deepcopy(a::MatElem)  Construct a copy of the given matrix and return it. This function must recursively construct copies of all of the internal data in the given matrix. Nemo matricess are mutable and so returning shallow copies is not sufficient.  To access entries of a Nemo matrix, we overload the square bracket notation.  M[r::Int, c::Int]  One can both assign to and access a given entry at row  r  and column  c  of a matrix  M  with this notation. Note that Julia and Nemo matrices are  1 -indexed, i.e. the first row has index  1 , not  0 , etc. This is in accordance with many papers on matrices and with systems such as Pari/GP.  Given a parent object  S  for a matrix space, the following coercion functions are provided to coerce various elements into the matrix space. Developers provide these by overloading the  call  operator for the matrix parent objects.  S()  Coerce zero into the space  S .  S(n::Integer)\nS(n::fmpz)  Return the diagonal matrix with the given integer along the diagonal and zeroes elsewhere.  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(A::Array{T, 2})  Take a Julia two dimensional array of elements in the base ring, of type  T  and construct the matrix with those entries.  S(f::MatElem)  Take a matrix that is already in the space  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the matrix space (as a diagonal matrix). This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom matrices must ensure the parent object of a matrix type constains a field  base_ring  specifying the base ring, and fields  rows  and  cols  to specify the dimensions. They must also ensure that each matrix element contains a field  parent  specifying the parent object of the matrix, or that there is at least a function  parent(a::MatElem)  which returns the parent of the given matrix.  Typically a developer will also overload the  MatrixSpace  generic function to create matrices of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/matrix/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate matricess and to set and retrieve entries and other basic data associated with the matrices. Also see the section on basic functionality above.  base_ring(::MatSpace)  #  Nemo.base_ring     Method .  base_ring(r::MatElem)   Return the base ring  R  of the matrix space that the supplied matrix  r  belongs to.   source  #  Base.parent     Method .  parent(a::MatElem)   Return the parent object of the given matrix.   source  #  Nemo.rows     Method .  rows(a::MatElem)   Return the number of rows of the given matrix.   source  #  Nemo.cols     Method .  cols(a::MatElem)   Return the number of columns of the given matrix.   source  #  Nemo.iszero     Method .  iszero(a::MatElem)   Return  true  if the supplied matrix  a  is the zero matrix, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::MatElem)   Return  true  if the supplied matrix  a  is diagonal with ones along the diagonal, otherwise return  false .   source  Here are some examples of basic manipulation of matrices.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nC = zero(S)\nD = one(S)\n\nf = iszero(C)\ng = isone(D)\nr = rows(B)\nc = cols(B)\nU = base_ring(C)\nV = base_ring(S)\nW = parent(D)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/matrix/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo matrices. Note that Julia uses the single slash for floating point division. Therefore to perform exact division by a constant we use  divexact .      Function  Operation      -(a::MatElem)  unary minus    +{T  : RingElem}(a::MatElem{T}, b::MatElem{T})  addition    -{T  : RingElem}(a::MatElem{T}, b::MatElem{T})  subtraction    *{T  : RingElem}(a::MatElem{T}, b::MatElem{T})  multiplication    divexact{T  : RingElem}(a::MatElem{T}, b::MatElem{T})  exact division     An exception is raised if the matrix dimensions are not compatible for the given operation. The  divexact  function computes  a*inv(b)  where  inv(b)  is the inverse of the matrix  b . This assumes that  b  can be inverted.  The following ad hoc operators are also provided.     Function  Operation      +(a::Integer, b::MatElem)  addition    +(a::MatElem, b::Integer)  addition    +(a::fmpz, b::MatElem)  addition    +(a::MatElem, b::fmpz)  addition    +{T  : RingElem}(a::T, b::MatElem{T})  addition    +{T  : RingElem}(a::MatElem{T}, b::T)  addition    -(a::Integer, b::MatElem)  subtraction    -(a::MatElem, b::Integer)  subtraction    -(a::fmpz, b::MatElem)  subtraction    -(a::MatElem, b::fmpz)  subtraction    -{T  : RingElem}(a::T, b::MatElem{T})  subtraction    -{T  : RingElem}(a::MatElem{T}, b::T)  subtraction    *(a::Integer, b::MatElem)  multiplication    *(a::MatElem, b::Integer)  multiplication    *(a::fmpz, b::MatElem)  multiplication    *(a::MatElem, b::fmpz)  multiplication    *{T  : RingElem}(a::T, b::MatElem{T})  multiplication    *{T  : RingElem}(a::MatElem{T}, b::T)  multiplication    divexact(a::MatElem, b::Integer)  exact division    divexact(a::MatElem, b::fmpz)  exact division    divexact{T  : RingElem}(a::MatElem{T}, b::T)  exact division    ^(a::MatElem, n::Int)  powering     The following function is also provided.  #  Nemo.powers     Method .  powers{T  : RingElem}(a::MatElem{T}, d::Int)   Return an array of matrices  M  wher  M[i + 1] = a^i  for  i = 0..d    source  If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on matrices.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nC = -A\nD = A + B\nF = A - B\nG = A*B\nH = 3*A\nK = B + 2\nM = fmpz(3) - B\nN = t - A\nP = A^3\nQ = powers(A, 3)\nR = divexact(A*3, 3)", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/matrix/#comparison-operators", 
            "text": "The following comparison operators are implemented for matrices in Nemo.", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/matrix/#function", 
            "text": "isequal{T  : RingElem}(a::MatElem{T}, b::MatElem{T})   =={T  : RingElem}(a::MatElem{T}, b::MatElem{T})  The  isequal  operation returns  true  if and only if all the entries of the matrix are precisely equal as compared by  isequal . This is a stronger form of equality, used for comparing inexact coefficients, such as elements of a power series ring, the  p -adics, or the reals or complex numbers. Two elements are precisely equal only if they have the same precision or bounds in addition to being arithmetically equal.   #  Nemo.overlaps     Method .  overlaps(x::arb_mat, y::arb_mat)   Returns  true  if all entries of  x  overlap with the corresponding entry of  y , otherwise return  false .   source  #  Nemo.overlaps     Method .  overlaps(x::acb_mat, y::acb_mat)   Returns  true  if all entries of  x  overlap with the corresponding entry of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb_mat, y::arb_mat)   Returns  true  if all entries of  x  contain the corresponding entry of  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb_mat, y::acb_mat)   Returns  true  if all entries of  x  contain the corresponding entry of  y , otherwise return  false .   source  In addition we have the following ad hoc comparison operators.", 
            "title": "Function"
        }, 
        {
            "location": "/matrix/#function_1", 
            "text": "=={T  : RingElem}(a::MatElem{T}, b::T)   =={T  : RingElem}(a::T, b::MatElem{T})   ==(a::MatElem, b::Integer)   ==(a::Integer, b::MatElem)   ==(a::MatElem, b::fmpz)   ==(a::fmpz, b::MatElem)  Here are some examples of comparisons.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nA != B\nA == deepcopy(A)\nA != 12\nfmpz(11) != A\nB != t\nS(11) == 11\n\nC = RR[1 2; 3 4]\nD = RR[ 1 +/- 0.1   2 +/- 0.1 ;  3 +/- 0.1   4 +/- 0.1 ]\noverlaps(C, D)\ncontains(D, C)", 
            "title": "Function"
        }, 
        {
            "location": "/matrix/#scaling", 
            "text": "#  Base.:     Method .  (x::fmpz_mat, y::Int)   Return  2^yx .   source   Base.:     Method .  (x::fmpz_mat, y::Int)   Return  x/2^y  where rounding is towards zero.   source  Here are some examples of scaling matrices.  S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nB = A 5\nC = B 2", 
            "title": "Scaling"
        }, 
        {
            "location": "/matrix/#transpose", 
            "text": "#  Base.transpose     Method .  transpose(x::MatElem)   Return the transpose of the given matrix.   source  Here is an example of transposing a matrix.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nB = transpose(A)", 
            "title": "Transpose"
        }, 
        {
            "location": "/matrix/#gram-matrix", 
            "text": "#  Nemo.gram     Method .  gram(x::MatElem)   Return the Gram matrix of  x , i.e. if  x  is an  r\\times c  matrix return the  r\\times r  matrix whose entries  i, j  are the dot products of the  i -th and  j -th rows, respectively.   source  Here is an example of computing the Gram matrix.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nB = gram(A)", 
            "title": "Gram matrix"
        }, 
        {
            "location": "/matrix/#trace", 
            "text": "#  Base.LinAlg.trace     Method .  trace(x::MatElem)   Return the trace of the matrix  a , i.e. the sum of the diagonal elements. We require the matrix to be square.   source  Here is an example of computing the trace.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nb = trace(A)", 
            "title": "Trace"
        }, 
        {
            "location": "/matrix/#content", 
            "text": "#  Nemo.content     Method .  content(x::MatElem)   Return the content of the matrix  a , i.e. the greatest common divisor of all its entries, assuming it exists.   source  Here is an example of computing the content of a matrix.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\n\nb = content(A)", 
            "title": "Content"
        }, 
        {
            "location": "/matrix/#concatenation", 
            "text": "#  Base.hcat     Method .  hcat(a::MatElem, b::MatElem)   Return the horizontal concatenation of  a  and  b . Assumes that the number of rows is the same in  a  and  b .   source  #  Base.vcat     Method .  vcat(a::MatElem, b::MatElem)   Return the vertical concatenation of  a  and  b . Assumes that the number of columns is the same in  a  and  b .   source  Here are some examples of concatenation.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nB = S([R(2) R(3) R(1); t t + 1 t + 2; R(-1) t^2 t^3])\n\nhcat(A, B)\nvcat(A, B)", 
            "title": "Concatenation"
        }, 
        {
            "location": "/matrix/#permutation", 
            "text": "#  Base.:*     Method .  *(P::perm, x::MatElem)   Apply the pemutation  P  to the rows of the matrix  x  and return the result.   source  Here is an example of applying a permutation to a matrix.  R, t = PolynomialRing(QQ,  t )\nS = MatrixSpace(R, 3, 3)\nG = PermGroup(3)\n\nA = S([t + 1 t R(1); t^2 t t; R(-2) t + 2 t^2 + t + 1])\nP = G([1, 3, 2])\n\nB = P*A", 
            "title": "Permutation"
        }, 
        {
            "location": "/matrix/#lu-factorisation", 
            "text": "#  Base.LinAlg.lufact     Method .  lufact{T  : FieldElem}(A::MatElem{T}, P = PermGroup(rows(A)))   Return a tuple  r, p, L, U  consisting of the rank of  A , a permutation  p  of  A  belonging to  P , a lower triangular matrix  L  and an upper triangular matrix  U  such that  p(A) = LU , where  p(A)  stands for the matrix whose rows are the given permutation  p  of the rows of  A .   source  #  Nemo.fflu     Method .  fflu{T  : RingElem}(A::MatElem{T}, P = PermGroup(rows(A)))   Return a tuple  r, d, p, L, U  consisting of the rank of  A , a denominator  d , a permutation  p  of  A  belonging to  P , a lower triangular matrix  L  and an upper triangular matrix  U  such that  p(A) = LD^1U , where  p(A)  stands for the matrix whose rows are the given permutation  p  of the rows of  A  and such that  D  is the diagonal matrix diag (p_1, p_1p_2, \\ldots, p_{n-2}p_{n-1}, p_{n-1}  where the  p_i  are the inverses of the diagonal entries of  U . The denominator  d  is set to  \\pm \\mbox{det}(S)  where  S  is an appropriate submatrix of  A  ( S = A  if  A  is square) and the sign is decided by the parity of the permutation.   source  Here are some examples of LU factorisation.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 - 2 a - 1 2a])\n\nr, P, L, U = lufact(A)\nr, d, P, L, U = fflu(A)", 
            "title": "LU factorisation"
        }, 
        {
            "location": "/matrix/#reduced-row-echelon-form", 
            "text": "#  Nemo.rref     Method .  rref{T  : RingElem}(M::MatElem{T})   Returns a tuple  (r, d, A)  consisting of the rank  r  of  M  and a denominator  d  in the base ring of  M  and a matrix  A  such that  A/d  is the reduced row echelon form of  M . Note that the denominator is not usually minimal.   source  #  Nemo.rref     Method .  rref{T  : FieldElem}(M::MatElem{T})   Returns a tuple  (r, A)  consisting of the rank  r  of  M  and a reduced row echelon form  A  of  M .   source  #  Nemo.isrref     Method .  isrref{T  : RingElem}(M::MatElem{T})   Return  true  if  M  is in reduced row echelon form, otherwise return  false .   source  #  Nemo.isrref     Method .  isrref{T  : FieldElem}(M::MatElem{T})   Return  true  if  M  is in reduced row echelon form, otherwise return  false .   source  Here are some examples of computing reduced row echelon form.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\nS = MatrixSpace(K, 3, 3)\n\nM = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nr, d, A = rref(M)\nisrref(A)\n\nR, x = PolynomialRing(ZZ,  x )\nS = MatrixSpace(R, 3, 3)\nU = MatrixSpace(R, 3, 2)\n\nM = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n\nr, A = rref(M)\nisrref(A)", 
            "title": "Reduced row-echelon form"
        }, 
        {
            "location": "/matrix/#hermite-normal-form", 
            "text": "#  Nemo.hnf     Method .  hnf{T  : RingElem}(A::GenMat{T}) -  GenMat{T}   Return the upper right row Hermite normal form of  A .   source  #  Nemo.hnf_with_trafo     Method .  hnf{T  : RingElem}(A::GenMat{T}) -  GenMaT{T}, GenMat{T}   Return the upper right row Hermite normal form  H  of  A  together with invertible matrix  U  such that  UA = H .   source", 
            "title": "Hermite normal form"
        }, 
        {
            "location": "/matrix/#determinant", 
            "text": "#  Base.LinAlg.det     Method .  det{T  : RingElem}(M::MatElem{T})   Return the determinant of the matrix  M . We assume  M  is square.   source  #  Base.LinAlg.det     Method .  det{T  : FieldElem}(M::MatElem{T})   Return the determinant of the matrix  M . We assume  M  is square.   source  #  Nemo.det_divisor     Method .  det_divisor(x::fmpz_mat)   Return some positive divisor of the determinant of  x , if the determinant is nonzero, otherwise return zero.   source  #  Nemo.det_given_divisor     Method .  det_given_divisor(x::fmpz_mat, d::Integer, proved=true)   Return the determinant of  x  given a positive divisor of its determinant. If  proved == true  (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.   source  #  Nemo.det_given_divisor     Method .  det_given_divisor(x::fmpz_mat, d::fmpz, proved=true)   Return the determinant of  x  given a positive divisor of its determinant. If  proved == true  (the default), the output is guaranteed to be correct, otherwise a heuristic algorithm is used.   source  Here are some examples of computing the determinant.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nd = det(A)\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 6 3])\n\nc = det_divisor(A)\nd = det_given_divisor(A, c)", 
            "title": "Determinant"
        }, 
        {
            "location": "/matrix/#rank", 
            "text": "#  Base.LinAlg.rank     Method .  rank{T  : RingElem}(M::MatElem{T})   Return the rank of the matrix  M .   source  #  Base.LinAlg.rank     Method .  rank{T  : FieldElem}(M::MatElem{T})   Return the rank of the matrix  M .   source  Here are some examples of computing the rank of a matrix.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nd = rank(A)", 
            "title": "Rank"
        }, 
        {
            "location": "/matrix/#linear-solving", 
            "text": "solve{T  : RingElem}(::MatElem{T}, ::MatElem{T})  #  Nemo.cansolve     Method .  cansolve(a::fmpz_mat, b::fmpz_mat) -  Bool, fmpz_mat   Return true and a matrix  x  such that  ax = b , or false and some matrix in case  x  does not exist.   source  #  Nemo.solve_rational     Method .  solve_rational{T  : RingElem}(M::MatElem{T}, b::MatElem{T})   Given a non-singular  n\\times n  matrix over a ring and an  n\\times m  matrix over the same ring, return a tuple  x, d  consisting of an  n\\times m  matrix  x  and a denominator  d  such that  Ax = db . The denominator will be the determinant of  A  up to sign. If  A  is singular an exception is raised.   source  #  Nemo.solve_triu     Method .  solve_triu{T  : FieldElem}(U::MatElem{T}, b::MatElem{T}, unit=false)   Given a non-singular  n\\times n  matrix over a field which is upper triangular, and an  n\\times m  matrix over the same field, return an  n\\times m  matrix  x  such that  Ax = b . If  A  is singular an exception is raised. If unit is true then  U  is assumed to have ones on its diagonal, and the diagonal will not be read.   source  #  Nemo.solve_dixon     Method .  solve_dixon(a::fmpz_mat, b::fmpz_mat)   Return a tuple  (x, m)  consisting of a column vector  x  such that  ax = b \\pmod{m} . The element   b  must be a column vector with the same number   of rows as  a  and  a  must be a square matrix. If these conditions are not met or  (x, d)  does not exist, an exception is raised.   source  #  Nemo.solve_dixon     Method .  solve_dixon(a::fmpq_mat, b::fmpq_mat)   Solve  ax = b  by clearing denominators and using Dixon's algorithm. This is usually faster for large systems.   source  Here are some examples of linear solving.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\nS = MatrixSpace(K, 3, 3)\nU = MatrixSpace(K, 3, 1)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\nb = U([2a a + 1 (-a - 1)]')\n\nx = solve(A, b)\n\nA = S([a + 1 2a + 3 a^2 + 1; K(0) a^2 - 1 2a; K(0) K(0) a])\nb = U([2a a + 1 (-a - 1)]')\n\nx = solve_triu(A, b, false)\n\nR, x = PolynomialRing(ZZ,  x )\nS = MatrixSpace(R, 3, 3)\nU = MatrixSpace(R, 3, 2)\n\nA = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\nb = U([2x x + 1 (-x - 1); x + 1 (-x) x^2]')\n\nx, d = solve_rational(A, b)\n\nS = MatrixSpace(ZZ, 3, 3)\nT = MatrixSpace(ZZ, 3, 1)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])   \nB = T([fmpz(4), 5, 7])\n\nX, d = solve_rational(A, B)\nX, m = solve_dixon(A, B)", 
            "title": "Linear solving"
        }, 
        {
            "location": "/matrix/#inverse", 
            "text": "#  Base.inv     Method .  inv{T  : RingElem}(M::MatElem{T})   Given a non-singular  n\\times n  matrix over a ring the tuple  X, d  consisting of an  n\\times n  matrix  X  and a denominator  d  such that  AX = dI_n , where  I_n  is the  n\\times n  identity matrix. The denominator will be the determinant of  A  up to sign. If  A  is singular an exception  is raised.   source  #  Base.inv     Method .  inv{T  : FieldElem}(M::MatElem{T})   Given a non-singular  n\\times n  matrix over a field, return an  n\\times n  matrix  X  such that  AX = I_n  where  I_n  is the  n\\times n  identity matrix. If  A  is singular an exception is raised.   source  #  Base.inv     Method .  inv(M::arb_mat)   Given a   n\\times n  matrix of type  arb_mat , return an  n\\times n  matrix  X  such that  AX  contains the  identity matrix. If  A  cannot be inverted numerically an exception is raised.   source  #  Base.inv     Method .  inv(M::acb_mat)   Given a  n\\times n  matrix of type  acb_mat , return an  n\\times n  matrix  X  such that  AX  contains the  identity matrix. If  A  cannot be inverted numerically an exception is raised.   source  #  Nemo.pseudo_inv     Method .  pseudo_inv(x::fmpz_mat)   Return a tuple  (z, d)  consisting of a matrix  z  and denominator  d  such that  z/d  is the inverse of  x .   source  Here are some examples of taking the inverse of a matrix.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\nS = MatrixSpace(K, 3, 3)\n\nA = S([K(0) 2a + 3 a^2 + 1; a^2 - 2 a - 1 2a; a^2 + 3a + 1 2a K(1)])\n\nX = inv(A)\n\nR, x = PolynomialRing(ZZ,  x )\nS = MatrixSpace(R, 3, 3)\n\nA = S([R(0) 2x + 3 x^2 + 1; x^2 - 2 x - 1 2x; x^2 + 3x + 1 2x R(1)])\n\nX, d = inv(A)\n\nS = MatrixSpace(ZZ, 3, 3)\n\nA = S([1 0 1; 2 3 1; 5 6 7])\n\nB, d = pseudo_inv(A)\n\nA = RR[1 0 1; 2 3 1; 5 6 7]\n\nX = inv(A)", 
            "title": "Inverse"
        }, 
        {
            "location": "/matrix/#nullspace", 
            "text": "#  Base.LinAlg.nullspace     Method .  nullspace{T  : RingElem}(M::MatElem{T})   Returns a tuple  (\\nu, N)  consisting of the nullity  \\nu  of  M  and a basis  N  (consisting of column vectors) for the right nullspace of  M , i.e. such that  MN  is the zero matrix. If  M  is an  m\\times n  matrix  N  will be an  n\\times \\nu  matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In Nemo we use the name ``kernel'' for a function to compute an integral kernel.   source  #  Base.LinAlg.nullspace     Method .  nullspace{T  : FieldElem}(M::MatElem{T})   Returns a tuple  (\\nu, N)  consisting of the nullity  \\nu  of  M  and a basis  N  (consisting of column vectors) for the right nullspace of  M , i.e. such that  MN  is the zero matrix. If  M  is an  m\\times n  matrix  N  will be an  n\\times \\nu  matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In Nemo we use the name ``kernel'' for a function to compute an integral kernel.   source  #  Nemo.nullspace_right_rational     Method .  nullspace_right_rational(x::fmpz_mat)   Return the right rational nullspace of  x , i.e. a set of vectors over  \\mathbb{Z}  giving a  \\mathbb{Q} -basis for the nullspace of  x  considered as a matrix over  \\mathbb{Q} .   source  Here are some examples of computing the nullspace of a matrix.  R, x = PolynomialRing(ZZ,  x )\nS = MatrixSpace(R, 4, 4)\n\nM = S([-6*x^2+6*x+12 -12*x^2-21*x-15 -15*x^2+21*x+33 -21*x^2-9*x-9;\n       -8*x^2+8*x+16 -16*x^2+38*x-20 90*x^2-82*x-44 60*x^2+54*x-34;\n       -4*x^2+4*x+8 -8*x^2+13*x-10 35*x^2-31*x-14 22*x^2+21*x-15;\n       -10*x^2+10*x+20 -20*x^2+70*x-25 150*x^2-140*x-85 105*x^2+90*x-50])\n\nn, N = nullspace(M)", 
            "title": "Nullspace"
        }, 
        {
            "location": "/matrix/#hessenberg-form", 
            "text": "#  Nemo.hessenberg     Method .  hessenberg{T  : RingElem}(A::MatElem{T})   Returns the Hessenberg form of  M , i.e. an upper Hessenberg matrix which is similar to  M . The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.   source  #  Nemo.ishessenberg     Method .  ishessenberg{T  : RingElem}(A::MatElem{T})   Returns  true  if  M  is in Hessenberg form, otherwise returns  false .   source  Here are some examples of computing the Hessenberg form.  R = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 4, 4)\n\nM = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n       R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n\nA = hessenberg(M)\nishessenberg(A) == true", 
            "title": "Hessenberg form"
        }, 
        {
            "location": "/matrix/#characteristic-polynomial", 
            "text": "#  Nemo.charpoly     Method .  charpoly{T  : RingElem}(V::Ring, Y::MatElem{T})   Returns the characteristic polynomial  p  of the matrix  M . The polynomial ring  R  of the resulting polynomial must be supplied and the matrix is assumed to be square.   source  Here are some examples of computing the characteristic polynomial.  R = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 4, 4)\nT, x = PolynomialRing(R,  x )\n\nM = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n       R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n\nA = charpoly(T, M)", 
            "title": "Characteristic polynomial"
        }, 
        {
            "location": "/matrix/#minimal-polynomial", 
            "text": "#  Nemo.minpoly     Method .  minpoly{T  : RingElem}(S::Ring, M::MatElem{T}, charpoly_only = false)   Returns the minimal polynomial  p  of the matrix  M . The polynomial ring  R  of the resulting polynomial must be supplied and the matrix must be square.   source  #  Nemo.minpoly     Method .  minpoly{T  : FieldElem}(S::Ring, M::MatElem{T}, charpoly_only = false)   Returns the minimal polynomial  p  of the matrix  M . The polynomial ring  R  of the resulting polynomial must be supplied and the matrix must be square.   source  minpoly{T  : RingElem}(S::Ring, M::MatElem{T}, charpoly_only = false)   Returns the minimal polynomial  p  of the matrix  M . The polynomial ring  R  of the resulting polynomial must be supplied and the matrix must be square.   source  Here are some examples of computing the minimal polynomial of a matrix.  R, x = FiniteField(13, 1,  x )\nT, y = PolynomialRing(R,  y )\n\nM = R[7 6 1;\n      7 7 5;\n      8 12 5]\n\nA = minpoly(T, M)", 
            "title": "Minimal polynomial"
        }, 
        {
            "location": "/matrix/#transforms", 
            "text": "#  Nemo.similarity!     Method .  similarity!{T  : RingElem}(A::MatElem{T}, r::Int, d::T)   Applies a similarity transform to the  n\\times n  matrix  M  in-place. Let  P  be the  n\\times n  identity matrix that has had all zero entries of row  r  replaced with  d , then the transform applied is equivalent to  M = P^{-1}MP . We require  M  to be a square matrix. A similarity transform preserves the minimal and characteristic polynomials of a matrix.   source  Here is an example of applying a similarity transform to a matrix.  R = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 4, 4)\n\nM = S([R(1) R(2) R(4) R(3); R(2) R(5) R(1) R(0);\n       R(6) R(1) R(3) R(2); R(1) R(1) R(3) R(5)])\n\nsimilarity!(M, 1, R(3))", 
            "title": "Transforms"
        }, 
        {
            "location": "/matrix/#modular-reduction", 
            "text": "#  Nemo.reduce_mod     Method .  reduce_mod(x::fmpz_mat, y::Integer)   Reduce the entries of  x  modulo  y  and return the result.   source  #  Nemo.reduce_mod     Method .  reduce_mod(x::fmpz_mat, y::fmpz)   Reduce the entries of  x  modulo  y  and return the result.   source  Here are some examples of modular reduction.  S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 9 2 2])\n\nreduce_mod(A, ZZ(5))\nreduce_mod(A, 2)", 
            "title": "Modular reduction"
        }, 
        {
            "location": "/matrix/#lifting", 
            "text": "#  Nemo.lift     Method .  lift(a::nmod_mat)   Return a lift of the matrix  a  to a matrix over  \\mathbb{Z} , i.e. where the entries of the returned matrix are those of  a  lifted to  \\mathbb{Z} .   source  Here are some examples of lifting.  R = ResidueRing(ZZ, 7)\nS = MatrixSpace(R, 3, 3)\n\na = S([4 5 6; 7 3 2; 1 4 5])\n\n b = lift(a)", 
            "title": "Lifting"
        }, 
        {
            "location": "/matrix/#special-matrices", 
            "text": "#  Nemo.hadamard     Method .  hadamard(R::FmpzMatSpace)   Return the Hadamard matrix for the given matrix space. The number of rows and columns must be equal.   source  #  Nemo.ishadamard     Method .  ishadamard(x::fmpz_mat)   Return  true  if the given matrix is Hadamard, otherwise return  false .   source  #  Nemo.hilbert     Method .  hilbert(R::FmpqMatSpace)   Return the Hilbert matrix in the given matrix space. This is the matrix with entries  H_{i,j} = 1/(i + j - 1) .   source  Here are some examples of computing special matrices.  R = MatrixSpace(ZZ, 3, 3)\nS = MatrixSpace(QQ, 3, 3)\n\nA = hadamard(R)\nishadamard(A)\nB = hilbert(R)", 
            "title": "Special matrices"
        }, 
        {
            "location": "/matrix/#hermite-normal-form_1", 
            "text": "#  Nemo.hnf     Method .  hnf(x::fmpz_mat)   Return the Hermite Normal Form of  x .   source  #  Nemo.hnf_with_transform     Method .  hnf_with_transform(x::fmpz_mat)   Compute a tuple  (H, T)  where  H  is the Hermite normal form of  x  and  T  is a transformation matrix so that  H = Tx .   source  #  Nemo.hnf_modular     Method .  hnf_modular(x::fmpz_mat, d::fmpz)   Compute the Hermite normal form of  x  given that  d  is a multiple of the determinant of the nonzero rows of  x .   source  #  Nemo.hnf_modular_eldiv     Method .  hnf_modular_eldiv(x::fmpz_mat, d::fmpz)   Compute the Hermite normal form of  x  given that  d  is a multiple of the largest elementary divisor of  x . The matrix  x  must have full rank.   source  #  Nemo.ishnf     Method .  ishnf(x::fmpz_mat)   Return  true  if the given matrix is in Hermite Normal Form, otherwise return  false .   source  Here are some examples of computing the Hermite Normal Form.  S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = hnf(A)\nH, T = hnf_with_transform(A)\nM = hnf_modular(A, fmpz(27))\nN = hnf_modular_eldiv(A, fmpz(27))\nishnf(M)", 
            "title": "Hermite Normal Form"
        }, 
        {
            "location": "/matrix/#weak-popov-form", 
            "text": "Nemo provdes algorithms for computing the (weak) Popov of a matrix with entries in a univariate polynomial ring over a field.  weak_popov{T  : PolyElem}(::GenMat{T})\nweak_popov_with_trafo{T  : PolyElem}(::GenMat{T})\npopov{T  : PolyElem}(::GenMat{T})\npopov_with_trafo{T  : PolyElem}(::GenMat{T})\ndet_popov{T  : PolyElem}(::GenMat{T})", 
            "title": "(Weak) Popov form"
        }, 
        {
            "location": "/matrix/#lattice-basis-reduction", 
            "text": "Nemo provides LLL lattice basis reduction. Optionally one can specify the setup using a context object created by the following function.  lll_ctx(delta::Float64, eta::Float64, rep=:zbasis, gram=:approx)  Return a LLL context object specifying LLL parameters  \\delta  and  \\eta  and specifying the representation as either  :zbasis  or  :gram  and the Gram type as either  :approx  or  :exact .  #  Nemo.lll     Method .  lll(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51))   Return the LLL reduction of the matrix  x . By default the matrix  x  is a  \\mathbb{Z} -basis and the Gram matrix is maintained throughout in approximate form. The LLL is performed with reduction parameters  \\delta = 0.99  and  \\eta = 0.51 . All of these defaults can be overridden by specifying an optional context object.   source  #  Nemo.lll_with_transform     Method .   Compute a tuple  (L, T)  where  L  is the LLL reduction of  a  and  T  is a transformation matrix so that  L = Ta . All the default parameters can be overridden by supplying an optional context object.   source  #  Nemo.lll_gram     Method .  lll_gram(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51, :gram))   Given the Gram matrix  x  of a matrix, compute the Gram matrix of its LLL reduction.   source  #  Nemo.lll_gram_with_transform     Method .  lll_gram_with_transform(x::fmpz_mat, ctx=lll_ctx(0.99, 0.51, :gram))   Given the Gram matrix  x  of a matrix  M , compute a tuple  (L, T)  where  L  is the gram matrix of the LLL reduction of the matrix and  T  is a transformation matrix so that  L = TM .   source  #  Nemo.lll_with_removal     Method .  lll_with_removal(x::fmpz_mat, b::fmpz, ctx=lll_ctx(0.99, 0.51))   Compute the LLL reduction of  x  and throw away rows whose norm exceeds the given bound  b . Return a tuple  (r, L)  where the first  r  rows of  L  are the rows remaining after removal.   source  #  Nemo.lll_with_removal_transform     Method .  lll_with_removal_transform(x::fmpz_mat, b::fmpz, ctx=lll_ctx(0.99, 0.51))   Compute a tuple  (r, L, T)  where the first  r  rows of  L  are those remaining from the LLL reduction after removal of vectors with norm exceeding the bound  b  and  T  is a transformation matrix so that  L = Tx .   source  Here are some examples of lattice basis reduction.  S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nL = lll(A, lll_ctx(0.95, 0.55, :zbasis, :approx)\nL, T = lll_with_transform(A)\n\nG == lll_gram(gram(A))\nG, T = lll_gram_with_transform(gram(A))\n\nr, L = lll_with_removal(A, fmpz(100))\nr, L, T = lll_with_removal_transform(A, fmpz(100))", 
            "title": "Lattice basis reduction"
        }, 
        {
            "location": "/matrix/#smith-normal-form", 
            "text": "#  Nemo.snf     Method .  snf(x::fmpz_mat)   Compute the Smith normal form of  x .   source  #  Nemo.snf_diagonal     Method .  snf_diagonal(x::fmpz_mat)   Given a diagonal matrix  x  compute the Smith normal form of  x .   source  #  Nemo.issnf     Method .  issnf(x::fmpz_mat)   Return  true  if  x  is in Smith normal form, otherwise return  false .   source  Here are some examples of computing the Smith Normal Form.  S = MatrixSpace(ZZ, 3, 3)\n\nA = S([fmpz(2) 3 5; 1 4 7; 19 3 7])\n\nB = snf(A)\nissnf(B) == true\n\nB = S([fmpz(2) 0 0; 0 4 0; 0 0 7])\n\nC = snf_diagonal(B)", 
            "title": "Smith Normal Form"
        }, 
        {
            "location": "/matrix/#strong-echelon-form", 
            "text": "#  Nemo.strong_echelon_form     Method .  strong_echelon_form(a::nmod_mat)   Return the strong echeleon form of  a . The matrix  a  must have at least as many rows as columns.   source  Here is an example of computing the strong echelon form.  R = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = strong_echelon_form(A)", 
            "title": "Strong Echelon Form"
        }, 
        {
            "location": "/matrix/#howell-form", 
            "text": "#  Nemo.howell_form     Method .  howell_form(a::nmod_mat)   Return the Howell normal form of  a . The matrix  a  must have at least as many rows as columns.   source  Here is an example of computing the Howell form.  R = ResidueRing(ZZ, 12)\nS = MatrixSpace(R, 3, 3)\n\nA = S([4 1 0; 0 0 5; 0 0 0 ])\n\nB = howell_form(A)", 
            "title": "Howell Form"
        }, 
        {
            "location": "/matrix/#gram-schmidt-orthogonalisation", 
            "text": "#  Nemo.gso     Method .  gso(x::fmpq_mat)   Return the Gram-Schmidt Orthogonalisation of the matrix  x .   source  Here are some examples of computing the Gram-Schmidt Orthogonalisation.  S = MatrixSpace(QQ, 3, 3)\n\nA = S([4 7 3; 2 9 1; 0 5 3])\n\nB = gso(A)", 
            "title": "Gram-Schmidt Orthogonalisation"
        }, 
        {
            "location": "/matrix/#exponential", 
            "text": "#  Base.exp     Method .  exp(x::arb_mat)   Returns the exponential of the matrix  x .   source  #  Base.exp     Method .  exp(x::acb_mat)   Returns the exponential of the matrix  x .   source  Here are some examples of computing the exponential function of matrix.  A = RR[2 0 0; 0 3 0; 0 0 1]\n\nB = exp(A)", 
            "title": "Exponential"
        }, 
        {
            "location": "/matrix/#norm", 
            "text": "#  Nemo.bound_inf_norm     Method .  bound_inf_norm(x::arb_mat)   Returns a nonnegative element  z  of type  arb , such that  z  is an upper bound for the infinity norm for every matrix in  x    source  #  Nemo.bound_inf_norm     Method .  bound_inf_norm(x::acb_mat)   Returns a nonnegative element  z  of type  acb , such that  z  is an upper bound for the infinity norm for every matrix in  x    source  Here are some examples of computing bounds on the infinity norm of a matrix.  A = RR[1 2 3; 4 5 6; 7 8 9]\n\nd = bound_inf_norm(A)", 
            "title": "Norm"
        }, 
        {
            "location": "/matrix/#shifting", 
            "text": "#  Base.Math.ldexp     Method .  ldexp(x::acb_mat, y::Int)   Return  2^yx . Note that  y  can be positive, zero or negative.   source  #  Base.Math.ldexp     Method .  ldexp(x::acb_mat, y::Int)   Return  2^yx . Note that  y  can be positive, zero or negative.   source  Here are some examples of shifting.  A = RR[1 2 3; 4 5 6; 7 8 9]\n\nB = ldexp(A, 4)\n\noverlaps(16*A, B)", 
            "title": "Shifting"
        }, 
        {
            "location": "/matrix/#predicates", 
            "text": "#  Base.isreal     Method .  isreal(M::acb_mat)   Returns whether every entry of  M  has vanishing imaginary part.   source  Here are some examples for predicates.  A = CC[1 2 3; 4 5 6; 7 8 9]\n\nisreal(A)\n\nisreal(onei(CC)*A)", 
            "title": "Predicates"
        }, 
        {
            "location": "/integer/", 
            "text": "Introduction\n\n\nThe default integer type in Nemo is provided by Flint. The associated ring of integers is represented by the constant parent object called \nFlintZZ\n.\n\n\nFor convenience we define\n\n\nZZ = FlintZZ\n\n\n\n\nso that integers can be constructed using \nZZ\n instead of \nFlintZZ\n. Note that this is the name of a specific parent object, not the name of its type.\n\n\nThe types of the integer ring parent objects and elements of the asociated rings of integers are given in the following table according to the library provding them.\n\n\n\n\n\n\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nFlint\n\n\nfmpz\n\n\nFlintIntegerRing\n\n\n\n\n\n\n\n\nAll integer element types belong directly to the abstract type \nRingElem\n and all the integer ring parent object types belong to the abstract type \nRing\n.\n\n\n\n\nInteger element constructors\n\n\nThere are various ways to construct integers given an integer ring parent object such as \nZZ\n. As usual, one can coerce various elements into the ring of integers using the parent object. Here are some examples.\n\n\nZZ(123)\nZZ(\n123\n)\nZZ(123.0)\n\n\n\n\nNote that when coercing from floating point numbers of various kinds, the input must be exactly an integer without fractional part.\n\n\nApart from coercing elements into the ring of integers, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::FlintIntegerRing)\n\n\n\n\n\n\nReturn the integer \n1\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::FlintIntegerRing)\n\n\n\n\n\n\nReturn the integer \n1\n.\n\n\n\n\nsource\n\n\nHere are some examples of constructing integers.\n\n\na = ZZ(123)\nb = one(ZZ)\nc = zero(ZZ)\n\n\n\n\n\n\nBasic functionality\n\n\nThe following basic functionality is provided by the default integer implementation in Nemo, to support construction of generic rings over the integers. Any custom integer implementation in Nemo should provide these  functions along with the usual arithmetic operations and greatest common divisor.\n\n\nparent_type(::Type{fmpz})\n\n\n\n\nGives the type of the parent object of a Flint integer.\n\n\nelem_type(R::FlintIntegerRing)\n\n\n\n\nGiven the parent object for the integer ring, return the type of elements of the integer ring.\n\n\nBase.hash(a::fmpz, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the integer \na\n. This should be xor'd with a fixed random hexadecimal specific to the integer type. The hash of the machine words used to store the integer should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndeepcopy(a::fmpz)\n\n\n\n\nConstruct a copy of the given integer and return it. This function must recursively construct copies of all of the internal data in the given integer. Nemo integers are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::fmpz, a::fmpz, b::fmpz)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing integer \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::fmpz, a::fmpz)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven the parent object \nZZ\n for the integer ring, the following coercion functions are provided to coerce various elements into the integer ring. Developers provide these by overloading the \ncall\n operator for the integer ring parent objects.\n\n\nZZ()\n\n\n\n\nCoerce zero into the integer ring.\n\n\nZZ(n::Integer)\n\n\n\n\nCoerce an integer value into the integer ring.\n\n\nZZ(n::String)\n\n\n\n\nParse the given string as an integer.\n\n\nZZ(n::Float64)\nZZ(n::Float32)\nZZ(n::Float16)\nZZ(n::BigFloat)\n\n\n\n\nCoerce the given floating point number into the integer ring, assuming that it can be exactly represented as an integer.\n\n\nZZ(f::fmpz)\n\n\n\n\nTake an integer that is already in the Flint integer ring and simply return it. A copy of the original is not made.\n\n\nIn addition to the above, developers of custom integer types must ensure that they provide the equivalent of the function \nbase_ring(R::FlintIntegerRing)\n which should return \nUnion{}\n. In addition to this they should ensure that each integer element contains a field \nparent\n specifying the parent object of the integer, or at least supply the equivalent of the function  \nparent(a::fmpz)\n to return the parent object of an integer.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate integers. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::FlintIntegerRing)\n\n\n\n\n\n\nReturns \nUnion{}\n as this ring is not dependent on another ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::fmpz)\n\n\n\n\n\n\nReturns \nUnion{}\n as the parent ring is not dependent on another ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::fmpz)\n\n\n\n\n\n\nReturns the unique Flint integer parent object \nFlintZZ\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if the given integer is zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if the given integer is one, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if the given integer is a unit, i.e. \n\\pm 1\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sign\n \n \nMethod\n.\n\n\nsign(a::fmpz)\n\n\n\n\n\n\nReturns the sign of \na\n, i.e. \n+1\n, \n0\n or \n-1\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.size\n \n \nMethod\n.\n\n\nsize(a::fmpz)\n\n\n\n\n\n\nReturns the number of limbs required to store the absolute value of \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fits\n \n \nMethod\n.\n\n\nfits(::Type{UInt}, a::fmpz)\n\n\n\n\n\n\nReturns \ntrue\n if the given integer fits into a \nUInt\n, otherwise returns \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fits\n \n \nMethod\n.\n\n\nfits(::Type{Int}, a::fmpz)\n\n\n\n\n\n\nReturns \ntrue\n if the given integer fits into an \nInt\n, otherwise returns \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.den\n \n \nMethod\n.\n\n\nden(a::fmpz)\n\n\n\n\n\n\nReturns the denominator of \na\n thought of as a rational. Always returns \n1\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.num\n \n \nMethod\n.\n\n\nnum(a::fmpz)\n\n\n\n\n\n\nReturns the numerator of \na\n thought of as a rational. Always returns \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of integers.\n\n\na = ZZ(12)\n\nR = base_ring(ZZ)\nS = base_ring(a)\nT = parent(a)\niszero(a)\nisone(a)\nisunit(a)\nsign(a)\ns = size(a)\nfits(Int, a)\nn = num(a)\nd = den(a)\n\n\n\n\n\n\nArithmetic operations\n\n\nNemo provides all the standard ring operations for integers, as follows.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::fmpz)\n\n\nunary minus\n\n\n\n\n\n\n+(a::fmpz, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n-(a::fmpz, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::fmpz, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::fmpz, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\n\n\nIn addition, the following ad hoc ring operations are defined.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::fmpz, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::Integer, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n-(a::fmpz, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::Integer, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::fmpz, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::Integer, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::fmpz, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::Integer, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\n^(a::fmpz, b::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nHere are some examples of arithmetic operations on integers.\n\n\na = fmpz(12)\nb = fmpz(3)\n\nc = a + b\nd = divexact(a, b)\nf = 3a\ng = a*ZZ(7)\nh = 3 - a\nk = divexact(a, 4)\nm = a^7\n\n\n\n\n\n\nEuclidean division\n\n\nNemo also provides a large number of Euclidean division operations. Recall that for a dividend \na\n and divisor \nb\n, we can write \na = bq + r\n with \n0 \\leq |r| < |b|\n. We call \nq\n the quotient and \nr\n the remainder.\n\n\nWe distinguish three cases. If \nq\n is rounded towards zero, \nr\n will have the same sign as \na\n. If \nq\n is rounded towards plus infinity, \nr\n will have the opposite sign to \nb\n. Finally, if \nq\n is rounded towards minus infinity, \nr\n will have the same sign as \nb\n.\n\n\nIn the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with \nq\n representing return of the quotient and \nr\n representing return of the remainder.\n\n\n\n\n\n\n\n\nFunction\n\n\nReturn\n\n\nRounding\n\n\n\n\n\n\n\n\n\n\ndivrem(a::fmpz, b::fmpz)\n\n\nq, r\n\n\ntowards zero\n\n\n\n\n\n\ntdivrem(a::fmpz, b::fmpz)\n\n\nq, r\n\n\ntowards zero\n\n\n\n\n\n\nfdivrem(a::fmpz, b::fmpz)\n\n\nq, r\n\n\ntowards minus infinity\n\n\n\n\n\n\n\n\nNemo also offers the following ad hoc division operators. The notation and description is as for the other Euclidean division functions.\n\n\n\n\n\n\n\n\nFunction\n\n\nReturn\n\n\nRounding\n\n\n\n\n\n\n\n\n\n\nrem(a::fmpz, b::Int)\n\n\nr\n\n\ntowards zero\n\n\n\n\n\n\ndiv(a::fmpz, b::Int)\n\n\nq\n\n\ntowards zero\n\n\n\n\n\n\ntdiv(a::fmpz, b::Int)\n\n\nq\n\n\ntowards zero\n\n\n\n\n\n\nfdiv(a::fmpz, b::Int)\n\n\nq\n\n\ntowards minus infinity\n\n\n\n\n\n\ncdiv(a::fmpz, b::Int)\n\n\nq\n\n\ntowards plus infinity\n\n\n\n\n\n\n\n\nThe following functions are also available, for the case where one is dividing by a power of \n2\n. In other words, for Euclidean division of the form \na = b2^{d} + r\n. These are useful for bit twiddling.\n\n\n\n\n\n\n\n\nFunction\n\n\nReturn\n\n\nRounding\n\n\n\n\n\n\n\n\n\n\ntdivpow2(a::fmpz, d::Int)\n\n\nq\n\n\ntowards zero\n\n\n\n\n\n\nfdivpow2(a::fmpz, d::Int)\n\n\nq\n\n\ntowards minus infinity\n\n\n\n\n\n\nfmodpow2(a::fmpz, d::Int)\n\n\nr\n\n\ntowards minus infinity\n\n\n\n\n\n\ncdivpow2(a::fmpz, d::Int)\n\n\nq\n\n\ntowards plus infinity\n\n\n\n\n\n\n\n\nHere are some examples of Euclidean division.\n\n\na = fmpz(12)\nb = fmpz(5)\n\nq, r = divrem(a, b)\nc = cdiv(a, b)\nd = fdiv(a, b)\nf = tdivpow2(a, 2)\ng = fmodpow2(a, 3)\n\n\n\n\n\n\nComparison\n\n\nNemo provides a full complement of comparison operators for integers. This includes the usual \n<, >, \\leq, \\geq, ==, !=\n operators. These are usually provided via Julia once Nemo provides the \nisless\n function and the \n==\n function. However, to avoid two calls to Flint for such comparisons we implement them differently.\n\n\nInstead of \nisless\n we implement a function \ncmp(a, b)\n which returns a positive value if \na > b\n, zero if \na == b\n and a negative value if \na < b\n. We then implement all the other operators, including \n==\n in terms of \ncmp\n.\n\n\nFor convenience we also implement a \ncmpabs(a, b)\n function which returns a positive value if \n|a| > |b|\n, zero if \n|a| == |b|\n and a negative value if \n|a| < |b|\n. This can be slightly faster than a call to \ncmp\n or one of the comparison operators when comparing nonnegative values for example.\n\n\nHere is a list of the comparison functions implemented, with the understanding that \ncmp\n provides all of the comparison operators listed above.\n\n\n\n\nFunction\n\n\ncmp(a::fmpz, b::fmpz) cmpabs(a::fmpz, b::fmpz)\n\n\nWe also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.\n\n\n\n\nFunction\n\n\ncmp(a::fmpz, b::Int) cmp(a::Int, b::fmpz) cmp(a::fmpz, b::UInt) cmp(a::UInt, b::fmpz)\n\n\nHere are some examples of comparisons.\n\n\na = ZZ(12)\nb = ZZ(3)\n\na \n b\na != b\na \n 4\n5 \n= b\ncmpabs(a, b)\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nBase.:\n \n \nMethod\n.\n\n\n(x::fmpz, c::Int)\n\n\n\n\n\n\nReturn \n2^cx\n where \nc \\geq 0\n.\n\n\n\n\nsource\n\n\n\n\nBase.:\n \n \nMethod\n.\n\n\n(x::fmpz, c::Int)\n\n\n\n\n\n\nReturn \nx/2^c\n, discarding any remainder, where \nc \\geq 0\n.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\na = fmpz(12)\n\na \n 3\na \n 5\n\n\n\n\n\n\nModular arithmetic\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod(x::fmpz, y::fmpz)\n\n\n\n\n\n\nReturn the remainder after division of \nx\n by \ny\n. The remainder will be the least nonnegative remainder.\n\n\n\n\nsource\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod(x::fmpz, y::Int)\n\n\n\n\n\n\nReturn the remainder after division of \nx\n by \ny\n. The remainder will be the least nonnegative remainder.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod(x::fmpz, p::fmpz, m::fmpz)\n\n\n\n\n\n\nReturn \nx^p (\\mod m)\n. The remainder will be in the range \n[0, m)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod(x::fmpz, p::Int, m::fmpz)\n\n\n\n\n\n\nReturn \nx^p (\\mod m)\n. The remainder will be in the range \n[0, m)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.invmod\n \n \nMethod\n.\n\n\ninvmod(x::fmpz, m::fmpz)\n\n\n\n\n\n\nReturn \nx^{-1} (\\mod m)\n. The remainder will be in the range \n[0, m)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sqrtmod\n \n \nMethod\n.\n\n\nsqrtmod(x::fmpz, m::fmpz)\n\n\n\n\n\n\nReturn a square root of \nx (\\mod m)\n if one exists. The remainder will be in the range \n[0, m)\n. We require that \nm\n is prime, otherwise the algorithm may not terminate.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.crt\n \n \nMethod\n.\n\n\ncrt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, signed=false)\n\n\n\n\n\n\nFind \nr\n such that \nr \\equiv r_1 (\\mod m_1)\n and \nr \\equiv r_2 (\\mod m_2)\n. If \nsigned = true\n, \nr\n will be in the range \n-m_1m_2/2 < r \\leq m_1m_2/2\n. If \nsigned = false\n the value will be in the range \n0 \\leq r < m_1m_2\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.crt\n \n \nMethod\n.\n\n\ncrt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, signed=false)\n\n\n\n\n\n\nFind \nr\n such that \nr \\equiv r_1 (\\mod m_1)\n and \nr \\equiv r_2 (\\mod m_2)\n. If \nsigned = true\n, \nr\n will be in the range \n-m_1m_2/2 < r \\leq m_1m_2/2\n. If \nsigned = false\n the value will be in the range \n0 \\leq r < m_1m_2\n.\n\n\n\n\nsource\n\n\nHere are some examples of modular arithmetic.\n\n\na = powmod(ZZ(12), ZZ(110), ZZ(13))\na = powmod(ZZ(12), 110, ZZ(13))\nb = invmod(ZZ(12), ZZ(13))\nc = sqrtmod(ZZ(12), ZZ(13))\nd = crt(ZZ(5), ZZ(13), ZZ(7), ZZ(37), true)\n\n\n\n\n\n\nInteger logarithm\n\n\n#\n\n\nNemo.flog\n \n \nMethod\n.\n\n\nflog(x::fmpz, c::fmpz)\n\n\n\n\n\n\nReturn the floor of the logarithm of \nx\n to base \nc\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.flog\n \n \nMethod\n.\n\n\nflog(x::fmpz, c::Int)\n\n\n\n\n\n\nReturn the floor of the logarithm of \nx\n to base \nc\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.clog\n \n \nMethod\n.\n\n\nclog(x::fmpz, c::fmpz)\n\n\n\n\n\n\nReturn the ceiling of the logarithm of \nx\n to base \nc\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.clog\n \n \nMethod\n.\n\n\nclog(x::fmpz, c::Int)\n\n\n\n\n\n\nReturn the ceiling of the logarithm of \nx\n to base \nc\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing integer logarithms.\n\n\na = fmpz(12)\nb = fmpz(2)\n\nc = flog(a, b)\nd = clog(a, 3)\n\n\n\n\n\n\nGCD and LCM\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd(x::fmpz, y::fmpz)\n\n\n\n\n\n\nReturn the greatest common divisor of \nx\n and \ny\n. The returned result will always be nonnegative and will be zero iff \nx\n and \ny\n are zero.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd(x::Array{fmpz, 1})\n\n\n\n\n\n\nReturn the greatest common divisor of the elements of \nx\n. The returned result will always be nonnegative and will be zero iff all elements of \nx\n are zero.\n\n\n\n\nsource\n\n\n#\n\n\nBase.lcm\n \n \nMethod\n.\n\n\nlcm(x::fmpz, y::fmpz)\n\n\n\n\n\n\nReturn the least common multiple of \nx\n and \ny\n. The returned result will always be nonnegative and will be zero iff \nx\n and \ny\n are zero.\n\n\n\n\nsource\n\n\n#\n\n\nBase.lcm\n \n \nMethod\n.\n\n\nlcm(x::Array{fmpz, 1})\n\n\n\n\n\n\nReturn the least common multiple of the elements of \nx\n. The returned result will always be nonnegative and will be zero iff the elements of \nx\n are zero.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcdx\n \n \nMethod\n.\n\n\ngcdx(a::fmpz, b::fmpz)\n\n\n\n\n\n\nReturn a tuple \ng, s, t\n such that \ng\n is the greatest common divisor of \na\n and \nb\n and integers \ns\n and \nt\n such that \ng = as + bt\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gcdinv\n \n \nMethod\n.\n\n\ngcdinv(a::fmpz, b::fmpz)\n\n\n\n\n\n\nReturn a tuple \ng, s\n where \ng\n is the greatest common divisor of \na\n and \nb\n and where \ns\n is the inverse of \na\n modulo \nb\n if \ng = 1\n. This function can be used to detect impossible inverses, i.e. where \na\n and \nb\n are not coprime, and to yield the common factor of \na\n and \nb\n if they are not coprime. We require \nb \\geq a \\geq 0\n.\n\n\n\n\nsource\n\n\nHere are some examples of GCD and LCM.\n\n\na = ZZ(3)\nb = ZZ(12)\n\nc = gcd(a, b)\nd = lcm(a, b)\ng, s, t = gcdx(a, b)\ng, s = gcdinv(a, b)\n\n\n\n\n\n\nInteger roots\n\n\n#\n\n\nBase.isqrt\n \n \nMethod\n.\n\n\nisqrt(x::fmpz)\n\n\n\n\n\n\nReturn the floor of the square root of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isqrtrem\n \n \nMethod\n.\n\n\nisqrtrem(x::fmpz)\n\n\n\n\n\n\nReturn a tuple \ns, r\n consisting of the floor \ns\n of the square root of \nx\n and the remainder \nr\n, i.e. such that \nx = s^2 + r\n. We require \nx \\geq 0\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.root\n \n \nMethod\n.\n\n\nroot(x::fmpz, n::Int)\n\n\n\n\n\n\nReturn the floor of the \nn\n-the root of \nx\n. We require \nn > 0\n and that \nx \\geq 0\n if \nn\n is even.\n\n\n\n\nsource\n\n\nHere are some examples of integer roots.\n\n\na = ZZ(13)\n\nb = sqrt(a)\ns, r = sqrtrem(a)\nc = root(a, 3)\n\n\n\n\n\n\nNumber theoretic functionality\n\n\n#\n\n\nNemo.divisible\n \n \nMethod\n.\n\n\ndivisible(x::fmpz, y::Int)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is divisible by \ny\n, otherwise return \nfalse\n. We require \nx \\neq 0\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divisible\n \n \nMethod\n.\n\n\ndivisible(x::fmpz, y::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is divisible by \ny\n, otherwise return \nfalse\n. We require \nx \\neq 0\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issquare\n \n \nMethod\n.\n\n\nissquare(x::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is a square, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nisprime(::UInt)\nisprime(::fmpz)\n\n\n\n\n#\n\n\nNemo.isprobabprime\n \n \nMethod\n.\n\n\nisprobabprime(x::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is a very probably a prime number, otherwise return \nfalse\n. No counterexamples are known to this test, but it is conjectured that infinitely many exist.\n\n\n\n\nsource\n\n\nfactor(::fmpz)\n\n\n\n\nremove(::fmpz, y:fmpz)\n\n\n\n\n#\n\n\nNemo.divisor_lenstra\n \n \nMethod\n.\n\n\ndivisor_lenstra(n::fmpz, r::fmpz, m::fmpz)\n\n\n\n\n\n\nIf \nn\n has a factor which lies in the residue class \nr (\\mod m)\n for \n0 < r < m < n\n, this function returns such a factor. Otherwise it returns \n0\n. This is only efficient if \nm\n is at least the cube root of \nn\n. We require gcd\n(r, m) = 1\n and this condition is not checked.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fac\n \n \nMethod\n.\n\n\nfac(x::Int)\n\n\n\n\n\n\nReturn the factorial of \nx\n, i.e. \nx! = 1.2.3\\ldots x\n. We require \nx \\geq 0\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.risingfac\n \n \nMethod\n.\n\n\nrisingfac(x::fmpz, y::Int)\n\n\n\n\n\n\nReturn the rising factorial of \nx\n, i.e. \nx(x + 1)(x + 2)\\ldots (x + n - 1)\n. If \nn < 0\n we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.risingfac\n \n \nMethod\n.\n\n\nrisingfac(x::Int, y::Int)\n\n\n\n\n\n\nReturn the rising factorial of \nx\n, i.e. \nx(x + 1)(x + 2)\\ldots (x + n - 1)\n. If \nn < 0\n we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.primorial\n \n \nMethod\n.\n\n\nprimorial(x::Int)\n\n\n\n\n\n\nReturn the primorial of \nn\n, i.e. the product of all primes less than or equal to \nn\n. If \nn < 0\n we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fib\n \n \nMethod\n.\n\n\nfib(x::Int)\n\n\n\n\n\n\nReturn the \nn\n-th Fibonacci number \nF_n\n. We define \nF_1 = 1\n, \nF_2 = 1\n and \nF_{i + 1} = F_i + F_{i - 1}\n for all \ni > 2\n. We require \nn \\geq 0\n. For convenience, we define \nF_0 = 0\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bell\n \n \nMethod\n.\n\n\nbell(x::Int)\n\n\n\n\n\n\nReturn the Bell number \nB_n\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.binom\n \n \nMethod\n.\n\n\nbinom(n::Int, k::Int)\n\n\n\n\n\n\nReturn the binomial coefficient \n\\frac{n!}{(n - k)!k!}\n. If \nn, k < 0\n or \nk > n\n we return \n0\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.moebiusmu\n \n \nMethod\n.\n\n\nmoebiusmu(x::fmpz)\n\n\n\n\n\n\nReturns the Moebius mu function of \nx\n as an \\code{Int}. The value returned is either \n-1\n, \n0\n or \n1\n. If \nx < 0\n we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.jacobi\n \n \nMethod\n.\n\n\njacobi(x::fmpz, y::fmpz)\n\n\n\n\n\n\nReturn the value of the Jacobi symbol \n\\left(\\frac{x}{y}\\right)\n. If \ny \\leq x\n or \nx < 0\n, we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sigma\n \n \nMethod\n.\n\n\nsigma(x::fmpz, y::Int)\n\n\n\n\n\n\nReturn the value of the sigma function, i.e. \n\\sum_{0 < d \\;| x} d^y\n. If \ny < 0\n we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.eulerphi\n \n \nMethod\n.\n\n\neulerphi(x::fmpz)\n\n\n\n\n\n\nReturn the value of the Euler phi function at \nx\n, i.e. the number of positive integers less than \nx\n that are coprime with \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.numpart\n \n \nMethod\n.\n\n\nnumpart(x::Int)\n\n\n\n\n\n\nReturn the number of partitions of \nx\n. This function is not available on Windows 64.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.numpart\n \n \nMethod\n.\n\n\nnumpart(x::fmpz)\n\n\n\n\n\n\nReturn the number of partitions of \nx\n. This function is not available on Windows 64.\n\n\n\n\nsource\n\n\nHere are some examples of number theoretic functionality.\n\n\nisprime(ZZ(13))\nn = fac(100)\ns = sigma(ZZ(128), 10)\na = eulerphi(ZZ(12480))\np = numpart(1000)\nf = factor(ZZ(12))\n\n\n\n\n\n\nNumber digits and bases\n\n\n#\n\n\nBase.bin\n \n \nMethod\n.\n\n\nbin(n::fmpz)\n\n\n\n\n\n\nReturn \nn\n as a binary string.\n\n\n\n\nsource\n\n\n#\n\n\nBase.oct\n \n \nMethod\n.\n\n\noct(n::fmpz)\n\n\n\n\n\n\nReturn \nn\n as a octal string.\n\n\n\n\nsource\n\n\n#\n\n\nBase.dec\n \n \nMethod\n.\n\n\ndec(n::fmpz)\n\n\n\n\n\n\nReturn \nn\n as a decimal string.\n\n\n\n\nsource\n\n\n#\n\n\nBase.hex\n \n \nMethod\n.\n\n\nhex(n::fmpz) = base(n, 16)\n\n\n\n\n\n\nReturn \nn\n as a hexadecimal string.\n\n\n\n\nsource\n\n\n#\n\n\nBase.base\n \n \nMethod\n.\n\n\nbase(n::fmpz, b::Integer)\n\n\n\n\n\n\nReturn \nn\n as a string in base \nb\n. We require \n2 \\leq b \\leq 62\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.ndigits\n \n \nMethod\n.\n\n\nndigits(x::fmpz, b::Integer = 10)\n\n\n\n\n\n\nReturn the number of digits of \nx\n in the base \nb\n (default is \nb = 10\n).\n\n\n\n\nsource\n\n\n#\n\n\nNemo.nbits\n \n \nMethod\n.\n\n\nnbits(x::fmpz)\n\n\n\n\n\n\nReturn the number of binary bits of \nx\n. We return zero if \nx = 0\n.\n\n\n\n\nsource\n\n\nHere are some examples of writing numbers in various bases.\n\n\na = fmpz(12)\n\ns1 = bin(a)\ns2 = base(a, 13)\nn1 = nbits(a)\nn2 = ndigits(a, 3)\n\n\n\n\n\n\nBit twiddling\n\n\n#\n\n\nNemo.popcount\n \n \nMethod\n.\n\n\npopcount(x::fmpz)\n\n\n\n\n\n\nReturn the number of ones in the binary representation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.prevpow2\n \n \nMethod\n.\n\n\nprevpow2(x::fmpz)\n\n\n\n\n\n\nReturn the previous power of \n2\n up to including \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.nextpow2\n \n \nMethod\n.\n\n\nnextpow2(x::fmpz)\n\n\n\n\n\n\nReturn the next power of \n2\n that is at least \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.trailing_zeros\n \n \nMethod\n.\n\n\ntrailing_zeros(x::fmpz)\n\n\n\n\n\n\nCount the trailing zeros in the binary representation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.clrbit!\n \n \nMethod\n.\n\n\nclrbit!(x::fmpz, c::Int)\n\n\n\n\n\n\nClear bit \nc\n of \nx\n, where the least significant bit is the \n0\n-th bit. Note that this function modifies its input in-place.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.setbit!\n \n \nMethod\n.\n\n\nsetbit!(x::fmpz, c::Int)\n\n\n\n\n\n\nSet bit \nc\n of \nx\n, where the least significant bit is the \n0\n-th bit. Note that this function modifies its input in-place.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.combit!\n \n \nMethod\n.\n\n\ncombit!(x::fmpz, c::Int)\n\n\n\n\n\n\nComplement bit \nc\n of \nx\n, where the least significant bit is the \n0\n-th bit. Note that this function modifies its input in-place.\n\n\n\n\nsource\n\n\nHere are some examples of bit twiddling.\n\n\na = fmpz(12)\n\np = popcount(a)\nb = nextpow2(a)\ncombit!(a, 2)", 
            "title": "Integers"
        }, 
        {
            "location": "/integer/#introduction", 
            "text": "The default integer type in Nemo is provided by Flint. The associated ring of integers is represented by the constant parent object called  FlintZZ .  For convenience we define  ZZ = FlintZZ  so that integers can be constructed using  ZZ  instead of  FlintZZ . Note that this is the name of a specific parent object, not the name of its type.  The types of the integer ring parent objects and elements of the asociated rings of integers are given in the following table according to the library provding them.     Library  Element type  Parent type      Flint  fmpz  FlintIntegerRing     All integer element types belong directly to the abstract type  RingElem  and all the integer ring parent object types belong to the abstract type  Ring .", 
            "title": "Introduction"
        }, 
        {
            "location": "/integer/#integer-element-constructors", 
            "text": "There are various ways to construct integers given an integer ring parent object such as  ZZ . As usual, one can coerce various elements into the ring of integers using the parent object. Here are some examples.  ZZ(123)\nZZ( 123 )\nZZ(123.0)  Note that when coercing from floating point numbers of various kinds, the input must be exactly an integer without fractional part.  Apart from coercing elements into the ring of integers, we offer the following functions.  #  Base.zero     Method .  zero(R::FlintIntegerRing)   Return the integer  1 .   source  #  Base.one     Method .  one(R::FlintIntegerRing)   Return the integer  1 .   source  Here are some examples of constructing integers.  a = ZZ(123)\nb = one(ZZ)\nc = zero(ZZ)", 
            "title": "Integer element constructors"
        }, 
        {
            "location": "/integer/#basic-functionality", 
            "text": "The following basic functionality is provided by the default integer implementation in Nemo, to support construction of generic rings over the integers. Any custom integer implementation in Nemo should provide these  functions along with the usual arithmetic operations and greatest common divisor.  parent_type(::Type{fmpz})  Gives the type of the parent object of a Flint integer.  elem_type(R::FlintIntegerRing)  Given the parent object for the integer ring, return the type of elements of the integer ring.  Base.hash(a::fmpz, h::UInt)  Return a  UInt  hexadecimal hash of the integer  a . This should be xor'd with a fixed random hexadecimal specific to the integer type. The hash of the machine words used to store the integer should be xor'd with the supplied parameter  h  as part of computing the hash.  deepcopy(a::fmpz)  Construct a copy of the given integer and return it. This function must recursively construct copies of all of the internal data in the given integer. Nemo integers are mutable and so returning shallow copies is not sufficient.  mul!(c::fmpz, a::fmpz, b::fmpz)  Multiply  a  by  b  and set the existing integer  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::fmpz, a::fmpz)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given the parent object  ZZ  for the integer ring, the following coercion functions are provided to coerce various elements into the integer ring. Developers provide these by overloading the  call  operator for the integer ring parent objects.  ZZ()  Coerce zero into the integer ring.  ZZ(n::Integer)  Coerce an integer value into the integer ring.  ZZ(n::String)  Parse the given string as an integer.  ZZ(n::Float64)\nZZ(n::Float32)\nZZ(n::Float16)\nZZ(n::BigFloat)  Coerce the given floating point number into the integer ring, assuming that it can be exactly represented as an integer.  ZZ(f::fmpz)  Take an integer that is already in the Flint integer ring and simply return it. A copy of the original is not made.  In addition to the above, developers of custom integer types must ensure that they provide the equivalent of the function  base_ring(R::FlintIntegerRing)  which should return  Union{} . In addition to this they should ensure that each integer element contains a field  parent  specifying the parent object of the integer, or at least supply the equivalent of the function   parent(a::fmpz)  to return the parent object of an integer.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/integer/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate integers. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(a::FlintIntegerRing)   Returns  Union{}  as this ring is not dependent on another ring.   source  #  Nemo.base_ring     Method .  base_ring(a::fmpz)   Returns  Union{}  as the parent ring is not dependent on another ring.   source  #  Base.parent     Method .  parent(a::fmpz)   Returns the unique Flint integer parent object  FlintZZ .   source  #  Nemo.iszero     Method .  iszero(a::fmpz)   Return  true  if the given integer is zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::fmpz)   Return  true  if the given integer is one, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::fmpz)   Return  true  if the given integer is a unit, i.e.  \\pm 1 , otherwise return  false .   source  #  Base.sign     Method .  sign(a::fmpz)   Returns the sign of  a , i.e.  +1 ,  0  or  -1 .   source  #  Base.size     Method .  size(a::fmpz)   Returns the number of limbs required to store the absolute value of  a .   source  #  Nemo.fits     Method .  fits(::Type{UInt}, a::fmpz)   Returns  true  if the given integer fits into a  UInt , otherwise returns  false .   source  #  Nemo.fits     Method .  fits(::Type{Int}, a::fmpz)   Returns  true  if the given integer fits into an  Int , otherwise returns  false .   source  #  Base.den     Method .  den(a::fmpz)   Returns the denominator of  a  thought of as a rational. Always returns  1 .   source  #  Base.num     Method .  num(a::fmpz)   Returns the numerator of  a  thought of as a rational. Always returns  a .   source  Here are some examples of basic manipulation of integers.  a = ZZ(12)\n\nR = base_ring(ZZ)\nS = base_ring(a)\nT = parent(a)\niszero(a)\nisone(a)\nisunit(a)\nsign(a)\ns = size(a)\nfits(Int, a)\nn = num(a)\nd = den(a)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/integer/#arithmetic-operations", 
            "text": "Nemo provides all the standard ring operations for integers, as follows.     Function  Operation      -(a::fmpz)  unary minus    +(a::fmpz, b::fmpz)  addition    -(a::fmpz, b::fmpz)  subtraction    *(a::fmpz, b::fmpz)  multiplication    divexact(a::fmpz, b::fmpz)  exact division     In addition, the following ad hoc ring operations are defined.     Function  Operation      +(a::fmpz, b::Integer)  addition    +(a::Integer, b::fmpz)  addition    -(a::fmpz, b::Integer)  subtraction    -(a::Integer, b::fmpz)  subtraction    *(a::fmpz, b::Integer)  multiplication    *(a::Integer, b::fmpz)  multiplication    divexact(a::fmpz, b::Integer)  exact division    divexact(a::Integer, b::fmpz)  exact division    ^(a::fmpz, b::Int)  powering     Here are some examples of arithmetic operations on integers.  a = fmpz(12)\nb = fmpz(3)\n\nc = a + b\nd = divexact(a, b)\nf = 3a\ng = a*ZZ(7)\nh = 3 - a\nk = divexact(a, 4)\nm = a^7", 
            "title": "Arithmetic operations"
        }, 
        {
            "location": "/integer/#euclidean-division", 
            "text": "Nemo also provides a large number of Euclidean division operations. Recall that for a dividend  a  and divisor  b , we can write  a = bq + r  with  0 \\leq |r| < |b| . We call  q  the quotient and  r  the remainder.  We distinguish three cases. If  q  is rounded towards zero,  r  will have the same sign as  a . If  q  is rounded towards plus infinity,  r  will have the opposite sign to  b . Finally, if  q  is rounded towards minus infinity,  r  will have the same sign as  b .  In the following table we list the division functions and their rounding behaviour. We also give the return value of the function, with  q  representing return of the quotient and  r  representing return of the remainder.     Function  Return  Rounding      divrem(a::fmpz, b::fmpz)  q, r  towards zero    tdivrem(a::fmpz, b::fmpz)  q, r  towards zero    fdivrem(a::fmpz, b::fmpz)  q, r  towards minus infinity     Nemo also offers the following ad hoc division operators. The notation and description is as for the other Euclidean division functions.     Function  Return  Rounding      rem(a::fmpz, b::Int)  r  towards zero    div(a::fmpz, b::Int)  q  towards zero    tdiv(a::fmpz, b::Int)  q  towards zero    fdiv(a::fmpz, b::Int)  q  towards minus infinity    cdiv(a::fmpz, b::Int)  q  towards plus infinity     The following functions are also available, for the case where one is dividing by a power of  2 . In other words, for Euclidean division of the form  a = b2^{d} + r . These are useful for bit twiddling.     Function  Return  Rounding      tdivpow2(a::fmpz, d::Int)  q  towards zero    fdivpow2(a::fmpz, d::Int)  q  towards minus infinity    fmodpow2(a::fmpz, d::Int)  r  towards minus infinity    cdivpow2(a::fmpz, d::Int)  q  towards plus infinity     Here are some examples of Euclidean division.  a = fmpz(12)\nb = fmpz(5)\n\nq, r = divrem(a, b)\nc = cdiv(a, b)\nd = fdiv(a, b)\nf = tdivpow2(a, 2)\ng = fmodpow2(a, 3)", 
            "title": "Euclidean division"
        }, 
        {
            "location": "/integer/#comparison", 
            "text": "Nemo provides a full complement of comparison operators for integers. This includes the usual  <, >, \\leq, \\geq, ==, !=  operators. These are usually provided via Julia once Nemo provides the  isless  function and the  ==  function. However, to avoid two calls to Flint for such comparisons we implement them differently.  Instead of  isless  we implement a function  cmp(a, b)  which returns a positive value if  a > b , zero if  a == b  and a negative value if  a < b . We then implement all the other operators, including  ==  in terms of  cmp .  For convenience we also implement a  cmpabs(a, b)  function which returns a positive value if  |a| > |b| , zero if  |a| == |b|  and a negative value if  |a| < |b| . This can be slightly faster than a call to  cmp  or one of the comparison operators when comparing nonnegative values for example.  Here is a list of the comparison functions implemented, with the understanding that  cmp  provides all of the comparison operators listed above.", 
            "title": "Comparison"
        }, 
        {
            "location": "/integer/#function", 
            "text": "cmp(a::fmpz, b::fmpz) cmpabs(a::fmpz, b::fmpz)  We also provide the following ad hoc comparisons which again provide all of the comparison operators mentioned above.", 
            "title": "Function"
        }, 
        {
            "location": "/integer/#function_1", 
            "text": "cmp(a::fmpz, b::Int) cmp(a::Int, b::fmpz) cmp(a::fmpz, b::UInt) cmp(a::UInt, b::fmpz)  Here are some examples of comparisons.  a = ZZ(12)\nb = ZZ(3)\n\na   b\na != b\na   4\n5  = b\ncmpabs(a, b)", 
            "title": "Function"
        }, 
        {
            "location": "/integer/#shifting", 
            "text": "#  Base.:     Method .  (x::fmpz, c::Int)   Return  2^cx  where  c \\geq 0 .   source   Base.:     Method .  (x::fmpz, c::Int)   Return  x/2^c , discarding any remainder, where  c \\geq 0 .   source  Here are some examples of shifting.  a = fmpz(12)\n\na   3\na   5", 
            "title": "Shifting"
        }, 
        {
            "location": "/integer/#modular-arithmetic", 
            "text": "#  Base.mod     Method .  mod(x::fmpz, y::fmpz)   Return the remainder after division of  x  by  y . The remainder will be the least nonnegative remainder.   source  #  Base.mod     Method .  mod(x::fmpz, y::Int)   Return the remainder after division of  x  by  y . The remainder will be the least nonnegative remainder.   source  #  Nemo.powmod     Method .  powmod(x::fmpz, p::fmpz, m::fmpz)   Return  x^p (\\mod m) . The remainder will be in the range  [0, m)    source  #  Nemo.powmod     Method .  powmod(x::fmpz, p::Int, m::fmpz)   Return  x^p (\\mod m) . The remainder will be in the range  [0, m)    source  #  Base.invmod     Method .  invmod(x::fmpz, m::fmpz)   Return  x^{-1} (\\mod m) . The remainder will be in the range  [0, m)    source  #  Nemo.sqrtmod     Method .  sqrtmod(x::fmpz, m::fmpz)   Return a square root of  x (\\mod m)  if one exists. The remainder will be in the range  [0, m) . We require that  m  is prime, otherwise the algorithm may not terminate.   source  #  Nemo.crt     Method .  crt(r1::fmpz, m1::fmpz, r2::fmpz, m2::fmpz, signed=false)   Find  r  such that  r \\equiv r_1 (\\mod m_1)  and  r \\equiv r_2 (\\mod m_2) . If  signed = true ,  r  will be in the range  -m_1m_2/2 < r \\leq m_1m_2/2 . If  signed = false  the value will be in the range  0 \\leq r < m_1m_2 .   source  #  Nemo.crt     Method .  crt(r1::fmpz, m1::fmpz, r2::Int, m2::Int, signed=false)   Find  r  such that  r \\equiv r_1 (\\mod m_1)  and  r \\equiv r_2 (\\mod m_2) . If  signed = true ,  r  will be in the range  -m_1m_2/2 < r \\leq m_1m_2/2 . If  signed = false  the value will be in the range  0 \\leq r < m_1m_2 .   source  Here are some examples of modular arithmetic.  a = powmod(ZZ(12), ZZ(110), ZZ(13))\na = powmod(ZZ(12), 110, ZZ(13))\nb = invmod(ZZ(12), ZZ(13))\nc = sqrtmod(ZZ(12), ZZ(13))\nd = crt(ZZ(5), ZZ(13), ZZ(7), ZZ(37), true)", 
            "title": "Modular arithmetic"
        }, 
        {
            "location": "/integer/#integer-logarithm", 
            "text": "#  Nemo.flog     Method .  flog(x::fmpz, c::fmpz)   Return the floor of the logarithm of  x  to base  c .   source  #  Nemo.flog     Method .  flog(x::fmpz, c::Int)   Return the floor of the logarithm of  x  to base  c .   source  #  Nemo.clog     Method .  clog(x::fmpz, c::fmpz)   Return the ceiling of the logarithm of  x  to base  c .   source  #  Nemo.clog     Method .  clog(x::fmpz, c::Int)   Return the ceiling of the logarithm of  x  to base  c .   source  Here are some examples of computing integer logarithms.  a = fmpz(12)\nb = fmpz(2)\n\nc = flog(a, b)\nd = clog(a, 3)", 
            "title": "Integer logarithm"
        }, 
        {
            "location": "/integer/#gcd-and-lcm", 
            "text": "#  Base.gcd     Method .  gcd(x::fmpz, y::fmpz)   Return the greatest common divisor of  x  and  y . The returned result will always be nonnegative and will be zero iff  x  and  y  are zero.   source  #  Base.gcd     Method .  gcd(x::Array{fmpz, 1})   Return the greatest common divisor of the elements of  x . The returned result will always be nonnegative and will be zero iff all elements of  x  are zero.   source  #  Base.lcm     Method .  lcm(x::fmpz, y::fmpz)   Return the least common multiple of  x  and  y . The returned result will always be nonnegative and will be zero iff  x  and  y  are zero.   source  #  Base.lcm     Method .  lcm(x::Array{fmpz, 1})   Return the least common multiple of the elements of  x . The returned result will always be nonnegative and will be zero iff the elements of  x  are zero.   source  #  Base.gcdx     Method .  gcdx(a::fmpz, b::fmpz)   Return a tuple  g, s, t  such that  g  is the greatest common divisor of  a  and  b  and integers  s  and  t  such that  g = as + bt .   source  #  Nemo.gcdinv     Method .  gcdinv(a::fmpz, b::fmpz)   Return a tuple  g, s  where  g  is the greatest common divisor of  a  and  b  and where  s  is the inverse of  a  modulo  b  if  g = 1 . This function can be used to detect impossible inverses, i.e. where  a  and  b  are not coprime, and to yield the common factor of  a  and  b  if they are not coprime. We require  b \\geq a \\geq 0 .   source  Here are some examples of GCD and LCM.  a = ZZ(3)\nb = ZZ(12)\n\nc = gcd(a, b)\nd = lcm(a, b)\ng, s, t = gcdx(a, b)\ng, s = gcdinv(a, b)", 
            "title": "GCD and LCM"
        }, 
        {
            "location": "/integer/#integer-roots", 
            "text": "#  Base.isqrt     Method .  isqrt(x::fmpz)   Return the floor of the square root of  x .   source  #  Nemo.isqrtrem     Method .  isqrtrem(x::fmpz)   Return a tuple  s, r  consisting of the floor  s  of the square root of  x  and the remainder  r , i.e. such that  x = s^2 + r . We require  x \\geq 0 .   source  #  Nemo.root     Method .  root(x::fmpz, n::Int)   Return the floor of the  n -the root of  x . We require  n > 0  and that  x \\geq 0  if  n  is even.   source  Here are some examples of integer roots.  a = ZZ(13)\n\nb = sqrt(a)\ns, r = sqrtrem(a)\nc = root(a, 3)", 
            "title": "Integer roots"
        }, 
        {
            "location": "/integer/#number-theoretic-functionality", 
            "text": "#  Nemo.divisible     Method .  divisible(x::fmpz, y::Int)   Return  true  if  x  is divisible by  y , otherwise return  false . We require  x \\neq 0 .   source  #  Nemo.divisible     Method .  divisible(x::fmpz, y::fmpz)   Return  true  if  x  is divisible by  y , otherwise return  false . We require  x \\neq 0 .   source  #  Nemo.issquare     Method .  issquare(x::fmpz)   Return  true  if  x  is a square, otherwise return  false .   source  isprime(::UInt)\nisprime(::fmpz)  #  Nemo.isprobabprime     Method .  isprobabprime(x::fmpz)   Return  true  if  x  is a very probably a prime number, otherwise return  false . No counterexamples are known to this test, but it is conjectured that infinitely many exist.   source  factor(::fmpz)  remove(::fmpz, y:fmpz)  #  Nemo.divisor_lenstra     Method .  divisor_lenstra(n::fmpz, r::fmpz, m::fmpz)   If  n  has a factor which lies in the residue class  r (\\mod m)  for  0 < r < m < n , this function returns such a factor. Otherwise it returns  0 . This is only efficient if  m  is at least the cube root of  n . We require gcd (r, m) = 1  and this condition is not checked.   source  #  Nemo.fac     Method .  fac(x::Int)   Return the factorial of  x , i.e.  x! = 1.2.3\\ldots x . We require  x \\geq 0 .   source  #  Nemo.risingfac     Method .  risingfac(x::fmpz, y::Int)   Return the rising factorial of  x , i.e.  x(x + 1)(x + 2)\\ldots (x + n - 1) . If  n < 0  we throw a  DomainError() .   source  #  Nemo.risingfac     Method .  risingfac(x::Int, y::Int)   Return the rising factorial of  x , i.e.  x(x + 1)(x + 2)\\ldots (x + n - 1) . If  n < 0  we throw a  DomainError() .   source  #  Nemo.primorial     Method .  primorial(x::Int)   Return the primorial of  n , i.e. the product of all primes less than or equal to  n . If  n < 0  we throw a  DomainError() .   source  #  Nemo.fib     Method .  fib(x::Int)   Return the  n -th Fibonacci number  F_n . We define  F_1 = 1 ,  F_2 = 1  and  F_{i + 1} = F_i + F_{i - 1}  for all  i > 2 . We require  n \\geq 0 . For convenience, we define  F_0 = 0 .   source  #  Nemo.bell     Method .  bell(x::Int)   Return the Bell number  B_n .   source  #  Nemo.binom     Method .  binom(n::Int, k::Int)   Return the binomial coefficient  \\frac{n!}{(n - k)!k!} . If  n, k < 0  or  k > n  we return  0 .   source  #  Nemo.moebiusmu     Method .  moebiusmu(x::fmpz)   Returns the Moebius mu function of  x  as an \\code{Int}. The value returned is either  -1 ,  0  or  1 . If  x < 0  we throw a  DomainError() .   source  #  Nemo.jacobi     Method .  jacobi(x::fmpz, y::fmpz)   Return the value of the Jacobi symbol  \\left(\\frac{x}{y}\\right) . If  y \\leq x  or  x < 0 , we throw a  DomainError() .   source  #  Nemo.sigma     Method .  sigma(x::fmpz, y::Int)   Return the value of the sigma function, i.e.  \\sum_{0 < d \\;| x} d^y . If  y < 0  we throw a  DomainError() .   source  #  Nemo.eulerphi     Method .  eulerphi(x::fmpz)   Return the value of the Euler phi function at  x , i.e. the number of positive integers less than  x  that are coprime with  x .   source  #  Nemo.numpart     Method .  numpart(x::Int)   Return the number of partitions of  x . This function is not available on Windows 64.   source  #  Nemo.numpart     Method .  numpart(x::fmpz)   Return the number of partitions of  x . This function is not available on Windows 64.   source  Here are some examples of number theoretic functionality.  isprime(ZZ(13))\nn = fac(100)\ns = sigma(ZZ(128), 10)\na = eulerphi(ZZ(12480))\np = numpart(1000)\nf = factor(ZZ(12))", 
            "title": "Number theoretic functionality"
        }, 
        {
            "location": "/integer/#number-digits-and-bases", 
            "text": "#  Base.bin     Method .  bin(n::fmpz)   Return  n  as a binary string.   source  #  Base.oct     Method .  oct(n::fmpz)   Return  n  as a octal string.   source  #  Base.dec     Method .  dec(n::fmpz)   Return  n  as a decimal string.   source  #  Base.hex     Method .  hex(n::fmpz) = base(n, 16)   Return  n  as a hexadecimal string.   source  #  Base.base     Method .  base(n::fmpz, b::Integer)   Return  n  as a string in base  b . We require  2 \\leq b \\leq 62 .   source  #  Base.ndigits     Method .  ndigits(x::fmpz, b::Integer = 10)   Return the number of digits of  x  in the base  b  (default is  b = 10 ).   source  #  Nemo.nbits     Method .  nbits(x::fmpz)   Return the number of binary bits of  x . We return zero if  x = 0 .   source  Here are some examples of writing numbers in various bases.  a = fmpz(12)\n\ns1 = bin(a)\ns2 = base(a, 13)\nn1 = nbits(a)\nn2 = ndigits(a, 3)", 
            "title": "Number digits and bases"
        }, 
        {
            "location": "/integer/#bit-twiddling", 
            "text": "#  Nemo.popcount     Method .  popcount(x::fmpz)   Return the number of ones in the binary representation of  x .   source  #  Base.prevpow2     Method .  prevpow2(x::fmpz)   Return the previous power of  2  up to including  x .   source  #  Base.nextpow2     Method .  nextpow2(x::fmpz)   Return the next power of  2  that is at least  x .   source  #  Base.trailing_zeros     Method .  trailing_zeros(x::fmpz)   Count the trailing zeros in the binary representation of  x .   source  #  Nemo.clrbit!     Method .  clrbit!(x::fmpz, c::Int)   Clear bit  c  of  x , where the least significant bit is the  0 -th bit. Note that this function modifies its input in-place.   source  #  Nemo.setbit!     Method .  setbit!(x::fmpz, c::Int)   Set bit  c  of  x , where the least significant bit is the  0 -th bit. Note that this function modifies its input in-place.   source  #  Nemo.combit!     Method .  combit!(x::fmpz, c::Int)   Complement bit  c  of  x , where the least significant bit is the  0 -th bit. Note that this function modifies its input in-place.   source  Here are some examples of bit twiddling.  a = fmpz(12)\n\np = popcount(a)\nb = nextpow2(a)\ncombit!(a, 2)", 
            "title": "Bit twiddling"
        }, 
        {
            "location": "/rational/", 
            "text": "Introduction\n\n\nNemo provides much functionality for the rational numbers. See the section on Fraction Fields where all the basic functionality is documented, along with the extra functionality only available for the rational numbers themselves.", 
            "title": "Rationals"
        }, 
        {
            "location": "/rational/#introduction", 
            "text": "Nemo provides much functionality for the rational numbers. See the section on Fraction Fields where all the basic functionality is documented, along with the extra functionality only available for the rational numbers themselves.", 
            "title": "Introduction"
        }, 
        {
            "location": "/finitefield/", 
            "text": "Introduction\n\n\nFinite fields are provided in Nemo by Flint. This allows construction of finite fields of any characteristic and degree for which there are Conway polynomials. It is also possible for the user to specify their own irreducible polynomial generating a finite field.\n\n\nFinite fields are constructed using the \nFlintFiniteField\n function. However, for convenience we define\n\n\nFiniteField = FlintFiniteField\n\n\n\n\nso that finite fields can be constructed using \nFiniteField\n rather than \nFlintFiniteField\n. Note that this is the name of the constructor, but not of finite field type.\n\n\nThe types of finite field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.\n\n\n\n\n\n\n\n\nLibrary\n\n\nField\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nFlint\n\n\n\n\n\\mathbb{F}_{p^n}\n (small \np\n)\n\n\nfq_nmod\n\n\nFqNmodFiniteField\n\n\n\n\n\n\nFlint\n\n\n\n\n\\mathbb{F}_{p^n}\n (large \np\n)\n\n\nfq\n\n\nFqFiniteField\n\n\n\n\n\n\n\n\nThe only difference between the \nfq\n and \nfq_nmod\n types is the representation. The former is for finite fields with multiprecision characteristic and the latter is for characteristics that fit into a single unsigned machine word. The \nFlintFiniteField\n constructor automatically picks the correct representation for the user, and so the average user doesn't need to know about the actual types.\n\n\nAll the finite field types belong to the \nFinField\n abstract type and the finite field element types belong to the \nFinFieldElem\n abstract type.\n\n\nSince all the functionality for the \nfq\n finite field type is identical to that provided for the \nfq_nmod\n finite field type, we simply document the former.\n\n\n\n\nFinite field constructors\n\n\nIn order to construct finite field elements in Nemo, one must first construct the finite field itself. This is accomplished with one of the following constructors.\n\n\n#\n\n\nNemo.FlintFiniteField\n \n \nMethod\n.\n\n\nFlintFiniteField(char::fmpz, deg::Int, s::AbstractString)\n\n\n\n\n\n\nReturns a tuple \nS, x\n consisting of a finite field parent object \nS\n and generator \nx\n for the finite field of the given characteristic and degree. The string \ns\n is used to designate how the finite field generator will be printed. The characteristic must be prime. When a Conway polynomial is known, the field is generated using the Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. The generator of the field is  guaranteed to be a multiplicative generator only if the field is generated by a Conway polynomial. We require the degree to be positive.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.FlintFiniteField\n \n \nMethod\n.\n\n\nFlintFiniteField(char::Integer, deg::Int, s::AbstractString)\n\n\n\n\n\n\nReturns a tuple \nS, x\n consisting of a finite field parent object \nS\n and generator \nx\n for the finite field of the given characteristic and degree. The string \ns\n is used to designate how the finite field generator will be printed. The characteristic must be prime. When a Conway polynomial is known, the field is generated using the Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. The generator of the field is  guaranteed to be a multiplicative generator only if the field is generated by a Conway polynomial. We require the degree to be positive.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.FlintFiniteField\n \n \nMethod\n.\n\n\nFlintFiniteField(pol::fmpz_mod_poly, s::AbstractString)\n\n\n\n\n\n\nReturns a tuple \nS, x\n consisting of a finite field parent object \nS\n and generator \nx\n for the finite field over \nF_p\n defined by the given polynomial, i.e. \n\\mathbb{F}_p[t]/(pol)\n. The characteristic is specified by the modulus of \npol\n. The polynomial is required to be irreducible, but this is not checked. The string \ns\n is used to designate how the finite field generator will be printed. The generator will not be multiplicative in general.\n\n\n\n\nsource\n\n\nHere are some examples of creating finite fields and making use of the resulting parent objects to coerce various elements into those fields.\n\n\nR, x = FiniteField(7, 3, \nx\n)\nS, y = FiniteField(ZZ(12431351431561), 2, \ny\n)\nT, t = PolynomialRing(ResidueRing(ZZ, 12431351431561), \nt\n)\nU, z = FiniteField(t^2 + 7, \nz\n)\n\na = R(5)\nb = R(x)\nc = S(ZZ(11))\nd = U(7)\n\n\n\n\n\n\nFinite field element constructors\n\n\nOnce a finite field is constructed, there are various ways to construct elements in that field.\n\n\nApart from coercing elements into the finite field as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(a::FqFiniteField)\n\n\n\n\n\n\nReturn the additive identity, zero, in the given finite field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(a::FqFiniteField)\n\n\n\n\n\n\nReturn the multiplicative identity, one, in the given finite field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gen\n \n \nMethod\n.\n\n\ngen(a::FqFiniteField)\n\n\n\n\n\n\nReturn the generator of the finite field. Note that this is only guaranteed to be a multiplicative generator if the finite field is generated by a Conway polynomial automatically.\n\n\n\n\nsource\n\n\nHere are some examples of constructing finite field elements.\n\n\nR, x = FiniteField(ZZ(7), 5, \nx\n)\n\na = zero(R)\nb = one(R)\nc = gen(R)\n\n\n\n\n\n\nBasic functionality\n\n\nThe following basic functionality is provided by the default finite field implementation in Nemo, to support construction of generic rings over finite fields. Any custom finite field implementation in Nemo should provide these  functions along with the usual arithmetic operations.\n\n\nparent_type(::Type{fq})\n\n\n\n\nGives the type of the parent object of a Flint finite field element.\n\n\nelem_type(R::FqFiniteField)\n\n\n\n\nGiven the parent object for a finite field, return the type of elements of the field.\n\n\nBase.hash(a::fq, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the finite field element \na\n. This should be xor'd with a fixed random hexadecimal specific to the finite field type. The hash of the coefficients of the finite field representation should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndeepcopy(a::fq)\n\n\n\n\nConstruct a copy of the given finite field element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo finite field elements are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::fq, a::fq, b::fq)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing finite field element \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::fq, a::fq)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven the parent object \nR\n for a finite field, the following coercion functions are provided to coerce various elements into the finite field. Developers provide these by overloading the \ncall\n operator for the finite field parent objects.\n\n\nR()\n\n\n\n\nCoerce zero into the finite field.\n\n\nR(n::Integer)\nR(f::fmpz)\n\n\n\n\nCoerce an integer value into the finite field.\n\n\nR(f::fq)\n\n\n\n\nTake a finite field element that is already in the finite field and simply return it. A copy of the original is not made.\n\n\nIn addition to the above, developers of custom finite field types must ensure that they provide the equivalent of the function \nbase_ring(R::FqFiniteField)\n which should return \nUnion{}\n. In addition to this they should ensure that each finite field element contains a field \nparent\n specifying the parent object of the finite field element, or at least supply the equivalent of the function \nparent(a::fq)\n to return the parent object of a finite field element.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate finite field elements. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::FqFiniteField)\n\n\n\n\n\n\nReturns \nUnion{}\n as this field is not dependent on another field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::fq)\n\n\n\n\n\n\nReturns \nUnion{}\n as this field is not dependent on another field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::fq)\n\n\n\n\n\n\nReturns the parent of the given finite field element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::fq)\n\n\n\n\n\n\nReturn \ntrue\n if the given finite field element is zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::fq)\n\n\n\n\n\n\nReturn \ntrue\n if the given finite field element is one, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::fq)\n\n\n\n\n\n\nReturn \ntrue\n if the given finite field element is invertible, i.e. nonzero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isgen\n \n \nMethod\n.\n\n\nisgen(a::fq)\n\n\n\n\n\n\nReturn \ntrue\n if the given finite field element is the generator of the finite field, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.coeff\n \n \nMethod\n.\n\n\ncoeff(x::fq, n::Int)\n\n\n\n\n\n\nReturn the degree \nn\n coefficient of the polynomial representing the given finite field element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.degree\n \n \nMethod\n.\n\n\ndegree(a::FqFiniteField)\n\n\n\n\n\n\nReturn the degree of the given finite field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.characteristic\n \n \nMethod\n.\n\n\ncharacteristic(a::FqFiniteField)\n\n\n\n\n\n\nReturn the characteristic of the given finite field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.order\n \n \nMethod\n.\n\n\norder(a::FqFiniteField)\n\n\n\n\n\n\nReturn the order, i.e. the number of elements in, the given finite field.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of finite field elements.\n\n\nR, x = FiniteField(ZZ(7), 5, \nx\n)\n\na = zero(R)\nb = one(R)\nc = gen(R)\n\nd = characteristic(R)\nf = order(R)\ng = degree(R)\nh = iszero(a)\nk = isone(b)\nm = isunit(x + 1)\nn = isgen(x)\nU = parent(x + 1)\nV = base_ring(R)\n\n\n\n\n\n\nArithmetic operations\n\n\nNemo provides all the standard field operations for finite field elements, as follows.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::fq)\n\n\nunary minus\n\n\n\n\n\n\n+(a::fq, b::fq)\n\n\naddition\n\n\n\n\n\n\n-(a::fq, b::fq)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::fq, b::fq)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::fq, b::fq)\n\n\nexact division\n\n\n\n\n\n\n\n\nIn addition, the following ad hoc field operations are defined.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::fq, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::Integer, b::fq)\n\n\naddition\n\n\n\n\n\n\n+(a::fq, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::fq)\n\n\naddition\n\n\n\n\n\n\n-(a::fq, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::Integer, b::fq)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fq, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::fq)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::fq, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::Integer, b::fq)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fq, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::fq)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::fq, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::fq, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::Integer, b::fq)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::fmpz, b::fq)\n\n\nexact division\n\n\n\n\n\n\n^(a::fq, b::Int)\n\n\npowering\n\n\n\n\n\n\n^(a::fq, b::fmpz)\n\n\npowering\n\n\n\n\n\n\n\n\nHere are some examples of arithmetic operations on finite fields.\n\n\nR, x = FiniteField(ZZ(7), 5, \nx\n)\n\na = x^4 + 3x^2 + 6x + 1\nb = 3x^4 + 2x^2 + x + 1\n\nc = a + b\nd = a - b\nf = a*b\ng = 3a\nh = b*ZZ(5)\nk = divexact(a, b)\nm = divexact(1, b)\nn = divexact(a, ZZ(2))\np = a^3\n\n\n\n\n\n\nComparison\n\n\nNemo provides the comparison operation \n==\n for finite field elements. Julia then automatically provides the corresponding \n!=\n operation. Here are the functions provided.\n\n\n\n\nFunction\n\n\n==(a::fq, b::fq)\n\n\nIn addition, the following ad hoc comparisons are provided, Julia again providing the corresponding \n!=\n operators.\n\n\n\n\nFunction\n\n\n==(a::fq, b::Integer) ==(a::fq, b::fmpz) ==(a::Integer, b::fq) ==(a::fmpz, b::fq)\n\n\nHere are some examples of comparisons.\n\n\nR, x = FiniteField(ZZ(7), 5, \nx\n)\n\na = x^4 + 3x^2 + 6x + 1\nb = 3x^4 + 2x^2 + 2\n\nb != a\na == 3\nZZ(5) == b\n\n\n\n\n\n\nInversion\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(x::fq)\n\n\n\n\n\n\nReturn \nx^{-1}\n.\n\n\n\n\nsource\n\n\nHere are some examples of inversion.\n\n\nR, x = FiniteField(ZZ(7), 5, \nx\n)\n\na = x^4 + 3x^2 + 6x + 1\n\nb = inv(a)\n\n\n\n\n\n\nSpecial functions\n\n\nVarious special functions with finite field specific behaviour are defined.\n\n\n#\n\n\nBase.LinAlg.trace\n \n \nMethod\n.\n\n\ntrace(x::fq)\n\n\n\n\n\n\nReturn the trace of \na\n. This is an element of \n\\F_p\n, but the value returned is this value embedded in the original finite field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.norm\n \n \nMethod\n.\n\n\nnorm(x::fq)\n\n\n\n\n\n\nReturn the norm of \na\n. This is an element of \n\\F_p\n, but the value returned is this value embedded in the original finite field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.frobenius\n \n \nMethod\n.\n\n\nfrobenius(x::fq, n = 1)\n\n\n\n\n\n\nReturn the iterated Frobenius \n\\sigma_p^n(a)\n where \n\\sigma_p\n is the  Frobenius map sending the element \na\n to \na^p\n in the finite field of  characteristic \np\n. By default the Frobenius map is applied \nn = 1\n times if \nn\n is not specified.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.pth_root\n \n \nMethod\n.\n\n\npth_root(x::fq)\n\n\n\n\n\n\nReturn the \np\n-th root of \na\n in the finite field of characteristic \np\n. This is the inverse operation to the Frobenius map \n\\sigma_p\n.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\nR, x = FiniteField(ZZ(7), 5, \nx\n)\n\na = x^4 + 3x^2 + 6x + 1\n\nb = trace(a)\nc = norm(a)\nd = frobenius(a)\nf = frobenius(a, 3)\ng = pth_root(a)", 
            "title": "Finite fields"
        }, 
        {
            "location": "/finitefield/#introduction", 
            "text": "Finite fields are provided in Nemo by Flint. This allows construction of finite fields of any characteristic and degree for which there are Conway polynomials. It is also possible for the user to specify their own irreducible polynomial generating a finite field.  Finite fields are constructed using the  FlintFiniteField  function. However, for convenience we define  FiniteField = FlintFiniteField  so that finite fields can be constructed using  FiniteField  rather than  FlintFiniteField . Note that this is the name of the constructor, but not of finite field type.  The types of finite field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.     Library  Field  Element type  Parent type      Flint   \\mathbb{F}_{p^n}  (small  p )  fq_nmod  FqNmodFiniteField    Flint   \\mathbb{F}_{p^n}  (large  p )  fq  FqFiniteField     The only difference between the  fq  and  fq_nmod  types is the representation. The former is for finite fields with multiprecision characteristic and the latter is for characteristics that fit into a single unsigned machine word. The  FlintFiniteField  constructor automatically picks the correct representation for the user, and so the average user doesn't need to know about the actual types.  All the finite field types belong to the  FinField  abstract type and the finite field element types belong to the  FinFieldElem  abstract type.  Since all the functionality for the  fq  finite field type is identical to that provided for the  fq_nmod  finite field type, we simply document the former.", 
            "title": "Introduction"
        }, 
        {
            "location": "/finitefield/#finite-field-constructors", 
            "text": "In order to construct finite field elements in Nemo, one must first construct the finite field itself. This is accomplished with one of the following constructors.  #  Nemo.FlintFiniteField     Method .  FlintFiniteField(char::fmpz, deg::Int, s::AbstractString)   Returns a tuple  S, x  consisting of a finite field parent object  S  and generator  x  for the finite field of the given characteristic and degree. The string  s  is used to designate how the finite field generator will be printed. The characteristic must be prime. When a Conway polynomial is known, the field is generated using the Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. The generator of the field is  guaranteed to be a multiplicative generator only if the field is generated by a Conway polynomial. We require the degree to be positive.   source  #  Nemo.FlintFiniteField     Method .  FlintFiniteField(char::Integer, deg::Int, s::AbstractString)   Returns a tuple  S, x  consisting of a finite field parent object  S  and generator  x  for the finite field of the given characteristic and degree. The string  s  is used to designate how the finite field generator will be printed. The characteristic must be prime. When a Conway polynomial is known, the field is generated using the Conway polynomial. Otherwise a random sparse, irreducible polynomial is used. The generator of the field is  guaranteed to be a multiplicative generator only if the field is generated by a Conway polynomial. We require the degree to be positive.   source  #  Nemo.FlintFiniteField     Method .  FlintFiniteField(pol::fmpz_mod_poly, s::AbstractString)   Returns a tuple  S, x  consisting of a finite field parent object  S  and generator  x  for the finite field over  F_p  defined by the given polynomial, i.e.  \\mathbb{F}_p[t]/(pol) . The characteristic is specified by the modulus of  pol . The polynomial is required to be irreducible, but this is not checked. The string  s  is used to designate how the finite field generator will be printed. The generator will not be multiplicative in general.   source  Here are some examples of creating finite fields and making use of the resulting parent objects to coerce various elements into those fields.  R, x = FiniteField(7, 3,  x )\nS, y = FiniteField(ZZ(12431351431561), 2,  y )\nT, t = PolynomialRing(ResidueRing(ZZ, 12431351431561),  t )\nU, z = FiniteField(t^2 + 7,  z )\n\na = R(5)\nb = R(x)\nc = S(ZZ(11))\nd = U(7)", 
            "title": "Finite field constructors"
        }, 
        {
            "location": "/finitefield/#finite-field-element-constructors", 
            "text": "Once a finite field is constructed, there are various ways to construct elements in that field.  Apart from coercing elements into the finite field as above, we offer the following functions.  #  Base.zero     Method .  zero(a::FqFiniteField)   Return the additive identity, zero, in the given finite field.   source  #  Base.one     Method .  one(a::FqFiniteField)   Return the multiplicative identity, one, in the given finite field.   source  #  Nemo.gen     Method .  gen(a::FqFiniteField)   Return the generator of the finite field. Note that this is only guaranteed to be a multiplicative generator if the finite field is generated by a Conway polynomial automatically.   source  Here are some examples of constructing finite field elements.  R, x = FiniteField(ZZ(7), 5,  x )\n\na = zero(R)\nb = one(R)\nc = gen(R)", 
            "title": "Finite field element constructors"
        }, 
        {
            "location": "/finitefield/#basic-functionality", 
            "text": "The following basic functionality is provided by the default finite field implementation in Nemo, to support construction of generic rings over finite fields. Any custom finite field implementation in Nemo should provide these  functions along with the usual arithmetic operations.  parent_type(::Type{fq})  Gives the type of the parent object of a Flint finite field element.  elem_type(R::FqFiniteField)  Given the parent object for a finite field, return the type of elements of the field.  Base.hash(a::fq, h::UInt)  Return a  UInt  hexadecimal hash of the finite field element  a . This should be xor'd with a fixed random hexadecimal specific to the finite field type. The hash of the coefficients of the finite field representation should be xor'd with the supplied parameter  h  as part of computing the hash.  deepcopy(a::fq)  Construct a copy of the given finite field element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo finite field elements are mutable and so returning shallow copies is not sufficient.  mul!(c::fq, a::fq, b::fq)  Multiply  a  by  b  and set the existing finite field element  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::fq, a::fq)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given the parent object  R  for a finite field, the following coercion functions are provided to coerce various elements into the finite field. Developers provide these by overloading the  call  operator for the finite field parent objects.  R()  Coerce zero into the finite field.  R(n::Integer)\nR(f::fmpz)  Coerce an integer value into the finite field.  R(f::fq)  Take a finite field element that is already in the finite field and simply return it. A copy of the original is not made.  In addition to the above, developers of custom finite field types must ensure that they provide the equivalent of the function  base_ring(R::FqFiniteField)  which should return  Union{} . In addition to this they should ensure that each finite field element contains a field  parent  specifying the parent object of the finite field element, or at least supply the equivalent of the function  parent(a::fq)  to return the parent object of a finite field element.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/finitefield/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate finite field elements. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(a::FqFiniteField)   Returns  Union{}  as this field is not dependent on another field.   source  #  Nemo.base_ring     Method .  base_ring(a::fq)   Returns  Union{}  as this field is not dependent on another field.   source  #  Base.parent     Method .  parent(a::fq)   Returns the parent of the given finite field element.   source  #  Nemo.iszero     Method .  iszero(a::fq)   Return  true  if the given finite field element is zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::fq)   Return  true  if the given finite field element is one, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::fq)   Return  true  if the given finite field element is invertible, i.e. nonzero, otherwise return  false .   source  #  Nemo.isgen     Method .  isgen(a::fq)   Return  true  if the given finite field element is the generator of the finite field, otherwise return  false .   source  #  Nemo.coeff     Method .  coeff(x::fq, n::Int)   Return the degree  n  coefficient of the polynomial representing the given finite field element.   source  #  Nemo.degree     Method .  degree(a::FqFiniteField)   Return the degree of the given finite field.   source  #  Nemo.characteristic     Method .  characteristic(a::FqFiniteField)   Return the characteristic of the given finite field.   source  #  Nemo.order     Method .  order(a::FqFiniteField)   Return the order, i.e. the number of elements in, the given finite field.   source  Here are some examples of basic manipulation of finite field elements.  R, x = FiniteField(ZZ(7), 5,  x )\n\na = zero(R)\nb = one(R)\nc = gen(R)\n\nd = characteristic(R)\nf = order(R)\ng = degree(R)\nh = iszero(a)\nk = isone(b)\nm = isunit(x + 1)\nn = isgen(x)\nU = parent(x + 1)\nV = base_ring(R)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/finitefield/#arithmetic-operations", 
            "text": "Nemo provides all the standard field operations for finite field elements, as follows.     Function  Operation      -(a::fq)  unary minus    +(a::fq, b::fq)  addition    -(a::fq, b::fq)  subtraction    *(a::fq, b::fq)  multiplication    divexact(a::fq, b::fq)  exact division     In addition, the following ad hoc field operations are defined.     Function  Operation      +(a::fq, b::Integer)  addition    +(a::Integer, b::fq)  addition    +(a::fq, b::fmpz)  addition    +(a::fmpz, b::fq)  addition    -(a::fq, b::Integer)  subtraction    -(a::Integer, b::fq)  subtraction    -(a::fq, b::fmpz)  subtraction    -(a::fmpz, b::fq)  subtraction    *(a::fq, b::Integer)  multiplication    *(a::Integer, b::fq)  multiplication    *(a::fq, b::fmpz)  multiplication    *(a::fmpz, b::fq)  multiplication    divexact(a::fq, b::Integer)  exact division    divexact(a::fq, b::fmpz)  exact division    divexact(a::Integer, b::fq)  exact division    divexact(a::fmpz, b::fq)  exact division    ^(a::fq, b::Int)  powering    ^(a::fq, b::fmpz)  powering     Here are some examples of arithmetic operations on finite fields.  R, x = FiniteField(ZZ(7), 5,  x )\n\na = x^4 + 3x^2 + 6x + 1\nb = 3x^4 + 2x^2 + x + 1\n\nc = a + b\nd = a - b\nf = a*b\ng = 3a\nh = b*ZZ(5)\nk = divexact(a, b)\nm = divexact(1, b)\nn = divexact(a, ZZ(2))\np = a^3", 
            "title": "Arithmetic operations"
        }, 
        {
            "location": "/finitefield/#comparison", 
            "text": "Nemo provides the comparison operation  ==  for finite field elements. Julia then automatically provides the corresponding  !=  operation. Here are the functions provided.", 
            "title": "Comparison"
        }, 
        {
            "location": "/finitefield/#function", 
            "text": "==(a::fq, b::fq)  In addition, the following ad hoc comparisons are provided, Julia again providing the corresponding  !=  operators.", 
            "title": "Function"
        }, 
        {
            "location": "/finitefield/#function_1", 
            "text": "==(a::fq, b::Integer) ==(a::fq, b::fmpz) ==(a::Integer, b::fq) ==(a::fmpz, b::fq)  Here are some examples of comparisons.  R, x = FiniteField(ZZ(7), 5,  x )\n\na = x^4 + 3x^2 + 6x + 1\nb = 3x^4 + 2x^2 + 2\n\nb != a\na == 3\nZZ(5) == b", 
            "title": "Function"
        }, 
        {
            "location": "/finitefield/#inversion", 
            "text": "#  Base.inv     Method .  inv(x::fq)   Return  x^{-1} .   source  Here are some examples of inversion.  R, x = FiniteField(ZZ(7), 5,  x )\n\na = x^4 + 3x^2 + 6x + 1\n\nb = inv(a)", 
            "title": "Inversion"
        }, 
        {
            "location": "/finitefield/#special-functions", 
            "text": "Various special functions with finite field specific behaviour are defined.  #  Base.LinAlg.trace     Method .  trace(x::fq)   Return the trace of  a . This is an element of  \\F_p , but the value returned is this value embedded in the original finite field.   source  #  Base.LinAlg.norm     Method .  norm(x::fq)   Return the norm of  a . This is an element of  \\F_p , but the value returned is this value embedded in the original finite field.   source  #  Nemo.frobenius     Method .  frobenius(x::fq, n = 1)   Return the iterated Frobenius  \\sigma_p^n(a)  where  \\sigma_p  is the  Frobenius map sending the element  a  to  a^p  in the finite field of  characteristic  p . By default the Frobenius map is applied  n = 1  times if  n  is not specified.   source  #  Nemo.pth_root     Method .  pth_root(x::fq)   Return the  p -th root of  a  in the finite field of characteristic  p . This is the inverse operation to the Frobenius map  \\sigma_p .   source  Here are some examples of special functions.  R, x = FiniteField(ZZ(7), 5,  x )\n\na = x^4 + 3x^2 + 6x + 1\n\nb = trace(a)\nc = norm(a)\nd = frobenius(a)\nf = frobenius(a, 3)\ng = pth_root(a)", 
            "title": "Special functions"
        }, 
        {
            "location": "/padic/", 
            "text": "Introduction\n\n\nP-adic fields are provided in Nemo by Flint. This allows construction of \np\n-adic fields for any prime \np\n.\n\n\nP-adic fields are constructed using the \nFlintPadicField\n function. However, for convenience we define\n\n\nPadicField = FlintPadicField\n\n\n\n\nso that \np\n-adic fields can be constructed using \nPadicField\n rather than \nFlintPadicField\n. Note that this is the name of the constructor, but not of padic field type.\n\n\nThe types of \np\n-adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.\n\n\n\n\n\n\n\n\nLibrary\n\n\nField\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nFlint\n\n\n\n\n\\mathbb{Q}_p\n\n\n\n\npadic\n\n\nPadicField\n\n\n\n\n\n\n\n\nAll the \np\n-adic field types belong to the \nField\n abstract type and the \np\n-adic field element types belong to the \nFieldElem\n abstract type.\n\n\n\n\nP-adic field constructors\n\n\nIn order to construct \np\n-adic field elements in Nemo, one must first construct the \np\n-adic field itself. This is accomplished with one of the following constructors.\n\n\n#\n\n\nNemo.FlintPadicField\n \n \nMethod\n.\n\n\nFlintPadicField(p::Integer, prec::Int)\n\n\n\n\n\n\nReturns the parent object for the \np\n-adic field for given prime \np\n, where the default absolute precision of elements of the field is given by \nprec\n.\n\n\n\n\nsource\n\n\nIt is also possible to call the inner constructor directly. It has the following form.\n\n\nFlintPadicField(p::fmpz, prec::Int)\n\n\n\n\nReturns the parent object for the \np\n-adic field for given prime \np\n, where the default absolute precision of elements of the field is given by \nprec\n.\n\n\nHere are some examples of creating \np\n-adic fields and making use of the resulting parent objects to coerce various elements into those fields.\n\n\nR = PadicField(7, 30)\nS = PadicField(ZZ(65537), 30)\n\na = R()\nb = S(1)\nc = S(ZZ(123))\nd = R(ZZ(1)//7^2)\n\n\n\n\n\n\nP-adic field element constructors\n\n\nOnce a \np\n-adic field is constructed, there are various ways to construct elements in that field.\n\n\nApart from coercing elements into the \np\n-adic field as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::FlintPadicField)\n\n\n\n\n\n\nReturn zero in the given \np\n-adic field, to the default precision.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::FlintPadicField)\n\n\n\n\n\n\nReturn zero in the given \np\n-adic field, to the default precision.\n\n\n\n\nsource\n\n\nElements can also be constructed using the big-oh notation. For this purpose we define the following functions.\n\n\n#\n\n\nNemo.O\n \n \nMethod\n.\n\n\nO(R::FlintPadicField, m::Integer)\n\n\n\n\n\n\nConstruct the value \n0 + O(p^n)\n given \nm = p^n\n. An exception results if \nm\n is not found to be a power of \np = prime(R)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.O\n \n \nMethod\n.\n\n\nO(R::FlintPadicField, m::fmpz)\n\n\n\n\n\n\nConstruct the value \n0 + O(p^n)\n given \nm = p^n\n. An exception results if \nm\n is not found to be a power of \np = prime(R)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.O\n \n \nMethod\n.\n\n\nO(R::FlintPadicField, m::fmpq)\n\n\n\n\n\n\nConstruct the value \n0 + O(p^n)\n given \nm = p^n\n. An exception results if \nm\n is not found to be a power of \np = prime(R)\n.\n\n\n\n\nsource\n\n\nThe \nO(p^n)\n construction can be used to construct \np\n-adic values of precision \nn\n by adding it to integer values representing the \np\n-adic value modulo \np^n\n as in the examples.\n\n\nHere are some examples of constructing \np\n-adic field elements.\n\n\nR = PadicField(7, 30)\nS = PadicField(fmpz(65537), 30)\n\na = one(R)\nb = zero(S)\nc = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nd = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\nf = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)\n\n\n\n\nBeware that the expression \n1 + 2*p + 3*p^2 + O(R, p^n)\n is actually computed as a normal Julia expression. Therefore if \\code{Int} values are used instead of Flint integers or Julia bignums, overflow may result in evaluating the value.\n\n\n\n\nBasic functionality\n\n\nThe following basic functionality is provided by the default \np\n-adic field implementation in Nemo, to support construction of generic rings over \np\n-adic fields. Any custom \np\n-adic field implementation in Nemo should provide these  functions along with the usual arithmetic operations.\n\n\nparent_type(::Type{padic})\n\n\n\n\nGives the type of the parent object of a Flint \np\n-adic field element.\n\n\nelem_type(R::FlintPadicField)\n\n\n\n\nGiven the parent object for a \np\n-adic field, return the type of elements of the field.\n\n\nBase.hash(a::padic, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the \np\n-adic field element \na\n. This should be xor'd with a fixed random hexadecimal specific to the \np\n-adic field type. The hash of the representative of the \np\n-adic field element (lifted to \n\\mathbb{Q}\n and the prime \np\n for the field, should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndeepcopy(a::padic)\n\n\n\n\nConstruct a copy of the given \np\n-adic field element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo \np\n-adic field elements are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::padic, a::padic, b::padic)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing \np\n-adic field element \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::padic, a::padic)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven the parent object \nR\n for a \np\n-adic field, the following coercion functions are provided to coerce various elements into the \np\n-adic field. Developers provide these by overloading the \ncall\n operator for the \np\n-adic field parent objects.\n\n\nR()\n\n\n\n\nCoerce zero into the \np\n-adic field.\n\n\nR(n::Integer)\nR(f::fmpz)\nR(f::fmpq)\n\n\n\n\nCoerce an integer or rational value into the \np\n-adic field.\n\n\nR(f::padic)\n\n\n\n\nTake a \np\n-adic field element that is already in the \np\n-adic field and simply return it. A copy of the original is not made.\n\n\nIn addition to the above, developers of custom \np\n-adic field types must ensure that they provide the equivalent of the function \nbase_ring(R::FlintPadicField)\n which should return \nUnion{}\n. In addition to this they should ensure that each \np\n-adic field element contains a field \nparent\n specifying the parent object of the \np\n-adic field element, or at least supply the equivalent of the function \nparent(a::padic)\n to return the parent object of a \np\n-adic field element.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate \np\n-adic field elements. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::FlintPadicField)\n\n\n\n\n\n\nReturns \nUnion{}\n as this field is not dependent on another field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::padic)\n\n\n\n\n\n\nReturns \nUnion{}\n as this field is not dependent on another field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::padic)\n\n\n\n\n\n\nReturns the parent of the given p-adic field element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::padic)\n\n\n\n\n\n\nReturn \ntrue\n if the given p-adic field element is zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::padic)\n\n\n\n\n\n\nReturn \ntrue\n if the given p-adic field element is one, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::padic)\n\n\n\n\n\n\nReturn \ntrue\n if the given p-adic field element is invertible, i.e. nonzero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.prime\n \n \nMethod\n.\n\n\nprime(R::FlintPadicField)\n\n\n\n\n\n\nReturn the prime \np\n for the given \np\n-adic field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.precision\n \n \nMethod\n.\n\n\nprecision(a::padic)\n\n\n\n\n\n\nReturn the precision of the given \np\n-adic field element, i.e. if the element is known to \nO(p^n)\n this function will return \nn\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.valuation\n \n \nMethod\n.\n\n\nvaluation(a::padic)\n\n\n\n\n\n\nReturn the valuation of the given \np\n-adic field element, i.e. if the given element is divisible by \np^n\n but not a higher power of \np\n then the function will return \nn\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nlift(R::FlintIntegerRing, a::padic)\n\n\n\n\n\n\nReturn a lift of the given \np\n-adic field element to \n\\mathbb{Z}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nlift(R::FlintRationalField, a::padic)\n\n\n\n\n\n\nReturn a lift of the given \np\n-adic field element to \n\\mathbb{Q}\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of \np\n-adic field elements.\n\n\nR = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = R(2)\n\nd = one(R)\nf = zero(R)\ng = isone(d)\nh = iszero(f)\nk = precision(a)\nm = prime(R)\nn = valuation(b)\np = lift(FlintZZ, a)\nq = lift(FlintQQ, divexact(a, b))\n\n\n\n\n\n\nArithmetic operations\n\n\nNemo provides all the standard field operations for \np\n-adic field elements, as follows.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::padic)\n\n\nunary minus\n\n\n\n\n\n\n+(a::padic, b::padic)\n\n\naddition\n\n\n\n\n\n\n-(a::padic, b::padic)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::padic, b::padic)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::padic, b::padic)\n\n\nexact division\n\n\n\n\n\n\n\n\nIn addition, the following ad hoc field operations are defined.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::padic, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::Integer, b::padic)\n\n\naddition\n\n\n\n\n\n\n+(a::padic, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::padic)\n\n\naddition\n\n\n\n\n\n\n+(a::padic, b::fmpq)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpq, b::padic)\n\n\naddition\n\n\n\n\n\n\n-(a::padic, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::Integer, b::padic)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::padic, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::padic)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::padic, b::fmpq)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpq, b::padic)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::padic, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::Integer, b::padic)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::padic, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::padic)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::padic, b::fmpq)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpq, b::padic)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::padic, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::padic, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::padic, b::fmpq)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::Integer, b::padic)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::fmpz, b::padic)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::fmpq, b::padic)\n\n\nexact division\n\n\n\n\n\n\n^(a::padic, b::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nHere are some examples of arithmetic operations on \np\n-adic field elements.\n\n\nR = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = O(R, 7^3)\nd = R(2)\n\nf = a + b\ng = a - b\nh = a*b\nj = b*c\nk = a*d\nm = a + 2\nn = 3 - b\np = a*ZZ(5)\nq = ZZ(3)*c\nr = 2*d\ns = 2 + d\nt = d - ZZ(2)\nu = a + ZZ(1)//7^2\nv = (ZZ(12)//11)*b\nw = c*(ZZ(1)//7)\n\n\n\n\n\n\nComparison\n\n\nNemo provides the comparison operation \n==\n for \np\n-adic field elements. Julia then automatically provides the corresponding \n!=\n operation. Here are the functions provided.\n\n\n\n\nFunction\n\n\n==(a::padic, b::padic) isequal(a::padic, b::padic)\n\n\nNote that \n==\n returns \ntrue\n if its arguments are arithmetically equal to the minimum of the two precisions. The \nisequal\n function requires them to both be the same precision, as for power series.\n\n\nIn addition, the following ad hoc comparisons are provided, Julia again providing the corresponding \n!=\n operators.\n\n\n\n\nFunction\n\n\n==(a::padic, b::Integer) ==(a::padic, b::fmpz) ==(a::padic, b::fmpq) ==(a::Integer, b::padic) ==(a::fmpz, b::padic) ==(a::fmpq, b::padic)\n\n\nHere are some examples of comparisons.\n\n\nR = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 3*7^3 + O(R, 7^5)\nc = O(R, 7^3)\nd = R(2)\n\na == 1 + 2*7 + O(R, 7^2)\nb == c\nisequal(a, b)\nc == R(0)\nd == R(2)\nZZ(3) == d\nZZ(3)//7 == c\n\n\n\n\n\n\nInversion\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(a::padic)\n\n\n\n\n\n\nReturns \na^{-1}\n. If \na = 0\n a \nDivideError()\n is thrown.\n\n\n\n\nsource\n\n\nHere are some examples of inversion.\n\n\nR = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\nd = 7 + 2*7^2 + O(R, 7^5)\n\nf = inv(a)\ng = inv(b)\nh = inv(c)\nk = inv(d)\nl = inv(R(1))\n\n\n\n\n\n\nDivisibility\n\n\n#\n\n\nNemo.divides\n \n \nMethod\n.\n\n\ndivides(f::padic, g::padic)\n\n\n\n\n\n\nReturns a pair consisting of a flag which is set to \ntrue\n if \ng\n divides \nf\n and \nfalse\n otherwise, and a value \nh\n such that \nf = gh\n if such a value exists. If not, the value of \nh\n is undetermined.\n\n\n\n\nsource\n\n\nHere are some examples of divisibility testing.\n\n\nR = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\n\nflag, q = divides(a, b)\n\n\n\n\n\n\nGCD\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd(x::padic, y::padic)\n\n\n\n\n\n\nReturns the greatest common divisor of \nx\n and \ny\n, i.e. the function returns \n1\n unless both \na\n and \nb\n are \n0\n, in which case it returns \n0\n.\n\n\n\n\nsource\n\n\nHere are some examples of greatest common divisor.\n\n\nR = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\n\nd = gcd(a, b)\nf = gcd(R(0), R(0))\n\n\n\n\n\n\nSquare root\n\n\n#\n\n\nBase.sqrt\n \n \nMethod\n.\n\n\nsqrt(a::padic)\n\n\n\n\n\n\nReturn the \np\n-adic square root of \na\n. We define this only when the valuation of \na\n is even. The precision of the output will be precision\n(a) -\n valuation\n(a)/2\n. If the square root does not exist, an exception is thrown.\n\n\n\n\nsource\n\n\nHere are some examples of taking the square root.\n\n\nR = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\n\nd = sqrt(a)\nf = sqrt(b)\nf = sqrt(c)\ng = sqrt(R(121))\n\n\n\n\n\n\nSpecial functions\n\n\n#\n\n\nBase.exp\n \n \nMethod\n.\n\n\nexp(a::padic)\n\n\n\n\n\n\nReturn the \np\n-adic exponential of \na\n. We define this only when the valuation of \na\n is positive (unless \na = 0\n). The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nBase.log\n \n \nMethod\n.\n\n\nlog(a::padic)\n\n\n\n\n\n\nReturn the \np\n-adic logarithm of \na\n. We define this only when the valuation of \na\n is zero (but not for \na == 0\n). The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.teichmuller\n \n \nMethod\n.\n\n\nteichmuller(a::padic)\n\n\n\n\n\n\nReturn the Teichmuller lift of the \np\n-adic value \na\n. We require the valuation of \na\n to be nonnegative. The precision of the output will be the same as the precision of the input. For convenience, if \na\n is congruent to zero modulo \np\n we return zero. If the input is not valid an exception is thrown.\n\n\n\n\nsource\n\n\nR = PadicField(7, 30)\n\n\na = 1 + 7 + 2\n7^2 + O(R, 7^3) b = 2 + 5\n7 + 3\n7^2 + O(R, 7^3) c = 3\n7 + 2*7^2 + O(R, 7^5)\n\n\nc = exp(c) d = log(a) c = exp(R(0)) d = log(R(1)) f = teichmuller(b)", 
            "title": "P-adic fields"
        }, 
        {
            "location": "/padic/#introduction", 
            "text": "P-adic fields are provided in Nemo by Flint. This allows construction of  p -adic fields for any prime  p .  P-adic fields are constructed using the  FlintPadicField  function. However, for convenience we define  PadicField = FlintPadicField  so that  p -adic fields can be constructed using  PadicField  rather than  FlintPadicField . Note that this is the name of the constructor, but not of padic field type.  The types of  p -adic fields in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.     Library  Field  Element type  Parent type      Flint   \\mathbb{Q}_p   padic  PadicField     All the  p -adic field types belong to the  Field  abstract type and the  p -adic field element types belong to the  FieldElem  abstract type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/padic/#p-adic-field-constructors", 
            "text": "In order to construct  p -adic field elements in Nemo, one must first construct the  p -adic field itself. This is accomplished with one of the following constructors.  #  Nemo.FlintPadicField     Method .  FlintPadicField(p::Integer, prec::Int)   Returns the parent object for the  p -adic field for given prime  p , where the default absolute precision of elements of the field is given by  prec .   source  It is also possible to call the inner constructor directly. It has the following form.  FlintPadicField(p::fmpz, prec::Int)  Returns the parent object for the  p -adic field for given prime  p , where the default absolute precision of elements of the field is given by  prec .  Here are some examples of creating  p -adic fields and making use of the resulting parent objects to coerce various elements into those fields.  R = PadicField(7, 30)\nS = PadicField(ZZ(65537), 30)\n\na = R()\nb = S(1)\nc = S(ZZ(123))\nd = R(ZZ(1)//7^2)", 
            "title": "P-adic field constructors"
        }, 
        {
            "location": "/padic/#p-adic-field-element-constructors", 
            "text": "Once a  p -adic field is constructed, there are various ways to construct elements in that field.  Apart from coercing elements into the  p -adic field as above, we offer the following functions.  #  Base.zero     Method .  zero(R::FlintPadicField)   Return zero in the given  p -adic field, to the default precision.   source  #  Base.one     Method .  one(R::FlintPadicField)   Return zero in the given  p -adic field, to the default precision.   source  Elements can also be constructed using the big-oh notation. For this purpose we define the following functions.  #  Nemo.O     Method .  O(R::FlintPadicField, m::Integer)   Construct the value  0 + O(p^n)  given  m = p^n . An exception results if  m  is not found to be a power of  p = prime(R) .   source  #  Nemo.O     Method .  O(R::FlintPadicField, m::fmpz)   Construct the value  0 + O(p^n)  given  m = p^n . An exception results if  m  is not found to be a power of  p = prime(R) .   source  #  Nemo.O     Method .  O(R::FlintPadicField, m::fmpq)   Construct the value  0 + O(p^n)  given  m = p^n . An exception results if  m  is not found to be a power of  p = prime(R) .   source  The  O(p^n)  construction can be used to construct  p -adic values of precision  n  by adding it to integer values representing the  p -adic value modulo  p^n  as in the examples.  Here are some examples of constructing  p -adic field elements.  R = PadicField(7, 30)\nS = PadicField(fmpz(65537), 30)\n\na = one(R)\nb = zero(S)\nc = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nd = 13 + 357*ZZ(65537) + O(S, ZZ(65537)^12)\nf = ZZ(1)//7^2 + ZZ(2)//7 + 3 + 4*7 + O(R, 7^2)  Beware that the expression  1 + 2*p + 3*p^2 + O(R, p^n)  is actually computed as a normal Julia expression. Therefore if \\code{Int} values are used instead of Flint integers or Julia bignums, overflow may result in evaluating the value.", 
            "title": "P-adic field element constructors"
        }, 
        {
            "location": "/padic/#basic-functionality", 
            "text": "The following basic functionality is provided by the default  p -adic field implementation in Nemo, to support construction of generic rings over  p -adic fields. Any custom  p -adic field implementation in Nemo should provide these  functions along with the usual arithmetic operations.  parent_type(::Type{padic})  Gives the type of the parent object of a Flint  p -adic field element.  elem_type(R::FlintPadicField)  Given the parent object for a  p -adic field, return the type of elements of the field.  Base.hash(a::padic, h::UInt)  Return a  UInt  hexadecimal hash of the  p -adic field element  a . This should be xor'd with a fixed random hexadecimal specific to the  p -adic field type. The hash of the representative of the  p -adic field element (lifted to  \\mathbb{Q}  and the prime  p  for the field, should be xor'd with the supplied parameter  h  as part of computing the hash.  deepcopy(a::padic)  Construct a copy of the given  p -adic field element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo  p -adic field elements are mutable and so returning shallow copies is not sufficient.  mul!(c::padic, a::padic, b::padic)  Multiply  a  by  b  and set the existing  p -adic field element  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::padic, a::padic)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given the parent object  R  for a  p -adic field, the following coercion functions are provided to coerce various elements into the  p -adic field. Developers provide these by overloading the  call  operator for the  p -adic field parent objects.  R()  Coerce zero into the  p -adic field.  R(n::Integer)\nR(f::fmpz)\nR(f::fmpq)  Coerce an integer or rational value into the  p -adic field.  R(f::padic)  Take a  p -adic field element that is already in the  p -adic field and simply return it. A copy of the original is not made.  In addition to the above, developers of custom  p -adic field types must ensure that they provide the equivalent of the function  base_ring(R::FlintPadicField)  which should return  Union{} . In addition to this they should ensure that each  p -adic field element contains a field  parent  specifying the parent object of the  p -adic field element, or at least supply the equivalent of the function  parent(a::padic)  to return the parent object of a  p -adic field element.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/padic/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate  p -adic field elements. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(a::FlintPadicField)   Returns  Union{}  as this field is not dependent on another field.   source  #  Nemo.base_ring     Method .  base_ring(a::padic)   Returns  Union{}  as this field is not dependent on another field.   source  #  Base.parent     Method .  parent(a::padic)   Returns the parent of the given p-adic field element.   source  #  Nemo.iszero     Method .  iszero(a::padic)   Return  true  if the given p-adic field element is zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::padic)   Return  true  if the given p-adic field element is one, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::padic)   Return  true  if the given p-adic field element is invertible, i.e. nonzero, otherwise return  false .   source  #  Nemo.prime     Method .  prime(R::FlintPadicField)   Return the prime  p  for the given  p -adic field.   source  #  Base.precision     Method .  precision(a::padic)   Return the precision of the given  p -adic field element, i.e. if the element is known to  O(p^n)  this function will return  n .   source  #  Nemo.valuation     Method .  valuation(a::padic)   Return the valuation of the given  p -adic field element, i.e. if the given element is divisible by  p^n  but not a higher power of  p  then the function will return  n .   source  #  Nemo.lift     Method .  lift(R::FlintIntegerRing, a::padic)   Return a lift of the given  p -adic field element to  \\mathbb{Z} .   source  #  Nemo.lift     Method .  lift(R::FlintRationalField, a::padic)   Return a lift of the given  p -adic field element to  \\mathbb{Q} .   source  Here are some examples of basic manipulation of  p -adic field elements.  R = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = R(2)\n\nd = one(R)\nf = zero(R)\ng = isone(d)\nh = iszero(f)\nk = precision(a)\nm = prime(R)\nn = valuation(b)\np = lift(FlintZZ, a)\nq = lift(FlintQQ, divexact(a, b))", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/padic/#arithmetic-operations", 
            "text": "Nemo provides all the standard field operations for  p -adic field elements, as follows.     Function  Operation      -(a::padic)  unary minus    +(a::padic, b::padic)  addition    -(a::padic, b::padic)  subtraction    *(a::padic, b::padic)  multiplication    divexact(a::padic, b::padic)  exact division     In addition, the following ad hoc field operations are defined.     Function  Operation      +(a::padic, b::Integer)  addition    +(a::Integer, b::padic)  addition    +(a::padic, b::fmpz)  addition    +(a::fmpz, b::padic)  addition    +(a::padic, b::fmpq)  addition    +(a::fmpq, b::padic)  addition    -(a::padic, b::Integer)  subtraction    -(a::Integer, b::padic)  subtraction    -(a::padic, b::fmpz)  subtraction    -(a::fmpz, b::padic)  subtraction    -(a::padic, b::fmpq)  subtraction    -(a::fmpq, b::padic)  subtraction    *(a::padic, b::Integer)  multiplication    *(a::Integer, b::padic)  multiplication    *(a::padic, b::fmpz)  multiplication    *(a::fmpz, b::padic)  multiplication    *(a::padic, b::fmpq)  multiplication    *(a::fmpq, b::padic)  multiplication    divexact(a::padic, b::Integer)  exact division    divexact(a::padic, b::fmpz)  exact division    divexact(a::padic, b::fmpq)  exact division    divexact(a::Integer, b::padic)  exact division    divexact(a::fmpz, b::padic)  exact division    divexact(a::fmpq, b::padic)  exact division    ^(a::padic, b::Int)  powering     Here are some examples of arithmetic operations on  p -adic field elements.  R = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 7^2 + 3*7^3 + O(R, 7^5)\nc = O(R, 7^3)\nd = R(2)\n\nf = a + b\ng = a - b\nh = a*b\nj = b*c\nk = a*d\nm = a + 2\nn = 3 - b\np = a*ZZ(5)\nq = ZZ(3)*c\nr = 2*d\ns = 2 + d\nt = d - ZZ(2)\nu = a + ZZ(1)//7^2\nv = (ZZ(12)//11)*b\nw = c*(ZZ(1)//7)", 
            "title": "Arithmetic operations"
        }, 
        {
            "location": "/padic/#comparison", 
            "text": "Nemo provides the comparison operation  ==  for  p -adic field elements. Julia then automatically provides the corresponding  !=  operation. Here are the functions provided.", 
            "title": "Comparison"
        }, 
        {
            "location": "/padic/#function", 
            "text": "==(a::padic, b::padic) isequal(a::padic, b::padic)  Note that  ==  returns  true  if its arguments are arithmetically equal to the minimum of the two precisions. The  isequal  function requires them to both be the same precision, as for power series.  In addition, the following ad hoc comparisons are provided, Julia again providing the corresponding  !=  operators.", 
            "title": "Function"
        }, 
        {
            "location": "/padic/#function_1", 
            "text": "==(a::padic, b::Integer) ==(a::padic, b::fmpz) ==(a::padic, b::fmpq) ==(a::Integer, b::padic) ==(a::fmpz, b::padic) ==(a::fmpq, b::padic)  Here are some examples of comparisons.  R = PadicField(7, 30)\n\na = 1 + 2*7 + 4*7^2 + O(R, 7^3)\nb = 3*7^3 + O(R, 7^5)\nc = O(R, 7^3)\nd = R(2)\n\na == 1 + 2*7 + O(R, 7^2)\nb == c\nisequal(a, b)\nc == R(0)\nd == R(2)\nZZ(3) == d\nZZ(3)//7 == c", 
            "title": "Function"
        }, 
        {
            "location": "/padic/#inversion", 
            "text": "#  Base.inv     Method .  inv(a::padic)   Returns  a^{-1} . If  a = 0  a  DivideError()  is thrown.   source  Here are some examples of inversion.  R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\nd = 7 + 2*7^2 + O(R, 7^5)\n\nf = inv(a)\ng = inv(b)\nh = inv(c)\nk = inv(d)\nl = inv(R(1))", 
            "title": "Inversion"
        }, 
        {
            "location": "/padic/#divisibility", 
            "text": "#  Nemo.divides     Method .  divides(f::padic, g::padic)   Returns a pair consisting of a flag which is set to  true  if  g  divides  f  and  false  otherwise, and a value  h  such that  f = gh  if such a value exists. If not, the value of  h  is undetermined.   source  Here are some examples of divisibility testing.  R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\n\nflag, q = divides(a, b)", 
            "title": "Divisibility"
        }, 
        {
            "location": "/padic/#gcd", 
            "text": "#  Base.gcd     Method .  gcd(x::padic, y::padic)   Returns the greatest common divisor of  x  and  y , i.e. the function returns  1  unless both  a  and  b  are  0 , in which case it returns  0 .   source  Here are some examples of greatest common divisor.  R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\n\nd = gcd(a, b)\nf = gcd(R(0), R(0))", 
            "title": "GCD"
        }, 
        {
            "location": "/padic/#square-root", 
            "text": "#  Base.sqrt     Method .  sqrt(a::padic)   Return the  p -adic square root of  a . We define this only when the valuation of  a  is even. The precision of the output will be precision (a) -  valuation (a)/2 . If the square root does not exist, an exception is thrown.   source  Here are some examples of taking the square root.  R = PadicField(7, 30)\n\na = 1 + 7 + 2*7^2 + O(R, 7^3)\nb = 2 + 3*7 + O(R, 7^5)\nc = 7^2 + 2*7^3 + O(R, 7^4)\n\nd = sqrt(a)\nf = sqrt(b)\nf = sqrt(c)\ng = sqrt(R(121))", 
            "title": "Square root"
        }, 
        {
            "location": "/padic/#special-functions", 
            "text": "#  Base.exp     Method .  exp(a::padic)   Return the  p -adic exponential of  a . We define this only when the valuation of  a  is positive (unless  a = 0 ). The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.   source  #  Base.log     Method .  log(a::padic)   Return the  p -adic logarithm of  a . We define this only when the valuation of  a  is zero (but not for  a == 0 ). The precision of the output will be the same as the precision of the input. If the input is not valid an exception is thrown.   source  #  Nemo.teichmuller     Method .  teichmuller(a::padic)   Return the Teichmuller lift of the  p -adic value  a . We require the valuation of  a  to be nonnegative. The precision of the output will be the same as the precision of the input. For convenience, if  a  is congruent to zero modulo  p  we return zero. If the input is not valid an exception is thrown.   source  R = PadicField(7, 30)  a = 1 + 7 + 2 7^2 + O(R, 7^3) b = 2 + 5 7 + 3 7^2 + O(R, 7^3) c = 3 7 + 2*7^2 + O(R, 7^5)  c = exp(c) d = log(a) c = exp(R(0)) d = log(R(1)) f = teichmuller(b)", 
            "title": "Special functions"
        }, 
        {
            "location": "/arb/", 
            "text": "Introduction\n\n\nArbitrary precision real ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Real numbers are  represented in mid-rad interval form \n[m \\pm r] = [m-r, m+r]\n.\n\n\nThe Arb real field is constructed using the \nArbField\n constructor. This constructs the parent object for the Arb real field.\n\n\nHowever, we define\n\n\nRealField = ArbField\n\n\n\n\nso that one can construct the Arb real field parent object using \nRealField\n instead of \nArbField\n.\n\n\nThe types of real balls in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.\n\n\n\n\n\n\n\n\nLibrary\n\n\nField\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nArb\n\n\n\n\n\\mathbb{R}\n (balls)\n\n\narb\n\n\nArbField\n\n\n\n\n\n\n\n\nAll the real field types belong to the \nField\n abstract type and the types of elements in this field, i.e. balls in this case, belong to the \nFieldElem\n abstract type.\n\n\n\n\nReal field constructors\n\n\nIn order to construct real balls in Nemo, one must first construct the Arb real field itself. This is accomplished with the following constructor.\n\n\nArbField(prec::Int)\n\n\n\n\nReturn the Arb field with precision in bits \nprec\n used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).\n\n\nWe define\n\n\nRealField = ArbField\n\n\n\n\nso that one can use \nRealField\n in place of \nArbField\n.\n\n\nHere is an example of creating an Arb real field and using the resulting parent object to coerce values into the resulting field.\n\n\nRR = RealField(64)\n\na = RR(\n0.25\n)\nb = RR(\n0.1\n)\nc = RR(0.5)\nd = RR(12)\n\n\n\n\nNote that whilst one can coerce double precision floating point values into an Arb real field, unless those values can be represented exactly in double precision, the resulting ball can't be any more precise than the double precision supplied.\n\n\nIf instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb field.\n\n\nIf the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function \nisexact\n below for more information.\n\n\n\n\nReal ball constructors\n\n\nOnce an Arb real field is constructed, there are various ways to construct balls in that field.\n\n\nApart from coercing elements into the Arb real field as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::ArbField)\n\n\n\n\n\n\nReturn exact zero in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::ArbField)\n\n\n\n\n\n\nReturn exact one in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ball\n \n \nMethod\n.\n\n\nball(mid::arb, rad::arb)\n\n\n\n\n\n\nConstructs an \narb\n enclosing the range \n[m-|r|, m+|r|]\n, given the pair \n(m, r)\n.\n\n\n\n\nsource\n\n\nHere are some examples of constructing balls.\n\n\nRR = RealField(64)\n\na = zero(RR)\nb = one(RR)\nc = ball(RR(3), RR(\n0.0001\n))\n\n\n\n\n\n\nBasic functionality\n\n\nThe following basic functionality is provided by the default Arb real field implementation in Nemo, to support construction of generic rings over real fields. Any custom real field implementation in Nemo should provide analogues of these functions along with the usual arithmetic operations.\n\n\nparent_type(::Type{arb})\n\n\n\n\nGives the type of the parent object of an Arb real field element.\n\n\nelem_type(R::ArbField)\n\n\n\n\nGiven the parent object for a Arb field, return the type of elements of the field.\n\n\nmul!(c::arb, a::arb, b::arb)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing Arb field element \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::arb, a::arb)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\ndeepcopy(a::arb)\n\n\n\n\nReturn a copy of the Arb field element \na\n, recursively copying the internal data. Arb field elements are mutable in Nemo so a shallow copy is not sufficient.\n\n\nGiven the parent object \nR\n for an Arb real field, the following coercion functions are provided to coerce various elements into the Arb field. Developers provide these by overloading the \ncall\n operator for the real field parent objects.\n\n\nR()\n\n\n\n\nCoerce zero into the Arb field.\n\n\nR(n::Integer)\nR(f::fmpz)\nR(q::fmpq)\n\n\n\n\nCoerce an integer or rational value into the Arb field.\n\n\nR(f::Float64)\nR(f::BigFloat)\n\n\n\n\nCoerce the given floating point number into the Arb field.\n\n\nR(f::AbstractString)\n\n\n\n\nCoerce the decimal number, given as a string, into the Arb field.\n\n\nR(f::arb)\n\n\n\n\nTake an Arb field element that is already in the Arb field and simply return it. A copy of the original is not made.\n\n\nHere are some examples of coercing elements into the Arb field.\n\n\nRR = RealField(64)\n\na = RR(3)\nb = RR(QQ(2,3))\nc = ball(RR(3), RR(\n0.0001\n))\nd = RR(\n3 +/- 0.0001\n)\nf = RR(\n-1.24e+12345\n)\ng = RR(\nnan +/- inf\n)\n\n\n\n\nIn addition to the above, developers of custom real field types must ensure that they provide the equivalent of the function \nbase_ring(R::ArbField)\n which should return \nUnion{}\n. In addition to this they should ensure that each real field element contains a field \nparent\n specifying the parent object of the real field element, or at least supply the equivalent of the function \nparent(a::arb)\n to return the parent object of a real field element.\n\n\n\n\nConversions\n\n\n#\n\n\nBase.convert\n \n \nMethod\n.\n\n\nconvert(::Type{Float64}, x::arb)\n\n\n\n\n\n\nReturn the midpoint of \nx\n rounded down to a machine double.\n\n\n\n\nsource\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate Arb field elements. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(R::ArbField)\n\n\n\n\n\n\nReturns \nUnion{}\n since an Arb field does not depend on any other ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(x::arb)\n\n\n\n\n\n\nReturns \nUnion{}\n since an Arb field does not depend on any other ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(x::arb)\n\n\n\n\n\n\nReturn the parent of the given Arb field element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isnonzero\n \n \nMethod\n.\n\n\nisnonzero(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly not equal to zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly not equal to oneo, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isfinite\n \n \nMethod\n.\n\n\nisfinite(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is finite, i.e. having finite midpoint and radius, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isexact\n \n \nMethod\n.\n\n\nisexact(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is exact, i.e. has zero radius, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isint\n \n \nMethod\n.\n\n\nisint(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is an exact integer, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ispositive\n \n \nMethod\n.\n\n\nispositive(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly positive, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isnonnegative\n \n \nMethod\n.\n\n\nisnonnegative(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly nonnegative, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isnegative\n \n \nMethod\n.\n\n\nisnegative(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly negative, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isnonpositive\n \n \nMethod\n.\n\n\nisnonpositive(x::arb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly nonpositive, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.midpoint\n \n \nMethod\n.\n\n\nmidpoint(x::arb)\n\n\n\n\n\n\nReturn the midpoint of the ball \nx\n as an Arb ball.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.radius\n \n \nMethod\n.\n\n\nradius(x::arb)\n\n\n\n\n\n\nReturn the radius of the ball \nx\n as an Arb ball.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.accuracy_bits\n \n \nMethod\n.\n\n\naccuracy_bits(x::arb)\n\n\n\n\n\n\nReturn the relative accuracy of \nx\n measured in bits, capped between \ntypemax(Int)\n and \n-typemax(Int)\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of Arb balls.\n\n\nRR = RealField(64)\n\na = RR(\n1.2 +/- 0.001\n)\nb = RR(3)\n\niszero(a)\nisone(b)\nispositive(a)\nisfinite(b)\nisint(b)\nisnegative(a)\nc = radius(a)\nd = midpoint(b)\nf = accuracy_bits(a)\nS = parent(a)\nT = base_ring(RR)\n\n\n\n\n\n\nArithmetic operations\n\n\nNemo provides all the standard field operations for Arb field elements, as follows. Note that division is represented by \n//\n since a field is its own fraction field and since exact division is not generally possible in an inexact field.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::arb)\n\n\nunary minus\n\n\n\n\n\n\n+(a::arb, b::arb)\n\n\naddition\n\n\n\n\n\n\n-(a::arb, b::arb)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::arb, b::arb)\n\n\nmultiplication\n\n\n\n\n\n\n//(a::arb, b::arb)\n\n\ndivision\n\n\n\n\n\n\n^(a::arb, b::arb)\n\n\npowering\n\n\n\n\n\n\n\n\nIn addition, the following ad hoc field operations are defined.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::arb, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::Integer, b::arb)\n\n\naddition\n\n\n\n\n\n\n+(a::arb, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::arb)\n\n\naddition\n\n\n\n\n\n\n-(a::arb, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::Integer, b::arb)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::arb, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::arb)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::arb, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::Integer, b::arb)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::arb, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::arb)\n\n\nmultiplication\n\n\n\n\n\n\n//(a::arb, b::Integer)\n\n\ndivision\n\n\n\n\n\n\n//(a::arb, b::fmpz)\n\n\ndivision\n\n\n\n\n\n\n//(a::Integer, b::arb)\n\n\ndivision\n\n\n\n\n\n\n//(a::fmpz, b::arb)\n\n\ndivision\n\n\n\n\n\n\n^(a::arb, b::Integer)\n\n\npowering\n\n\n\n\n\n\n^(a::arb, b::fmpz)\n\n\npowering\n\n\n\n\n\n\n^(a::arb, b::fmpq)\n\n\npowering\n\n\n\n\n\n\n\n\nHere are some examples of arithmetic operations on Arb balls.\n\n\nRR = RealField(64)\n\nx = RR(3)\ny = RR(QQ(2,3))\n\na = x + y\nb = x*y\nd = 1//y - x\nd = 3x + ZZ(100)//y\nf = (x^2 + y^2) ^ QQ(1,2)\n\n\n\n\n\n\nContainment\n\n\nIt is often necessary to determine whether a given exact value or ball is contained in a given real ball or whether two balls overlap. The following functions are provided for this purpose.\n\n\n#\n\n\nNemo.overlaps\n \n \nMethod\n.\n\n\noverlaps(x::arb, y::arb)\n\n\n\n\n\n\nReturns \ntrue\n if any part of the ball \nx\n overlaps any part of the ball \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb, y::arb)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains the ball \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb, y::Integer)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains the given integer value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb, y::fmpz)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains the given integer value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb, y::fmpq)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains the given rational value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::arb, y::BigFloat)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains the given floating point value,  otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nThe following functions are also provided for determining if a ball intersects a certain part of the real number line.\n\n\n#\n\n\nNemo.contains_zero\n \n \nMethod\n.\n\n\ncontains_zero(x::arb)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.contains_negative\n \n \nMethod\n.\n\n\ncontains_negative(x::arb)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains any negative value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.contains_positive\n \n \nMethod\n.\n\n\ncontains_positive(x::arb)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains any positive value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.contains_nonnegative\n \n \nMethod\n.\n\n\ncontains_nonnegative(x::arb)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains any nonnegative value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.contains_nonpositive\n \n \nMethod\n.\n\n\ncontains_nonpositive(x::arb)\n\n\n\n\n\n\nReturns \ntrue\n if the ball \nx\n contains any nonpositive value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of testing containment.\n\n\nRR = RealField(64)\nx = RR(\n1 +/- 0.001\n)\ny = RR(\n3\n)\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)\ncontains_positive(y)\n\n\n\n\n\n\nComparison\n\n\nNemo provides a full range of comparison operations for Arb balls. Note that a ball is considered less than another ball if every value in the first ball is less than every value in the second ball, etc.\n\n\nFirstly, we introduce an exact equality which is distinct from arithmetic equality. This is distinct from arithmetic equality implemented by \n==\n, which merely compares up to the minimum of the precisions of its operands.\n\n\n#\n\n\nBase.isequal\n \n \nMethod\n.\n\n\nisequal(x::arb, y::arb)\n\n\n\n\n\n\nReturn \ntrue\n if the balls \nx\n and \ny\n are precisely equal, i.e. have the same midpoints and radii.\n\n\n\n\nsource\n\n\nA full range of functions is available for comparing balls, i.e. \n==\n, \n!=\n, \n, \n=\n, \n=\n, \n. In fact, all these are implemented directly in C. In the table below we document these as though only \n==\n and \nisless\n had been provided to Julia.\n\n\n\n\nFunction\n\n\nisless(x::arb, y::arb)\n  \n==(x::arb, y::arb)\n\n\nAs well as these, we provide a full range of ad hoc comparison operators. Again, these are implemented directly in Julia, but we document them as though \nisless\n and \n==\n were provided.\n\n\n\n\nFunction\n\n\n==(x::arb, y::Integer)\n \n==(x::Integer, y::arb)\n \n==(x::arb, y::fmpz)\n \n==(x::fmpz, y::arb)\n \n==(x::arb, y::Float64)\n \n==(x::Float64, y::arb)\n \nisless(x::arb, y::Integer)\n \nisless(x::Integer, y::arb)\n \nisless(x::arb, y::fmpz)\n \nisless(x::fmpz, y::arb)\n \nisless(x::arb, y::Float64)\n \nisless(x::Float64, y::arb)\n\n\nHere are some examples of comparison.\n\n\nRR = RealField(64)\nx = RR(\n1 +/- 0.001\n)\ny = RR(\n3\n)\nz = RR(\n4\n)\n\nisequal(y, z)\nx \n= z\nx == 3\nZZ(3) \n z\nx != 1.23\n\n\n\n\n\n\nAbsolute value\n\n\n#\n\n\nBase.abs\n \n \nMethod\n.\n\n\nabs(x::arb)\n\n\n\n\n\n\nReturn the absolute value of \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of taking the absolute value.\n\n\nRR = RealField(64)\nx = RR(\n-1 +/- 0.001\n)\n\na = abs(x)\n\n\n\n\n\n\nInverse\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(x::arb)\n\n\n\n\n\n\nReturn the multiplicative inverse of \nx\n, i.e. \n1/x\n.\n\n\n\n\nsource\n\n\nHere are some examples of taking the inverse.\n\n\nRR = RealField(64)\nx = RR(\n-3 +/- 0.001\n)\n\na = inv(x)\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nBase.Math.ldexp\n \n \nMethod\n.\n\n\nldexp(x::arb, y::Int)\n\n\n\n\n\n\nReturn \n2^yx\n. Note that \ny\n can be positive, zero or negative.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.ldexp\n \n \nMethod\n.\n\n\nldexp(x::arb, y::fmpz)\n\n\n\n\n\n\nReturn \n2^yx\n. Note that \ny\n can be positive, zero or negative.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\nRR = RealField(64)\nx = RR(\n-3 +/- 0.001\n)\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))\n\n\n\n\n\n\nMiscellaneous operations\n\n\n#\n\n\nNemo.trim\n \n \nMethod\n.\n\n\ntrim(x::arb)\n\n\n\n\n\n\nReturn an \narb\n interval containing \nx\n but which may be more economical, by rounding off insignificant bits from the midpoint.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.unique_integer\n \n \nMethod\n.\n\n\nunique_integer(x::arb)\n\n\n\n\n\n\nReturn a pair where the first value is a boolean and the second is an \nfmpz\n integer. The boolean indicates whether the interval \nx\n contains a unique integer. If this is the case, the second return value is set to this unique integer.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.setunion\n \n \nMethod\n.\n\n\nsetunion(x::arb, y::arb)\n\n\n\n\n\n\nReturn an \narb\n containing the union of the intervals represented by \nx\n and \ny\n.\n\n\n\n\nsource\n\n\nHere are some examples of miscellaneous operations.\n\n\nRR = RealField(64)\nx = RR(\n-3 +/- 0.001\n)\ny = RR(\n2 +/- 0.5\n)\n\na = trim(x)\nb, c = unique_integer(x)\nd = setunion(x, y)\n\n\n\n\n\n\nConstants\n\n\n#\n\n\nNemo.const_pi\n \n \nMethod\n.\n\n\nconst_pi(r::ArbField)\n\n\n\n\n\n\nReturn \n\\pi = 3.14159\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.const_e\n \n \nMethod\n.\n\n\nconst_e(r::ArbField)\n\n\n\n\n\n\nReturn \ne = 2.71828\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.const_log2\n \n \nMethod\n.\n\n\nconst_log2(r::ArbField)\n\n\n\n\n\n\nReturn \n\\log(2) = 0.69314\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.const_log10\n \n \nMethod\n.\n\n\nconst_log10(r::ArbField)\n\n\n\n\n\n\nReturn \n\\log(10) = 2.302585\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.const_euler\n \n \nMethod\n.\n\n\nconst_euler(r::ArbField)\n\n\n\n\n\n\nReturn Euler's constant \n\\gamma = 0.577215\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.const_catalan\n \n \nMethod\n.\n\n\nconst_catalan(r::ArbField)\n\n\n\n\n\n\nReturn Catalan's constant \nC = 0.915965\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.const_khinchin\n \n \nMethod\n.\n\n\nconst_khinchin(r::ArbField)\n\n\n\n\n\n\nReturn Khinchin's constant \nK = 2.685452\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.const_glaisher\n \n \nMethod\n.\n\n\nconst_glaisher(r::ArbField)\n\n\n\n\n\n\nReturn Glaisher's constant \nA = 1.282427\\ldots\n as an element of \nr\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing real constants.\n\n\nRR = RealField(200)\n\na = const_pi(RR)\nb = const_e(RR)\nc = const_euler(RR)\nd = const_glaisher(RR)\n\n\n\n\n\n\nMathematical functions\n\n\n#\n\n\nBase.floor\n \n \nMethod\n.\n\n\nfloor(x::arb)\n\n\n\n\n\n\nCompute the floor of \nx\n, i.e. the greatest integer not exceeding \nx\n, as an Arb.\n\n\n\n\nsource\n\n\n#\n\n\nBase.ceil\n \n \nMethod\n.\n\n\nceil(x::arb)\n\n\n\n\n\n\nReturn the ceiling of \nx\n, i.e. the least integer not less than \nx\n, as an Arb.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sqrt\n \n \nMethod\n.\n\n\nsqrt(x::arb)\n\n\n\n\n\n\nReturn the square root of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.rsqrt\n \n \nMethod\n.\n\n\nrsqrt(x::arb)\n\n\n\n\n\n\nReturn the reciprocal of the square root of \nx\n, i.e. \n1/\\sqrt{x}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sqrt1pm1\n \n \nMethod\n.\n\n\nsqrt1pm1(x::arb)\n\n\n\n\n\n\nReturn \n\\sqrt{1+x}-1\n, evaluated accurately for small \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.log\n \n \nMethod\n.\n\n\nlog(x::arb)\n\n\n\n\n\n\nReturn the principal branch of the logarithm of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.log1p\n \n \nMethod\n.\n\n\nlog1p(x::arb)\n\n\n\n\n\n\nReturn \n\\log(1+x)\n, evaluated accurately for small \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.exp\n \n \nMethod\n.\n\n\nexp(x::arb)\n\n\n\n\n\n\nReturn the exponential of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.expm1\n \n \nMethod\n.\n\n\nexpm1(x::arb)\n\n\n\n\n\n\nReturn \n\\exp(x)-1\n, evaluated accurately for small \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sin\n \n \nMethod\n.\n\n\nsin(x::arb)\n\n\n\n\n\n\nReturn the sine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cos\n \n \nMethod\n.\n\n\ncos(x::arb)\n\n\n\n\n\n\nReturn the cosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.sinpi\n \n \nMethod\n.\n\n\nsinpi(x::arb)\n\n\n\n\n\n\nReturn the sine of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.cospi\n \n \nMethod\n.\n\n\ncospi(x::arb)\n\n\n\n\n\n\nReturn the cosine of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tan\n \n \nMethod\n.\n\n\ntan(x::arb)\n\n\n\n\n\n\nReturn the tangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.cot\n \n \nMethod\n.\n\n\ncot(x::arb)\n\n\n\n\n\n\nReturn the cotangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.tanpi\n \n \nMethod\n.\n\n\ntanpi(x::arb)\n\n\n\n\n\n\nReturn the tangent of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.cotpi\n \n \nMethod\n.\n\n\ncotpi(x::arb)\n\n\n\n\n\n\nReturn the cotangent of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sinh\n \n \nMethod\n.\n\n\nsinh(x::arb)\n\n\n\n\n\n\nReturn the hyperbolic sine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cosh\n \n \nMethod\n.\n\n\ncosh(x::arb)\n\n\n\n\n\n\nReturn the hyperbolic cosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tanh\n \n \nMethod\n.\n\n\ntanh(x::arb)\n\n\n\n\n\n\nReturn the hyperbolic tangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.coth\n \n \nMethod\n.\n\n\ncoth(x::arb)\n\n\n\n\n\n\nReturn the hyperbolic cotangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.atan\n \n \nMethod\n.\n\n\natan(x::arb)\n\n\n\n\n\n\nReturn the arctangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.asin\n \n \nMethod\n.\n\n\nasin(x::arb)\n\n\n\n\n\n\nReturn the arcsine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.acos\n \n \nMethod\n.\n\n\nacos(x::arb)\n\n\n\n\n\n\nReturn the arccosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.atanh\n \n \nMethod\n.\n\n\natanh(x::arb)\n\n\n\n\n\n\nReturn the hyperbolic arctangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.asinh\n \n \nMethod\n.\n\n\nasinh(x::arb)\n\n\n\n\n\n\nReturn the hyperbolic arcsine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.acosh\n \n \nMethod\n.\n\n\nacosh(x::arb)\n\n\n\n\n\n\nReturn the hyperbolic arccosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.gamma\n \n \nMethod\n.\n\n\ngamma(x::arb)\n\n\n\n\n\n\nReturn the Gamma function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.lgamma\n \n \nMethod\n.\n\n\nlgamma(x::arb)\n\n\n\n\n\n\nReturn the logarithm of the Gamma function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.rgamma\n \n \nMethod\n.\n\n\nrgamma(x::arb)\n\n\n\n\n\n\nReturn the reciprocal of the Gamma function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.digamma\n \n \nMethod\n.\n\n\ndigamma(x::arb)\n\n\n\n\n\n\nReturn the  logarithmic derivative of the gamma function evaluated at \nx\n, i.e. \n\\psi(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.zeta\n \n \nMethod\n.\n\n\nzeta(x::arb)\n\n\n\n\n\n\nReturn the Riemann zeta function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sincos\n \n \nMethod\n.\n\n\nsincos(x::arb)\n\n\n\n\n\n\nReturn a tuple \ns, c\n consisting of the sine \ns\n and cosine \nc\n of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sincospi\n \n \nMethod\n.\n\n\nsincospi(x::arb)\n\n\n\n\n\n\nReturn a tuple \ns, c\n consisting of the sine \ns\n and cosine \nc\n of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.sinpi\n \n \nMethod\n.\n\n\nsinpi(x::fmpq, r::ArbField)\n\n\n\n\n\n\nReturn the sine of \n\\pi x\n in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.cospi\n \n \nMethod\n.\n\n\ncospi(x::fmpq, r::ArbField)\n\n\n\n\n\n\nReturn the cosine of \n\\pi x\n in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sincospi\n \n \nMethod\n.\n\n\nsincospi(x::fmpq, r::ArbField)\n\n\n\n\n\n\nReturn a tuple \ns, c\n consisting of the sine and cosine of \n\\pi x\n in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sinhcosh\n \n \nMethod\n.\n\n\nsinhcosh(x::arb)\n\n\n\n\n\n\nReturn a tuple \ns, c\n consisting of the hyperbolic sine and cosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.atan2\n \n \nMethod\n.\n\n\natan2(x::arb, y::arb)\n\n\n\n\n\n\nReturn atan2\n(b,a) = \\arg(a+bi)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.agm\n \n \nMethod\n.\n\n\nagm(x::arb, y::arb)\n\n\n\n\n\n\nReturn the arithmetic-geometric mean of \nx\n and \ny\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.zeta\n \n \nMethod\n.\n\n\nzeta(s::arb, a::arb)\n\n\n\n\n\n\nReturn the Hurwitz zeta function \n\\zeta(s,a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.hypot\n \n \nMethod\n.\n\n\nhypot(x::arb, y::arb)\n\n\n\n\n\n\nReturn \n\\sqrt{x^2 + y^2}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.root\n \n \nMethod\n.\n\n\nroot(x::arb, n::Int)\n\n\n\n\n\n\nReturn the \nn\n-th root of \nx\n. We require \nx \\geq 0\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fac\n \n \nMethod\n.\n\n\nfac(x::arb)\n\n\n\n\n\n\nReturn the factorial of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fac\n \n \nMethod\n.\n\n\nfac(n::Int, r::ArbField)\n\n\n\n\n\n\nReturn the factorial of \nn\n in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.binom\n \n \nMethod\n.\n\n\nbinom(x::arb, n::UInt)\n\n\n\n\n\n\nReturn the binomial coefficient \n{x \\choose n}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.binom\n \n \nMethod\n.\n\n\nbinom(n::UInt, k::UInt, r::ArbField)\n\n\n\n\n\n\nReturn the binomial coefficient \n{n \\choose k}\n in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fib\n \n \nMethod\n.\n\n\nfib(n::fmpz, r::ArbField)\n\n\n\n\n\n\nReturn the \nn\n-th Fibonacci number in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.fib\n \n \nMethod\n.\n\n\nfib(n::Int, r::ArbField)\n\n\n\n\n\n\nReturn the \nn\n-th Fibonacci number in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.gamma\n \n \nMethod\n.\n\n\ngamma(x::fmpz, r::ArbField)\n\n\n\n\n\n\nReturn the Gamma function evaluated at \nx\n in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.gamma\n \n \nMethod\n.\n\n\ngamma(x::fmpq, r::ArbField)\n\n\n\n\n\n\nReturn the Gamma function evaluated at \nx\n in the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.zeta\n \n \nMethod\n.\n\n\nzeta(n::Int, r::ArbField)\n\n\n\n\n\n\nReturn the Riemann zeta function \n\\zeta(n)\n as an element of the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bernoulli\n \n \nMethod\n.\n\n\nbernoulli(n::Int, r::ArbField)\n\n\n\n\n\n\nReturn the \nn\n-th Bernoulli number as an element of the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.risingfac\n \n \nMethod\n.\n\n\nrisingfac(x::arb, n::Int)\n\n\n\n\n\n\nReturn the rising factorial \nx(x + 1)\\ldots (x + n - 1)\n as an Arb.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.risingfac\n \n \nMethod\n.\n\n\nrisingfac(x::fmpq, n::Int, r::ArbField)\n\n\n\n\n\n\nReturn the rising factorial \nx(x + 1)\\ldots (x + n - 1)\n as an element of the given Arb field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.risingfac2\n \n \nMethod\n.\n\n\nrisingfac2(x::arb, n::Int)\n\n\n\n\n\n\nReturn a tuple containing the rising factorial \nx(x + 1)\\ldots (x + n - 1)\n and its derivative.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.polylog\n \n \nMethod\n.\n\n\npolylog(s::arb, a::arb)\n\n\n\n\n\n\nReturn the polylogarithm Li\n_s(a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.polylog\n \n \nMethod\n.\n\n\npolylog(s::Int, a::arb)\n\n\n\n\n\n\nReturn the polylogarithm Li\n_s(a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chebyshev_t\n \n \nMethod\n.\n\n\nchebyshev_t(n::Int, x::arb)\n\n\n\n\n\n\nReturn the value of the Chebyshev polynomial \nT_n(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chebyshev_u\n \n \nMethod\n.\n\n\nchebyshev_u(n::Int, x::arb)\n\n\n\n\n\n\nReturn the value of the Chebyshev polynomial \nU_n(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chebyshev_t2\n \n \nMethod\n.\n\n\nchebyshev_t2(n::Int, x::arb)\n\n\n\n\n\n\nReturn the tuple \n(T_{n}(x), T_{n-1}(x))\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chebyshev_u2\n \n \nMethod\n.\n\n\nchebyshev_u2(n::Int, x::arb)\n\n\n\n\n\n\nReturn the tuple \n(U_{n}(x), U_{n-1}(x))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bell\n \n \nMethod\n.\n\n\nbell(n::fmpz, r::ArbField)\n\n\n\n\n\n\nReturn the Bell number \nB_n\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bell\n \n \nMethod\n.\n\n\nbell(n::Int, r::ArbField)\n\n\n\n\n\n\nReturn the Bell number \nB_n\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.numpart\n \n \nMethod\n.\n\n\nnumpart(n::fmpz, r::ArbField)\n\n\n\n\n\n\nReturn the number of partitions \np(n)\n as an element of \nr\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.numpart\n \n \nMethod\n.\n\n\nnumpart(n::fmpz, r::ArbField)\n\n\n\n\n\n\nReturn the number of partitions \np(n)\n as an element of \nr\n.\n\n\n\n\nsource\n\n\nHere are some examples of real valued mathematical functions.\n\n\nRR = RealField(64)\n\na = floor(exp(RR(1)))\nb = sinpi(QQ(5,6), RR)\nc = gamma(QQ(1,3), RealField(256))\nd = bernoulli(1000, RealField(53))\nf = polylog(3, RR(-10))", 
            "title": "Real balls"
        }, 
        {
            "location": "/arb/#introduction", 
            "text": "Arbitrary precision real ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Real numbers are  represented in mid-rad interval form  [m \\pm r] = [m-r, m+r] .  The Arb real field is constructed using the  ArbField  constructor. This constructs the parent object for the Arb real field.  However, we define  RealField = ArbField  so that one can construct the Arb real field parent object using  RealField  instead of  ArbField .  The types of real balls in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.     Library  Field  Element type  Parent type      Arb   \\mathbb{R}  (balls)  arb  ArbField     All the real field types belong to the  Field  abstract type and the types of elements in this field, i.e. balls in this case, belong to the  FieldElem  abstract type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/arb/#real-field-constructors", 
            "text": "In order to construct real balls in Nemo, one must first construct the Arb real field itself. This is accomplished with the following constructor.  ArbField(prec::Int)  Return the Arb field with precision in bits  prec  used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).  We define  RealField = ArbField  so that one can use  RealField  in place of  ArbField .  Here is an example of creating an Arb real field and using the resulting parent object to coerce values into the resulting field.  RR = RealField(64)\n\na = RR( 0.25 )\nb = RR( 0.1 )\nc = RR(0.5)\nd = RR(12)  Note that whilst one can coerce double precision floating point values into an Arb real field, unless those values can be represented exactly in double precision, the resulting ball can't be any more precise than the double precision supplied.  If instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb field.  If the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function  isexact  below for more information.", 
            "title": "Real field constructors"
        }, 
        {
            "location": "/arb/#real-ball-constructors", 
            "text": "Once an Arb real field is constructed, there are various ways to construct balls in that field.  Apart from coercing elements into the Arb real field as above, we offer the following functions.  #  Base.zero     Method .  zero(R::ArbField)   Return exact zero in the given Arb field.   source  #  Base.one     Method .  one(R::ArbField)   Return exact one in the given Arb field.   source  #  Nemo.ball     Method .  ball(mid::arb, rad::arb)   Constructs an  arb  enclosing the range  [m-|r|, m+|r|] , given the pair  (m, r) .   source  Here are some examples of constructing balls.  RR = RealField(64)\n\na = zero(RR)\nb = one(RR)\nc = ball(RR(3), RR( 0.0001 ))", 
            "title": "Real ball constructors"
        }, 
        {
            "location": "/arb/#basic-functionality", 
            "text": "The following basic functionality is provided by the default Arb real field implementation in Nemo, to support construction of generic rings over real fields. Any custom real field implementation in Nemo should provide analogues of these functions along with the usual arithmetic operations.  parent_type(::Type{arb})  Gives the type of the parent object of an Arb real field element.  elem_type(R::ArbField)  Given the parent object for a Arb field, return the type of elements of the field.  mul!(c::arb, a::arb, b::arb)  Multiply  a  by  b  and set the existing Arb field element  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::arb, a::arb)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  deepcopy(a::arb)  Return a copy of the Arb field element  a , recursively copying the internal data. Arb field elements are mutable in Nemo so a shallow copy is not sufficient.  Given the parent object  R  for an Arb real field, the following coercion functions are provided to coerce various elements into the Arb field. Developers provide these by overloading the  call  operator for the real field parent objects.  R()  Coerce zero into the Arb field.  R(n::Integer)\nR(f::fmpz)\nR(q::fmpq)  Coerce an integer or rational value into the Arb field.  R(f::Float64)\nR(f::BigFloat)  Coerce the given floating point number into the Arb field.  R(f::AbstractString)  Coerce the decimal number, given as a string, into the Arb field.  R(f::arb)  Take an Arb field element that is already in the Arb field and simply return it. A copy of the original is not made.  Here are some examples of coercing elements into the Arb field.  RR = RealField(64)\n\na = RR(3)\nb = RR(QQ(2,3))\nc = ball(RR(3), RR( 0.0001 ))\nd = RR( 3 +/- 0.0001 )\nf = RR( -1.24e+12345 )\ng = RR( nan +/- inf )  In addition to the above, developers of custom real field types must ensure that they provide the equivalent of the function  base_ring(R::ArbField)  which should return  Union{} . In addition to this they should ensure that each real field element contains a field  parent  specifying the parent object of the real field element, or at least supply the equivalent of the function  parent(a::arb)  to return the parent object of a real field element.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/arb/#conversions", 
            "text": "#  Base.convert     Method .  convert(::Type{Float64}, x::arb)   Return the midpoint of  x  rounded down to a machine double.   source", 
            "title": "Conversions"
        }, 
        {
            "location": "/arb/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate Arb field elements. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(R::ArbField)   Returns  Union{}  since an Arb field does not depend on any other ring.   source  #  Nemo.base_ring     Method .  base_ring(x::arb)   Returns  Union{}  since an Arb field does not depend on any other ring.   source  #  Base.parent     Method .  parent(x::arb)   Return the parent of the given Arb field element.   source  #  Nemo.iszero     Method .  iszero(x::arb)   Return  true  if  x  is certainly zero, otherwise return  false .   source  #  Nemo.isnonzero     Method .  isnonzero(x::arb)   Return  true  if  x  is certainly not equal to zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(x::arb)   Return  true  if  x  is certainly not equal to oneo, otherwise return  false .   source  #  Base.isfinite     Method .  isfinite(x::arb)   Return  true  if  x  is finite, i.e. having finite midpoint and radius, otherwise return  false .   source  #  Nemo.isexact     Method .  isexact(x::arb)   Return  true  if  x  is exact, i.e. has zero radius, otherwise return  false .   source  #  Nemo.isint     Method .  isint(x::arb)   Return  true  if  x  is an exact integer, otherwise return  false .   source  #  Nemo.ispositive     Method .  ispositive(x::arb)   Return  true  if  x  is certainly positive, otherwise return  false .   source  #  Nemo.isnonnegative     Method .  isnonnegative(x::arb)   Return  true  if  x  is certainly nonnegative, otherwise return  false .   source  #  Nemo.isnegative     Method .  isnegative(x::arb)   Return  true  if  x  is certainly negative, otherwise return  false .   source  #  Nemo.isnonpositive     Method .  isnonpositive(x::arb)   Return  true  if  x  is certainly nonpositive, otherwise return  false .   source  #  Nemo.midpoint     Method .  midpoint(x::arb)   Return the midpoint of the ball  x  as an Arb ball.   source  #  Nemo.radius     Method .  radius(x::arb)   Return the radius of the ball  x  as an Arb ball.   source  #  Nemo.accuracy_bits     Method .  accuracy_bits(x::arb)   Return the relative accuracy of  x  measured in bits, capped between  typemax(Int)  and  -typemax(Int) .   source  Here are some examples of basic manipulation of Arb balls.  RR = RealField(64)\n\na = RR( 1.2 +/- 0.001 )\nb = RR(3)\n\niszero(a)\nisone(b)\nispositive(a)\nisfinite(b)\nisint(b)\nisnegative(a)\nc = radius(a)\nd = midpoint(b)\nf = accuracy_bits(a)\nS = parent(a)\nT = base_ring(RR)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/arb/#arithmetic-operations", 
            "text": "Nemo provides all the standard field operations for Arb field elements, as follows. Note that division is represented by  //  since a field is its own fraction field and since exact division is not generally possible in an inexact field.     Function  Operation      -(a::arb)  unary minus    +(a::arb, b::arb)  addition    -(a::arb, b::arb)  subtraction    *(a::arb, b::arb)  multiplication    //(a::arb, b::arb)  division    ^(a::arb, b::arb)  powering     In addition, the following ad hoc field operations are defined.     Function  Operation      +(a::arb, b::Integer)  addition    +(a::Integer, b::arb)  addition    +(a::arb, b::fmpz)  addition    +(a::fmpz, b::arb)  addition    -(a::arb, b::Integer)  subtraction    -(a::Integer, b::arb)  subtraction    -(a::arb, b::fmpz)  subtraction    -(a::fmpz, b::arb)  subtraction    *(a::arb, b::Integer)  multiplication    *(a::Integer, b::arb)  multiplication    *(a::arb, b::fmpz)  multiplication    *(a::fmpz, b::arb)  multiplication    //(a::arb, b::Integer)  division    //(a::arb, b::fmpz)  division    //(a::Integer, b::arb)  division    //(a::fmpz, b::arb)  division    ^(a::arb, b::Integer)  powering    ^(a::arb, b::fmpz)  powering    ^(a::arb, b::fmpq)  powering     Here are some examples of arithmetic operations on Arb balls.  RR = RealField(64)\n\nx = RR(3)\ny = RR(QQ(2,3))\n\na = x + y\nb = x*y\nd = 1//y - x\nd = 3x + ZZ(100)//y\nf = (x^2 + y^2) ^ QQ(1,2)", 
            "title": "Arithmetic operations"
        }, 
        {
            "location": "/arb/#containment", 
            "text": "It is often necessary to determine whether a given exact value or ball is contained in a given real ball or whether two balls overlap. The following functions are provided for this purpose.  #  Nemo.overlaps     Method .  overlaps(x::arb, y::arb)   Returns  true  if any part of the ball  x  overlaps any part of the ball  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb, y::arb)   Returns  true  if the ball  x  contains the ball  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb, y::Integer)   Returns  true  if the ball  x  contains the given integer value, otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb, y::fmpz)   Returns  true  if the ball  x  contains the given integer value, otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb, y::fmpq)   Returns  true  if the ball  x  contains the given rational value, otherwise return  false .   source  #  Base.contains     Method .  contains(x::arb, y::BigFloat)   Returns  true  if the ball  x  contains the given floating point value,  otherwise return  false .   source  The following functions are also provided for determining if a ball intersects a certain part of the real number line.  #  Nemo.contains_zero     Method .  contains_zero(x::arb)   Returns  true  if the ball  x  contains zero, otherwise return  false .   source  #  Nemo.contains_negative     Method .  contains_negative(x::arb)   Returns  true  if the ball  x  contains any negative value, otherwise return  false .   source  #  Nemo.contains_positive     Method .  contains_positive(x::arb)   Returns  true  if the ball  x  contains any positive value, otherwise return  false .   source  #  Nemo.contains_nonnegative     Method .  contains_nonnegative(x::arb)   Returns  true  if the ball  x  contains any nonnegative value, otherwise return  false .   source  #  Nemo.contains_nonpositive     Method .  contains_nonpositive(x::arb)   Returns  true  if the ball  x  contains any nonpositive value, otherwise return  false .   source  Here are some examples of testing containment.  RR = RealField(64)\nx = RR( 1 +/- 0.001 )\ny = RR( 3 )\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)\ncontains_positive(y)", 
            "title": "Containment"
        }, 
        {
            "location": "/arb/#comparison", 
            "text": "Nemo provides a full range of comparison operations for Arb balls. Note that a ball is considered less than another ball if every value in the first ball is less than every value in the second ball, etc.  Firstly, we introduce an exact equality which is distinct from arithmetic equality. This is distinct from arithmetic equality implemented by  == , which merely compares up to the minimum of the precisions of its operands.  #  Base.isequal     Method .  isequal(x::arb, y::arb)   Return  true  if the balls  x  and  y  are precisely equal, i.e. have the same midpoints and radii.   source  A full range of functions is available for comparing balls, i.e.  == ,  != ,  ,  = ,  = ,  . In fact, all these are implemented directly in C. In the table below we document these as though only  ==  and  isless  had been provided to Julia.", 
            "title": "Comparison"
        }, 
        {
            "location": "/arb/#function", 
            "text": "isless(x::arb, y::arb)    ==(x::arb, y::arb)  As well as these, we provide a full range of ad hoc comparison operators. Again, these are implemented directly in Julia, but we document them as though  isless  and  ==  were provided.", 
            "title": "Function"
        }, 
        {
            "location": "/arb/#function_1", 
            "text": "==(x::arb, y::Integer)   ==(x::Integer, y::arb)   ==(x::arb, y::fmpz)   ==(x::fmpz, y::arb)   ==(x::arb, y::Float64)   ==(x::Float64, y::arb)   isless(x::arb, y::Integer)   isless(x::Integer, y::arb)   isless(x::arb, y::fmpz)   isless(x::fmpz, y::arb)   isless(x::arb, y::Float64)   isless(x::Float64, y::arb)  Here are some examples of comparison.  RR = RealField(64)\nx = RR( 1 +/- 0.001 )\ny = RR( 3 )\nz = RR( 4 )\n\nisequal(y, z)\nx  = z\nx == 3\nZZ(3)   z\nx != 1.23", 
            "title": "Function"
        }, 
        {
            "location": "/arb/#absolute-value", 
            "text": "#  Base.abs     Method .  abs(x::arb)   Return the absolute value of  x .   source  Here are some examples of taking the absolute value.  RR = RealField(64)\nx = RR( -1 +/- 0.001 )\n\na = abs(x)", 
            "title": "Absolute value"
        }, 
        {
            "location": "/arb/#inverse", 
            "text": "#  Base.inv     Method .  inv(x::arb)   Return the multiplicative inverse of  x , i.e.  1/x .   source  Here are some examples of taking the inverse.  RR = RealField(64)\nx = RR( -3 +/- 0.001 )\n\na = inv(x)", 
            "title": "Inverse"
        }, 
        {
            "location": "/arb/#shifting", 
            "text": "#  Base.Math.ldexp     Method .  ldexp(x::arb, y::Int)   Return  2^yx . Note that  y  can be positive, zero or negative.   source  #  Base.Math.ldexp     Method .  ldexp(x::arb, y::fmpz)   Return  2^yx . Note that  y  can be positive, zero or negative.   source  Here are some examples of shifting.  RR = RealField(64)\nx = RR( -3 +/- 0.001 )\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))", 
            "title": "Shifting"
        }, 
        {
            "location": "/arb/#miscellaneous-operations", 
            "text": "#  Nemo.trim     Method .  trim(x::arb)   Return an  arb  interval containing  x  but which may be more economical, by rounding off insignificant bits from the midpoint.   source  #  Nemo.unique_integer     Method .  unique_integer(x::arb)   Return a pair where the first value is a boolean and the second is an  fmpz  integer. The boolean indicates whether the interval  x  contains a unique integer. If this is the case, the second return value is set to this unique integer.   source  #  Nemo.setunion     Method .  setunion(x::arb, y::arb)   Return an  arb  containing the union of the intervals represented by  x  and  y .   source  Here are some examples of miscellaneous operations.  RR = RealField(64)\nx = RR( -3 +/- 0.001 )\ny = RR( 2 +/- 0.5 )\n\na = trim(x)\nb, c = unique_integer(x)\nd = setunion(x, y)", 
            "title": "Miscellaneous operations"
        }, 
        {
            "location": "/arb/#constants", 
            "text": "#  Nemo.const_pi     Method .  const_pi(r::ArbField)   Return  \\pi = 3.14159\\ldots  as an element of  r .   source  #  Nemo.const_e     Method .  const_e(r::ArbField)   Return  e = 2.71828\\ldots  as an element of  r .   source  #  Nemo.const_log2     Method .  const_log2(r::ArbField)   Return  \\log(2) = 0.69314\\ldots  as an element of  r .   source  #  Nemo.const_log10     Method .  const_log10(r::ArbField)   Return  \\log(10) = 2.302585\\ldots  as an element of  r .   source  #  Nemo.const_euler     Method .  const_euler(r::ArbField)   Return Euler's constant  \\gamma = 0.577215\\ldots  as an element of  r .   source  #  Nemo.const_catalan     Method .  const_catalan(r::ArbField)   Return Catalan's constant  C = 0.915965\\ldots  as an element of  r .   source  #  Nemo.const_khinchin     Method .  const_khinchin(r::ArbField)   Return Khinchin's constant  K = 2.685452\\ldots  as an element of  r .   source  #  Nemo.const_glaisher     Method .  const_glaisher(r::ArbField)   Return Glaisher's constant  A = 1.282427\\ldots  as an element of  r .   source  Here are some examples of computing real constants.  RR = RealField(200)\n\na = const_pi(RR)\nb = const_e(RR)\nc = const_euler(RR)\nd = const_glaisher(RR)", 
            "title": "Constants"
        }, 
        {
            "location": "/arb/#mathematical-functions", 
            "text": "#  Base.floor     Method .  floor(x::arb)   Compute the floor of  x , i.e. the greatest integer not exceeding  x , as an Arb.   source  #  Base.ceil     Method .  ceil(x::arb)   Return the ceiling of  x , i.e. the least integer not less than  x , as an Arb.   source  #  Base.sqrt     Method .  sqrt(x::arb)   Return the square root of  x .   source  #  Nemo.rsqrt     Method .  rsqrt(x::arb)   Return the reciprocal of the square root of  x , i.e.  1/\\sqrt{x} .   source  #  Nemo.sqrt1pm1     Method .  sqrt1pm1(x::arb)   Return  \\sqrt{1+x}-1 , evaluated accurately for small  x .   source  #  Base.log     Method .  log(x::arb)   Return the principal branch of the logarithm of  x .   source  #  Base.log1p     Method .  log1p(x::arb)   Return  \\log(1+x) , evaluated accurately for small  x .   source  #  Base.exp     Method .  exp(x::arb)   Return the exponential of  x .   source  #  Base.expm1     Method .  expm1(x::arb)   Return  \\exp(x)-1 , evaluated accurately for small  x .   source  #  Base.sin     Method .  sin(x::arb)   Return the sine of  x .   source  #  Base.cos     Method .  cos(x::arb)   Return the cosine of  x .   source  #  Base.Math.sinpi     Method .  sinpi(x::arb)   Return the sine of  \\pi x .   source  #  Base.Math.cospi     Method .  cospi(x::arb)   Return the cosine of  \\pi x .   source  #  Base.tan     Method .  tan(x::arb)   Return the tangent of  x .   source  #  Base.Math.cot     Method .  cot(x::arb)   Return the cotangent of  x .   source  #  Nemo.tanpi     Method .  tanpi(x::arb)   Return the tangent of  \\pi x .   source  #  Nemo.cotpi     Method .  cotpi(x::arb)   Return the cotangent of  \\pi x .   source  #  Base.sinh     Method .  sinh(x::arb)   Return the hyperbolic sine of  x .   source  #  Base.cosh     Method .  cosh(x::arb)   Return the hyperbolic cosine of  x .   source  #  Base.tanh     Method .  tanh(x::arb)   Return the hyperbolic tangent of  x .   source  #  Base.Math.coth     Method .  coth(x::arb)   Return the hyperbolic cotangent of  x .   source  #  Base.atan     Method .  atan(x::arb)   Return the arctangent of  x .   source  #  Base.asin     Method .  asin(x::arb)   Return the arcsine of  x .   source  #  Base.acos     Method .  acos(x::arb)   Return the arccosine of  x .   source  #  Base.atanh     Method .  atanh(x::arb)   Return the hyperbolic arctangent of  x .   source  #  Base.asinh     Method .  asinh(x::arb)   Return the hyperbolic arcsine of  x .   source  #  Base.acosh     Method .  acosh(x::arb)   Return the hyperbolic arccosine of  x .   source  #  Base.Math.gamma     Method .  gamma(x::arb)   Return the Gamma function evaluated at  x .   source  #  Base.Math.lgamma     Method .  lgamma(x::arb)   Return the logarithm of the Gamma function evaluated at  x .   source  #  Nemo.rgamma     Method .  rgamma(x::arb)   Return the reciprocal of the Gamma function evaluated at  x .   source  #  Base.Math.digamma     Method .  digamma(x::arb)   Return the  logarithmic derivative of the gamma function evaluated at  x , i.e.  \\psi(x) .   source  #  Base.Math.zeta     Method .  zeta(x::arb)   Return the Riemann zeta function evaluated at  x .   source  #  Nemo.sincos     Method .  sincos(x::arb)   Return a tuple  s, c  consisting of the sine  s  and cosine  c  of  x .   source  #  Nemo.sincospi     Method .  sincospi(x::arb)   Return a tuple  s, c  consisting of the sine  s  and cosine  c  of  \\pi x .   source  #  Base.Math.sinpi     Method .  sinpi(x::fmpq, r::ArbField)   Return the sine of  \\pi x  in the given Arb field.   source  #  Base.Math.cospi     Method .  cospi(x::fmpq, r::ArbField)   Return the cosine of  \\pi x  in the given Arb field.   source  #  Nemo.sincospi     Method .  sincospi(x::fmpq, r::ArbField)   Return a tuple  s, c  consisting of the sine and cosine of  \\pi x  in the given Arb field.   source  #  Nemo.sinhcosh     Method .  sinhcosh(x::arb)   Return a tuple  s, c  consisting of the hyperbolic sine and cosine of  x .   source  #  Base.Math.atan2     Method .  atan2(x::arb, y::arb)   Return atan2 (b,a) = \\arg(a+bi) .   source  #  Nemo.agm     Method .  agm(x::arb, y::arb)   Return the arithmetic-geometric mean of  x  and  y    source  #  Base.Math.zeta     Method .  zeta(s::arb, a::arb)   Return the Hurwitz zeta function  \\zeta(s,a) .   source  #  Base.Math.hypot     Method .  hypot(x::arb, y::arb)   Return  \\sqrt{x^2 + y^2} .   source  #  Nemo.root     Method .  root(x::arb, n::Int)   Return the  n -th root of  x . We require  x \\geq 0 .   source  #  Nemo.fac     Method .  fac(x::arb)   Return the factorial of  x .   source  #  Nemo.fac     Method .  fac(n::Int, r::ArbField)   Return the factorial of  n  in the given Arb field.   source  #  Nemo.binom     Method .  binom(x::arb, n::UInt)   Return the binomial coefficient  {x \\choose n} .   source  #  Nemo.binom     Method .  binom(n::UInt, k::UInt, r::ArbField)   Return the binomial coefficient  {n \\choose k}  in the given Arb field.   source  #  Nemo.fib     Method .  fib(n::fmpz, r::ArbField)   Return the  n -th Fibonacci number in the given Arb field.   source  #  Nemo.fib     Method .  fib(n::Int, r::ArbField)   Return the  n -th Fibonacci number in the given Arb field.   source  #  Base.Math.gamma     Method .  gamma(x::fmpz, r::ArbField)   Return the Gamma function evaluated at  x  in the given Arb field.   source  #  Base.Math.gamma     Method .  gamma(x::fmpq, r::ArbField)   Return the Gamma function evaluated at  x  in the given Arb field.   source  #  Base.Math.zeta     Method .  zeta(n::Int, r::ArbField)   Return the Riemann zeta function  \\zeta(n)  as an element of the given Arb field.   source  #  Nemo.bernoulli     Method .  bernoulli(n::Int, r::ArbField)   Return the  n -th Bernoulli number as an element of the given Arb field.   source  #  Nemo.risingfac     Method .  risingfac(x::arb, n::Int)   Return the rising factorial  x(x + 1)\\ldots (x + n - 1)  as an Arb.   source  #  Nemo.risingfac     Method .  risingfac(x::fmpq, n::Int, r::ArbField)   Return the rising factorial  x(x + 1)\\ldots (x + n - 1)  as an element of the given Arb field.   source  #  Nemo.risingfac2     Method .  risingfac2(x::arb, n::Int)   Return a tuple containing the rising factorial  x(x + 1)\\ldots (x + n - 1)  and its derivative.   source  #  Nemo.polylog     Method .  polylog(s::arb, a::arb)   Return the polylogarithm Li _s(a) .   source  #  Nemo.polylog     Method .  polylog(s::Int, a::arb)   Return the polylogarithm Li _s(a) .   source  #  Nemo.chebyshev_t     Method .  chebyshev_t(n::Int, x::arb)   Return the value of the Chebyshev polynomial  T_n(x) .   source  #  Nemo.chebyshev_u     Method .  chebyshev_u(n::Int, x::arb)   Return the value of the Chebyshev polynomial  U_n(x) .   source  #  Nemo.chebyshev_t2     Method .  chebyshev_t2(n::Int, x::arb)   Return the tuple  (T_{n}(x), T_{n-1}(x)) .   source  #  Nemo.chebyshev_u2     Method .  chebyshev_u2(n::Int, x::arb)   Return the tuple  (U_{n}(x), U_{n-1}(x))    source  #  Nemo.bell     Method .  bell(n::fmpz, r::ArbField)   Return the Bell number  B_n  as an element of  r .   source  #  Nemo.bell     Method .  bell(n::Int, r::ArbField)   Return the Bell number  B_n  as an element of  r .   source  #  Nemo.numpart     Method .  numpart(n::fmpz, r::ArbField)   Return the number of partitions  p(n)  as an element of  r .   source  #  Nemo.numpart     Method .  numpart(n::fmpz, r::ArbField)   Return the number of partitions  p(n)  as an element of  r .   source  Here are some examples of real valued mathematical functions.  RR = RealField(64)\n\na = floor(exp(RR(1)))\nb = sinpi(QQ(5,6), RR)\nc = gamma(QQ(1,3), RealField(256))\nd = bernoulli(1000, RealField(53))\nf = polylog(3, RR(-10))", 
            "title": "Mathematical functions"
        }, 
        {
            "location": "/acb/", 
            "text": "Introduction\n\n\nArbitrary precision complex ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Complex numbers are  represented in in rectangular form \na+bi\n where \na,b\n are \narb\n balls.\n\n\nThe Arb complex field is constructed using the \nAcbField\n constructor. This constructs the parent object for the Arb complex field.\n\n\nWe define\n\n\nComplexField = AcbField\n\n\n\n\nso that one can construct the Arb complex field parent using \nComplexField\n instead of \nAcbField\n.\n\n\nThe types of complex boxes in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.\n\n\n\n\n\n\n\n\nLibrary\n\n\nField\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nArb\n\n\n\n\n\\mathbb{C}\n (boxes)\n\n\nacb\n\n\nAcbField\n\n\n\n\n\n\n\n\nAll the complex field types belong to the \nField\n abstract type and the types of elements in this field, i.e. complex boxes in this case, belong to the \nFieldElem\n abstract type.\n\n\n\n\nComplex field constructors\n\n\nIn order to construct complex boxes in Nemo, one must first construct the Arb complex field itself. This is accomplished with the following constructor.\n\n\nAcbField(prec::Int)\n\n\n\n\nReturn the Arb complex field with precision in bits \nprec\n used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).\n\n\nWe define\n\n\nComplexField = AcbField\n\n\n\n\nso that one can use \nComplexField\n instead of \nAcbField\n.\n\n\nHere is an example of creating an Arb complex field and using the resulting parent object to coerce values into the resulting field.\n\n\nCC = ComplexField(64)\n\na = CC(\n0.25\n)\nb = CC(\n0.1\n)\nc = CC(0.5)\nd = CC(12)\n\n\n\n\nNote that whilst one can coerce double precision floating point values into an Arb complex field, unless those values can be represented exactly in double precision, the resulting ball can't be any more precise than the double precision supplied.\n\n\nIf instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb complex field.\n\n\nIf the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function \nisexact\n below for more information.\n\n\n\n\nComplex ball constructors\n\n\nOnce an Arb complex field is constructed, there are various ways to construct boxes in that field.\n\n\nApart from coercing elements into the Arb complex field as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::AcbField)\n\n\n\n\n\n\nReturn exact zero in the given Arb complex field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::AcbField)\n\n\n\n\n\n\nReturn exact one in the given Arb complex field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.onei\n \n \nMethod\n.\n\n\nonei(R::AcbField)\n\n\n\n\n\n\nReturn exact one times \ni\n in the given Arb complex field.\n\n\n\n\nsource\n\n\nHere are some examples of constructing complex boxes.\n\n\nCC = ComplexField(64)\n\na = zero(CC)\nb = one(CC)\nc = onei(CC)\n\n\n\n\n\n\nBasic functionality\n\n\nThe following basic functionality is provided by the default Arb complex field implementation in Nemo, to support construction of generic rings over complex fields. Any custom complex field implementation in Nemo should provide analogues of these functions along with the usual arithmetic operations.\n\n\nparent_type(::Type{acb})\n\n\n\n\nGives the type of the parent object of an Arb complex field element.\n\n\nelem_type(R::AcbField)\n\n\n\n\nGiven the parent object for an Arb complex field, return the type of elements of the field.\n\n\nmul!(c::acb, a::acb, b::acb)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing Arb complex field element \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::acb, a::acb)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\ndeepcopy(a::acb)\n\n\n\n\nReturn a copy of the Arb complex field element \na\n, recursively copying the internal data. Arb complex field elements are mutable in Nemo so a shallow copy is not sufficient.\n\n\nGiven the parent object \nR\n for an Arb complex field, the following coercion functions are provided to coerce various elements into the Arb complex field. Developers provide these by overloading the \ncall\n operator for the complex field parent objects.\n\n\nR()\n\n\n\n\nCoerce zero into the Arb complex field.\n\n\nR(n::Integer)\nR(f::fmpz)\nR(q::fmpq)\n\n\n\n\nCoerce an integer or rational value into the Arb complex field.\n\n\nR(f::Float64)\nR(f::BigFloat)\n\n\n\n\nCoerce the given floating point number into the Arb complex field.\n\n\nR(f::AbstractString)\nR(f::AbstractString, g::AbstractString)\n\n\n\n\nCoerce the decimal number, given as a string, into the Arb complex field. In each case \nf\n is the real part and \ng\n is the imaginary part.\n\n\nR(f::arb)\n\n\n\n\nCoerce the given Arb real ball into the Arb complex field.\n\n\nR(f::acb)\n\n\n\n\nTake an Arb complex field element that is already in an Arb field and simply return it. A copy of the original is not made.\n\n\nHere are some examples of coercing elements into the Arb complex field.\n\n\nRR = RealField(64)\nCC = ComplexField(64)\n\na = CC(3)\nb = CC(QQ(2,3))\nc = CC(\n3 +/- 0.0001\n)\nd = CC(\n-1.24e+12345\n)\nf = CC(\nnan +/- inf\n)\ng = CC(RR(3))\n\n\n\n\nIn addition to the above, developers of custom complex field types must ensure that they provide the equivalent of the function \nbase_ring(R::AcbField)\n which should return \nUnion{}\n. In addition to this they should ensure that each complex field element contains a field \nparent\n specifying the parent object of the complex field element, or at least supply the equivalent of the function \nparent(a::acb)\n to return the parent object of a complex field element.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate Arb complex field elements. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(R::AcbField)\n\n\n\n\n\n\nReturns \nUnion{}\n since an Arb complex field does not depend on any other ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::acb)\n\n\n\n\n\n\nReturns \nUnion{}\n since an Arb complex field does not depend on any other ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(x::acb)\n\n\n\n\n\n\nReturn the parent of the given Arb complex field element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(x::acb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(x::acb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is certainly zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isfinite\n \n \nMethod\n.\n\n\nisfinite(x::acb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is finite, i.e. its real and imaginary parts have finite midpoint and radius, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isexact\n \n \nMethod\n.\n\n\nisexact(x::acb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is exact, i.e. has its real and imaginary parts have zero radius, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isint\n \n \nMethod\n.\n\n\nisint(x::acb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is an exact integer, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isreal\n \n \nMethod\n.\n\n\nisint(x::acb)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is purely real, i.e. having zero imaginary part, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.real\n \n \nMethod\n.\n\n\nreal(x::acb)\n\n\n\n\n\n\nReturn the real part of \nx\n as an \narb\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.imag\n \n \nMethod\n.\n\n\nimag(x::acb)\n\n\n\n\n\n\nReturn the imaginary part of \nx\n as an \narb\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.accuracy_bits\n \n \nMethod\n.\n\n\naccuracy_bits(x::acb)\n\n\n\n\n\n\nReturn the relative accuracy of \nx\n measured in bits, capped between \ntypemax(Int)\n and \n-typemax(Int)\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of Arb complex boxes.\n\n\nCC = ComplexField(64)\n\na = CC(\n1.2 +/- 0.001\n)\nb = CC(3)\n\niszero(a)\nisone(b)\nisreal(a)\nisfinite(b)\nisint(b)\nc = real(a)\nd = imag(b)\nf = accuracy_bits(a)\nS = parent(a)\nT = base_ring(CC)\n\n\n\n\n\n\nArithmetic operations\n\n\nNemo provides all the standard field operations for Arb complex field elements, as follows. Note that division is represented by \n//\n since a field is its own fraction field and since exact division is not generally possible in an inexact field.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::acb)\n\n\nunary minus\n\n\n\n\n\n\n+(a::acb, b::acb)\n\n\naddition\n\n\n\n\n\n\n-(a::acb, b::acb)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::acb, b::acb)\n\n\nmultiplication\n\n\n\n\n\n\n//(a::acb, b::acb)\n\n\ndivision\n\n\n\n\n\n\n^(a::acb, b::acb)\n\n\npowering\n\n\n\n\n\n\n\n\nIn addition, the following ad hoc field operations are defined.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::acb, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::Integer, b::acb)\n\n\naddition\n\n\n\n\n\n\n+(a::acb, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::acb)\n\n\naddition\n\n\n\n\n\n\n+(a::acb, b::fmpq)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpq, b::acb)\n\n\naddition\n\n\n\n\n\n\n+(a::acb, b::arb)\n\n\naddition\n\n\n\n\n\n\n+(a::arb, b::acb)\n\n\naddition\n\n\n\n\n\n\n-(a::acb, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::Integer, b::acb)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::acb, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::acb)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::acb, b::fmpq)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpq, b::acb)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::acb, b::arb)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::arb, b::acb)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::acb, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::Integer, b::acb)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::acb, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::acb)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::acb, b::fmpq)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpq, b::acb)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::acb, b::arb)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::arb, b::acb)\n\n\nmultiplication\n\n\n\n\n\n\n//(a::acb, b::Integer)\n\n\ndivision\n\n\n\n\n\n\n//(a::acb, b::fmpz)\n\n\ndivision\n\n\n\n\n\n\n//(a::acb, b::fmpq)\n\n\ndivision\n\n\n\n\n\n\n//(a::Integer, b::acb)\n\n\ndivision\n\n\n\n\n\n\n//(a::fmpz, b::acb)\n\n\ndivision\n\n\n\n\n\n\n//(a::fmpq, b::acb)\n\n\ndivision\n\n\n\n\n\n\n//(a::arb, b::acb)\n\n\ndivision\n\n\n\n\n\n\n^(a::acb, b::fmpq)\n\n\npowering\n\n\n\n\n\n\n^(a::Integer, b::acb)\n\n\npowering\n\n\n\n\n\n\n^(a::fmpz, b::acb)\n\n\npowering\n\n\n\n\n\n\n^(a::fmpq, b::acb)\n\n\npowering\n\n\n\n\n\n\n^(a::arb, b::acb)\n\n\npowering\n\n\n\n\n\n\n\n\nHere are some examples of arithmetic operations on Arb complex boxes.\n\n\nCC = ComplexField(64)\n\nx = CC(3)\ny = CC(QQ(2,3))\n\na = x + y\nb = x*y\nd = 1//y - x\nd = 3x + ZZ(100)//y\nf = (x^2 + y^2) ^ QQ(1,2)\n\n\n\n\n\n\nContainment\n\n\nIt is often necessary to determine whether a given exact value or box is contained in a given complex box or whether two boxes overlap. The following functions are provided for this purpose.\n\n\n#\n\n\nNemo.overlaps\n \n \nMethod\n.\n\n\noverlaps(x::acb, y::acb)\n\n\n\n\n\n\nReturns \ntrue\n if any part of the box \nx\n overlaps any part of the box \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb, y::acb)\n\n\n\n\n\n\nReturns \ntrue\n if the box \nx\n contains the box \ny\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb, y::Integer)\n\n\n\n\n\n\nReturns \ntrue\n if the box \nx\n contains the given integer value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb, y::fmpz)\n\n\n\n\n\n\nReturns \ntrue\n if the box \nx\n contains the given integer value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.contains\n \n \nMethod\n.\n\n\ncontains(x::acb, y::fmpq)\n\n\n\n\n\n\nReturns \ntrue\n if the box \nx\n contains the given rational value, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nThe following functions are also provided for determining if a box intersects a certain part of the complex number plane.\n\n\n#\n\n\nNemo.contains_zero\n \n \nMethod\n.\n\n\ncontains_zero(x::acb)\n\n\n\n\n\n\nReturns \ntrue\n if the box \nx\n contains zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of testing containment.\n\n\nCC = ComplexField(64)\nx = CC(\n1 +/- 0.001\n)\ny = CC(\n3\n)\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)\n\n\n\n\n\n\nComparison\n\n\nNemo provides a full range of comparison operations for Arb complex boxes. \n\n\nFirstly, we introduce an exact equality which is distinct from arithmetic equality. This is distinct from arithmetic equality implemented by \n==\n, which merely compares up to the minimum of the precisions of its operands.\n\n\n#\n\n\nBase.isequal\n \n \nMethod\n.\n\n\nisequal(x::acb, y::acb)\n\n\n\n\n\n\nReturn \ntrue\n if the boxes \nx\n and \ny\n are precisely equal, i.e. their real and imaginary parts have the same midpoints and radii.\n\n\n\n\nsource\n\n\nA full range of functions is available for comparing boxes, i.e. \n==\n and \n!=\n. In fact, these are implemented directly in C. In the table below we document these as though only \n==\n had been provided to Julia.\n\n\n\n\nFunction\n\n\n==(x::acb, y::acb)\n\n\nAs well as these, we provide a full range of ad hoc comparison operators. Again, these are implemented directly in Julia, but we document them as though only \n==\n were provided.\n\n\n\n\nFunction\n\n\n==(x::acb, y::Integer)\n \n==(x::Integer, y::acb)\n \n==(x::acb, y::fmpz)\n \n==(x::fmpz, y::acb)\n \n==(x::arb, y::fmpz)\n \n==(x::fmpz, y::arb)\n \n==(x::acb, y::Float64)\n \n==(x::Float64, y::acb)\n\n\nHere are some examples of comparison.\n\n\nCC = ComplexField(64)\nx = CC(\n1 +/- 0.001\n)\ny = CC(\n3\n)\nz = CC(\n4\n)\n\nisequal(y, z)\nx != z\nx == 3\nZZ(3) == z\nx != 1.23\n\n\n\n\n\n\nAbsolute value\n\n\n#\n\n\nBase.abs\n \n \nMethod\n.\n\n\nabs(x::acb)\n\n\n\n\n\n\nReturn the complex absolute value of \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of taking the absolute value.\n\n\nCC = ComplexField(64)\nx = CC(\n-1 +/- 0.001\n)\n\na = abs(x)\n\n\n\n\n\n\nInverse\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(x::acb)\n\n\n\n\n\n\nReturn the multiplicative inverse of \nx\n, i.e. \n1/x\n.\n\n\n\n\nsource\n\n\nHere are some examples of taking the inverse.\n\n\nCC = ComplexField(64)\nx = CC(\n-3 +/- 0.001\n)\n\na = inv(x)\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nBase.Math.ldexp\n \n \nMethod\n.\n\n\nldexp(x::acb, y::Int)\n\n\n\n\n\n\nReturn \n2^yx\n. Note that \ny\n can be positive, zero or negative.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.ldexp\n \n \nMethod\n.\n\n\nldexp(x::acb, y::fmpz)\n\n\n\n\n\n\nReturn \n2^yx\n. Note that \ny\n can be positive, zero or negative.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\nCC = ComplexField(64)\nx = CC(\n-3 +/- 0.001\n)\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))\n\n\n\n\n\n\nMiscellaneous operations\n\n\n#\n\n\nNemo.trim\n \n \nMethod\n.\n\n\ntrim(x::acb)\n\n\n\n\n\n\nReturn an \nacb\n box containing \nx\n but which may be more economical, by rounding off insignificant bits from midpoints.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.unique_integer\n \n \nMethod\n.\n\n\nunique_integer(x::acb)\n\n\n\n\n\n\nReturn a pair where the first value is a boolean and the second is an \nfmpz\n integer. The boolean indicates whether the box \nx\n contains a unique integer. If this is the case, the second return value is set to this unique integer.\n\n\n\n\nsource\n\n\n#\n\n\nBase.conj\n \n \nMethod\n.\n\n\nconj(x::acb)\n\n\n\n\n\n\nReturn the complex conjugate of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.angle\n \n \nMethod\n.\n\n\nangle(x::acb)\n\n\n\n\n\n\nReturn the angle in radians that the complex vector \nx\n makes with the positive real axis in a counterclockwise direction.\n\n\n\n\nsource\n\n\nHere are some examples of miscellaneous operations.\n\n\nCC = ComplexField(64)\nx = CC(\n-3 +/- 0.001\n, \n0.1\n)\n\na = trim(x)\nb, c = unique_integer(x)\nd = conj(x)\nf = angle(x)\n\n\n\n\n\n\nConstants\n\n\nconst_pi(::AcbField)\n\n\n\n\nHere are some examples of computing complex constants.\n\n\nCC = ComplexField(200)\n\na = const_pi(CC)\n\n\n\n\n\n\nMathematical functions\n\n\n#\n\n\nBase.sqrt\n \n \nMethod\n.\n\n\nsqrt(x::acb)\n\n\n\n\n\n\nReturn the square root of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.rsqrt\n \n \nMethod\n.\n\n\nrsqrt(x::acb)\n\n\n\n\n\n\nReturn the reciprocal of the square root of \nx\n, i.e. \n1/\\sqrt{x}\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.log\n \n \nMethod\n.\n\n\nlog(x::acb)\n\n\n\n\n\n\nReturn the principal branch of the logarithm of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.log1p\n \n \nMethod\n.\n\n\nlog1p(x::acb)\n\n\n\n\n\n\nReturn \n\\log(1+x)\n, evaluated accurately for small \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.exp\n \n \nMethod\n.\n\n\nexp(x::acb)\n\n\n\n\n\n\nReturn the exponential of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.exppii\n \n \nMethod\n.\n\n\nexppii(x::acb)\n\n\n\n\n\n\nReturn the exponential of \n\\pi i x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sin\n \n \nMethod\n.\n\n\nsin(x::acb)\n\n\n\n\n\n\nReturn the sine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cos\n \n \nMethod\n.\n\n\ncos(x::acb)\n\n\n\n\n\n\nReturn the cosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.sinpi\n \n \nMethod\n.\n\n\nsinpi(x::acb)\n\n\n\n\n\n\nReturn the sine of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.cospi\n \n \nMethod\n.\n\n\ncospi(x::acb)\n\n\n\n\n\n\nReturn the cosine of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tan\n \n \nMethod\n.\n\n\ntan(x::acb)\n\n\n\n\n\n\nReturn the tangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.cot\n \n \nMethod\n.\n\n\ncot(x::acb)\n\n\n\n\n\n\nReturn the cotangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.tanpi\n \n \nMethod\n.\n\n\ntanpi(x::acb)\n\n\n\n\n\n\nReturn the tangent of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.cotpi\n \n \nMethod\n.\n\n\ncotpi(x::acb)\n\n\n\n\n\n\nReturn the cotangent of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sinh\n \n \nMethod\n.\n\n\nsinh(x::acb)\n\n\n\n\n\n\nReturn the hyperbolic sine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cosh\n \n \nMethod\n.\n\n\ncosh(x::acb)\n\n\n\n\n\n\nReturn the hyperbolic cosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tanh\n \n \nMethod\n.\n\n\ntanh(x::acb)\n\n\n\n\n\n\nReturn the hyperbolic tangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.coth\n \n \nMethod\n.\n\n\ncoth(x::acb)\n\n\n\n\n\n\nReturn the hyperbolic cotangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.atan\n \n \nMethod\n.\n\n\natan(x::acb)\n\n\n\n\n\n\nReturn the arctangent of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.logsinpi\n \n \nMethod\n.\n\n\nlogsinpi(x::acb)\n\n\n\n\n\n\nReturn \n\\log\\sin(\\pi x)\n, constructed without branch cuts off the real line.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.gamma\n \n \nMethod\n.\n\n\ngamma(x::acb)\n\n\n\n\n\n\nReturn the Gamma function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.lgamma\n \n \nMethod\n.\n\n\nlgamma(x::acb)\n\n\n\n\n\n\nReturn the logarithm of the Gamma function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.rgamma\n \n \nMethod\n.\n\n\nrgamma(x::acb)\n\n\n\n\n\n\nReturn the reciprocal of the Gamma function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.digamma\n \n \nMethod\n.\n\n\ndigamma(x::acb)\n\n\n\n\n\n\nReturn the  logarithmic derivative of the gamma function evaluated at \nx\n, i.e. \n\\psi(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.zeta\n \n \nMethod\n.\n\n\nzeta(x::acb)\n\n\n\n\n\n\nReturn the Riemann zeta function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.barnesg\n \n \nMethod\n.\n\n\nbarnesg(x::acb)\n\n\n\n\n\n\nReturn the Barnes \nG\n-function, evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.logbarnesg\n \n \nMethod\n.\n\n\nlogbarnesg(x::acb)\n\n\n\n\n\n\nReturn the logarithm of the Barnes \nG\n-function, evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.erf\n \n \nMethod\n.\n\n\nerf(x::acb)\n\n\n\n\n\n\nReturn the error function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.erfi\n \n \nMethod\n.\n\n\nerfi(x::acb)\n\n\n\n\n\n\nReturn the imaginary error function evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ei\n \n \nMethod\n.\n\n\nei(x::acb)\n\n\n\n\n\n\nReturn the exponential integral evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.si\n \n \nMethod\n.\n\n\nsi(x::acb)\n\n\n\n\n\n\nReturn the sine integral evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ci\n \n \nMethod\n.\n\n\nci(x::acb)\n\n\n\n\n\n\nReturn the exponential cosine integral evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.shi\n \n \nMethod\n.\n\n\nshi(x::acb)\n\n\n\n\n\n\nReturn the hyperbolic sine integral evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chi\n \n \nMethod\n.\n\n\nchi(x::acb)\n\n\n\n\n\n\nReturn the hyperbolic cosine integral evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modeta\n \n \nMethod\n.\n\n\nmodeta(x::acb)\n\n\n\n\n\n\nReturn the Dedekind eta function \n\\eta(\\tau)\n at \n\\tau = x\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modj\n \n \nMethod\n.\n\n\nmodj(x::acb)\n\n\n\n\n\n\nReturn the \nj\n-invariant \nj(\\tau)\n at \n\\tau = x\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modlambda\n \n \nMethod\n.\n\n\nmodlambda(x::acb)\n\n\n\n\n\n\nReturn the modular lambda function \n\\lambda(\\tau)\n at \n\\tau = x\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.moddelta\n \n \nMethod\n.\n\n\nmoddelta(x::acb)\n\n\n\n\n\n\nReturn the modular delta function \n\\Delta(\\tau)\n at \n\\tau = x\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ellipk\n \n \nMethod\n.\n\n\nellipk(x::acb)\n\n\n\n\n\n\nReturn the complete elliptic integral \nK(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ellipe\n \n \nMethod\n.\n\n\nellipe(x::acb)\n\n\n\n\n\n\nReturn the complete elliptic integral \nE(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sincos\n \n \nMethod\n.\n\n\nsincos(x::acb)\n\n\n\n\n\n\nReturn a tuple \ns, c\n consisting of the sine \ns\n and cosine \nc\n of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sincospi\n \n \nMethod\n.\n\n\nsincospi(x::acb)\n\n\n\n\n\n\nReturn a tuple \ns, c\n consisting of the sine \ns\n and cosine \nc\n of \n\\pi x\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.sinhcosh\n \n \nMethod\n.\n\n\nsinhcosh(x::acb)\n\n\n\n\n\n\nReturn a tuple \ns, c\n consisting of the hyperbolic sine and cosine of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.agm\n \n \nMethod\n.\n\n\nagm(x::acb)\n\n\n\n\n\n\nReturn the arithmetic-geometric mean of \n1\n and \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.agm\n \n \nMethod\n.\n\n\nagm(x::acb, y::acb)\n\n\n\n\n\n\nReturn the arithmetic-geometric mean of \nx\n and \ny\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.polygamma\n \n \nMethod\n.\n\n\npolygamma(s::acb, a::acb)\n\n\n\n\n\n\nReturn the generalised polygamma function \n\\psi(s,z)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.zeta\n \n \nMethod\n.\n\n\nzeta(s::acb, a::acb)\n\n\n\n\n\n\nReturn the Hurwitz zeta function \n\\zeta(s,a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.risingfac\n \n \nMethod\n.\n\n\nrisingfac(x::acb, n::Int)\n\n\n\n\n\n\nReturn the rising factorial \nx(x + 1)\\ldots (x + n - 1)\n as an Acb.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.risingfac2\n \n \nMethod\n.\n\n\nrisingfac2(x::acb, n::Int)\n\n\n\n\n\n\nReturn a tuple containing the rising factorial \nx(x + 1)\\ldots (x + n - 1)\n and its derivative.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.polylog\n \n \nMethod\n.\n\n\npolylog(s::acb, a::acb)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNemo.polylog\n \n \nMethod\n.\n\n\npolylog(s::Int, a::acb)\n\n\n\n\n\n\nReturn the polylogarithm Li\n_s(a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.li\n \n \nMethod\n.\n\n\nli(x::acb)\n\n\n\n\n\n\nReturn the logarithmic integral, evaluated at \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lioffset\n \n \nMethod\n.\n\n\nlioffset(x::acb)\n\n\n\n\n\n\nReturn the offset logarithmic integral, evaluated at \nx\n.\n\n\n\n\nsource\n\n\nexpint(::acb)\n\n\n\n\n#\n\n\nBase.Math.gamma\n \n \nMethod\n.\n\n\ngamma(s::acb, x::acb)\n\n\n\n\n\n\nReturn the upper incomplete gamma function \n\\Gamma(s,x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.besselj\n \n \nMethod\n.\n\n\nbesselj(nu::acb, x::acb)\n\n\n\n\n\n\nReturn the Bessel function \nJ_{\\nu}(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.bessely\n \n \nMethod\n.\n\n\nbessely(nu::acb, x::acb)\n\n\n\n\n\n\nReturn the Bessel function \nY_{\\nu}(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.besseli\n \n \nMethod\n.\n\n\nbesseli(nu::acb, x::acb)\n\n\n\n\n\n\nReturn the Bessel function \nI_{\\nu}(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Math.besselk\n \n \nMethod\n.\n\n\nbesselk(nu::acb, x::acb)\n\n\n\n\n\n\nReturn the Bessel function \nK_{\\nu}(x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hyp1f1\n \n \nMethod\n.\n\n\nhyp1f1(a::acb, b::acb, x::acb)\n\n\n\n\n\n\nReturn the confluent hypergeometric function \n{}_1F1(a,b,x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hyp1f1r\n \n \nMethod\n.\n\n\nhyp1f1r(a::acb, b::acb, x::acb)\n\n\n\n\n\n\nReturn the regularized confluent hypergeometric function \n{}_1F1(a,b,x) / \\Gamma(b)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hyperu\n \n \nMethod\n.\n\n\nhyperu(a::acb, b::acb, x::acb)\n\n\n\n\n\n\nReturn the confluent hypergeometric function \nU(a,b,x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.hyp2f1\n \n \nMethod\n.\n\n\nhyp2f1(a::acb, b::acb, c::acb, x::acb)\n\n\n\n\n\n\nReturn the Gauss hypergeometric function \n{}_2F_1(a,b,c,x)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.jtheta\n \n \nMethod\n.\n\n\njtheta(z::acb, tau::acb)\n\n\n\n\n\n\nReturn a tuple of four elements containing the Jacobi theta function values \n\\theta_1, \\theta_2, \\theta_3, \\theta_4\n evaluated at \nz, \\tau\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.ellipwp\n \n \nMethod\n.\n\n\nellipwp(z::acb, tau::acb)\n\n\n\n\n\n\nReturn the Weierstrass elliptic function \n\\wp(z,\\tau)\n.\n\n\n\n\nsource\n\n\nHere are some examples of complex valued mathematical functions.\n\n\nCC = ComplexField(64)\n\ns = CC(1, 2)\nz = CC(\n1.23\n, \n3.45\n)\n\na = sin(z)^2 + cos(z)^2\nb = zeta(z)\nc = besselj(s, z)\nd = hyp1f1(s, s+1, z)", 
            "title": "Complex boxes"
        }, 
        {
            "location": "/acb/#introduction", 
            "text": "Arbitrary precision complex ball arithmetic is supplied by Arb which provides a ball representation which tracks error bounds rigorously. Complex numbers are  represented in in rectangular form  a+bi  where  a,b  are  arb  balls.  The Arb complex field is constructed using the  AcbField  constructor. This constructs the parent object for the Arb complex field.  We define  ComplexField = AcbField  so that one can construct the Arb complex field parent using  ComplexField  instead of  AcbField .  The types of complex boxes in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.     Library  Field  Element type  Parent type      Arb   \\mathbb{C}  (boxes)  acb  AcbField     All the complex field types belong to the  Field  abstract type and the types of elements in this field, i.e. complex boxes in this case, belong to the  FieldElem  abstract type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/acb/#complex-field-constructors", 
            "text": "In order to construct complex boxes in Nemo, one must first construct the Arb complex field itself. This is accomplished with the following constructor.  AcbField(prec::Int)  Return the Arb complex field with precision in bits  prec  used for operations on interval midpoints. The precision used for interval radii is a fixed implementation-defined constant (30 bits).  We define  ComplexField = AcbField  so that one can use  ComplexField  instead of  AcbField .  Here is an example of creating an Arb complex field and using the resulting parent object to coerce values into the resulting field.  CC = ComplexField(64)\n\na = CC( 0.25 )\nb = CC( 0.1 )\nc = CC(0.5)\nd = CC(12)  Note that whilst one can coerce double precision floating point values into an Arb complex field, unless those values can be represented exactly in double precision, the resulting ball can't be any more precise than the double precision supplied.  If instead, values can be represented precisely using decimal arithmetic then one can supply them to Arb using a string. In this case, Arb will store them to the precision specified when creating the Arb complex field.  If the values can be stored precisely as a binary floating point number, Arb will store the values exactly. See the function  isexact  below for more information.", 
            "title": "Complex field constructors"
        }, 
        {
            "location": "/acb/#complex-ball-constructors", 
            "text": "Once an Arb complex field is constructed, there are various ways to construct boxes in that field.  Apart from coercing elements into the Arb complex field as above, we offer the following functions.  #  Base.zero     Method .  zero(R::AcbField)   Return exact zero in the given Arb complex field.   source  #  Base.one     Method .  one(R::AcbField)   Return exact one in the given Arb complex field.   source  #  Nemo.onei     Method .  onei(R::AcbField)   Return exact one times  i  in the given Arb complex field.   source  Here are some examples of constructing complex boxes.  CC = ComplexField(64)\n\na = zero(CC)\nb = one(CC)\nc = onei(CC)", 
            "title": "Complex ball constructors"
        }, 
        {
            "location": "/acb/#basic-functionality", 
            "text": "The following basic functionality is provided by the default Arb complex field implementation in Nemo, to support construction of generic rings over complex fields. Any custom complex field implementation in Nemo should provide analogues of these functions along with the usual arithmetic operations.  parent_type(::Type{acb})  Gives the type of the parent object of an Arb complex field element.  elem_type(R::AcbField)  Given the parent object for an Arb complex field, return the type of elements of the field.  mul!(c::acb, a::acb, b::acb)  Multiply  a  by  b  and set the existing Arb complex field element  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::acb, a::acb)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  deepcopy(a::acb)  Return a copy of the Arb complex field element  a , recursively copying the internal data. Arb complex field elements are mutable in Nemo so a shallow copy is not sufficient.  Given the parent object  R  for an Arb complex field, the following coercion functions are provided to coerce various elements into the Arb complex field. Developers provide these by overloading the  call  operator for the complex field parent objects.  R()  Coerce zero into the Arb complex field.  R(n::Integer)\nR(f::fmpz)\nR(q::fmpq)  Coerce an integer or rational value into the Arb complex field.  R(f::Float64)\nR(f::BigFloat)  Coerce the given floating point number into the Arb complex field.  R(f::AbstractString)\nR(f::AbstractString, g::AbstractString)  Coerce the decimal number, given as a string, into the Arb complex field. In each case  f  is the real part and  g  is the imaginary part.  R(f::arb)  Coerce the given Arb real ball into the Arb complex field.  R(f::acb)  Take an Arb complex field element that is already in an Arb field and simply return it. A copy of the original is not made.  Here are some examples of coercing elements into the Arb complex field.  RR = RealField(64)\nCC = ComplexField(64)\n\na = CC(3)\nb = CC(QQ(2,3))\nc = CC( 3 +/- 0.0001 )\nd = CC( -1.24e+12345 )\nf = CC( nan +/- inf )\ng = CC(RR(3))  In addition to the above, developers of custom complex field types must ensure that they provide the equivalent of the function  base_ring(R::AcbField)  which should return  Union{} . In addition to this they should ensure that each complex field element contains a field  parent  specifying the parent object of the complex field element, or at least supply the equivalent of the function  parent(a::acb)  to return the parent object of a complex field element.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/acb/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate Arb complex field elements. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(R::AcbField)   Returns  Union{}  since an Arb complex field does not depend on any other ring.   source  #  Nemo.base_ring     Method .  base_ring(a::acb)   Returns  Union{}  since an Arb complex field does not depend on any other ring.   source  #  Base.parent     Method .  parent(x::acb)   Return the parent of the given Arb complex field element.   source  #  Nemo.iszero     Method .  iszero(x::acb)   Return  true  if  x  is certainly zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(x::acb)   Return  true  if  x  is certainly zero, otherwise return  false .   source  #  Base.isfinite     Method .  isfinite(x::acb)   Return  true  if  x  is finite, i.e. its real and imaginary parts have finite midpoint and radius, otherwise return  false .   source  #  Nemo.isexact     Method .  isexact(x::acb)   Return  true  if  x  is exact, i.e. has its real and imaginary parts have zero radius, otherwise return  false .   source  #  Nemo.isint     Method .  isint(x::acb)   Return  true  if  x  is an exact integer, otherwise return  false .   source  #  Base.isreal     Method .  isint(x::acb)   Return  true  if  x  is purely real, i.e. having zero imaginary part, otherwise return  false .   source  #  Base.real     Method .  real(x::acb)   Return the real part of  x  as an  arb .   source  #  Base.imag     Method .  imag(x::acb)   Return the imaginary part of  x  as an  arb .   source  #  Nemo.accuracy_bits     Method .  accuracy_bits(x::acb)   Return the relative accuracy of  x  measured in bits, capped between  typemax(Int)  and  -typemax(Int) .   source  Here are some examples of basic manipulation of Arb complex boxes.  CC = ComplexField(64)\n\na = CC( 1.2 +/- 0.001 )\nb = CC(3)\n\niszero(a)\nisone(b)\nisreal(a)\nisfinite(b)\nisint(b)\nc = real(a)\nd = imag(b)\nf = accuracy_bits(a)\nS = parent(a)\nT = base_ring(CC)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/acb/#arithmetic-operations", 
            "text": "Nemo provides all the standard field operations for Arb complex field elements, as follows. Note that division is represented by  //  since a field is its own fraction field and since exact division is not generally possible in an inexact field.     Function  Operation      -(a::acb)  unary minus    +(a::acb, b::acb)  addition    -(a::acb, b::acb)  subtraction    *(a::acb, b::acb)  multiplication    //(a::acb, b::acb)  division    ^(a::acb, b::acb)  powering     In addition, the following ad hoc field operations are defined.     Function  Operation      +(a::acb, b::Integer)  addition    +(a::Integer, b::acb)  addition    +(a::acb, b::fmpz)  addition    +(a::fmpz, b::acb)  addition    +(a::acb, b::fmpq)  addition    +(a::fmpq, b::acb)  addition    +(a::acb, b::arb)  addition    +(a::arb, b::acb)  addition    -(a::acb, b::Integer)  subtraction    -(a::Integer, b::acb)  subtraction    -(a::acb, b::fmpz)  subtraction    -(a::fmpz, b::acb)  subtraction    -(a::acb, b::fmpq)  subtraction    -(a::fmpq, b::acb)  subtraction    -(a::acb, b::arb)  subtraction    -(a::arb, b::acb)  subtraction    *(a::acb, b::Integer)  multiplication    *(a::Integer, b::acb)  multiplication    *(a::acb, b::fmpz)  multiplication    *(a::fmpz, b::acb)  multiplication    *(a::acb, b::fmpq)  multiplication    *(a::fmpq, b::acb)  multiplication    *(a::acb, b::arb)  multiplication    *(a::arb, b::acb)  multiplication    //(a::acb, b::Integer)  division    //(a::acb, b::fmpz)  division    //(a::acb, b::fmpq)  division    //(a::Integer, b::acb)  division    //(a::fmpz, b::acb)  division    //(a::fmpq, b::acb)  division    //(a::arb, b::acb)  division    ^(a::acb, b::fmpq)  powering    ^(a::Integer, b::acb)  powering    ^(a::fmpz, b::acb)  powering    ^(a::fmpq, b::acb)  powering    ^(a::arb, b::acb)  powering     Here are some examples of arithmetic operations on Arb complex boxes.  CC = ComplexField(64)\n\nx = CC(3)\ny = CC(QQ(2,3))\n\na = x + y\nb = x*y\nd = 1//y - x\nd = 3x + ZZ(100)//y\nf = (x^2 + y^2) ^ QQ(1,2)", 
            "title": "Arithmetic operations"
        }, 
        {
            "location": "/acb/#containment", 
            "text": "It is often necessary to determine whether a given exact value or box is contained in a given complex box or whether two boxes overlap. The following functions are provided for this purpose.  #  Nemo.overlaps     Method .  overlaps(x::acb, y::acb)   Returns  true  if any part of the box  x  overlaps any part of the box  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb, y::acb)   Returns  true  if the box  x  contains the box  y , otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb, y::Integer)   Returns  true  if the box  x  contains the given integer value, otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb, y::fmpz)   Returns  true  if the box  x  contains the given integer value, otherwise return  false .   source  #  Base.contains     Method .  contains(x::acb, y::fmpq)   Returns  true  if the box  x  contains the given rational value, otherwise return  false .   source  The following functions are also provided for determining if a box intersects a certain part of the complex number plane.  #  Nemo.contains_zero     Method .  contains_zero(x::acb)   Returns  true  if the box  x  contains zero, otherwise return  false .   source  Here are some examples of testing containment.  CC = ComplexField(64)\nx = CC( 1 +/- 0.001 )\ny = CC( 3 )\n\noverlaps(x, y)\ncontains(x, y)\ncontains(y, 3)\ncontains(x, ZZ(1)//2)\ncontains_zero(x)", 
            "title": "Containment"
        }, 
        {
            "location": "/acb/#comparison", 
            "text": "Nemo provides a full range of comparison operations for Arb complex boxes.   Firstly, we introduce an exact equality which is distinct from arithmetic equality. This is distinct from arithmetic equality implemented by  == , which merely compares up to the minimum of the precisions of its operands.  #  Base.isequal     Method .  isequal(x::acb, y::acb)   Return  true  if the boxes  x  and  y  are precisely equal, i.e. their real and imaginary parts have the same midpoints and radii.   source  A full range of functions is available for comparing boxes, i.e.  ==  and  != . In fact, these are implemented directly in C. In the table below we document these as though only  ==  had been provided to Julia.", 
            "title": "Comparison"
        }, 
        {
            "location": "/acb/#function", 
            "text": "==(x::acb, y::acb)  As well as these, we provide a full range of ad hoc comparison operators. Again, these are implemented directly in Julia, but we document them as though only  ==  were provided.", 
            "title": "Function"
        }, 
        {
            "location": "/acb/#function_1", 
            "text": "==(x::acb, y::Integer)   ==(x::Integer, y::acb)   ==(x::acb, y::fmpz)   ==(x::fmpz, y::acb)   ==(x::arb, y::fmpz)   ==(x::fmpz, y::arb)   ==(x::acb, y::Float64)   ==(x::Float64, y::acb)  Here are some examples of comparison.  CC = ComplexField(64)\nx = CC( 1 +/- 0.001 )\ny = CC( 3 )\nz = CC( 4 )\n\nisequal(y, z)\nx != z\nx == 3\nZZ(3) == z\nx != 1.23", 
            "title": "Function"
        }, 
        {
            "location": "/acb/#absolute-value", 
            "text": "#  Base.abs     Method .  abs(x::acb)   Return the complex absolute value of  x .   source  Here are some examples of taking the absolute value.  CC = ComplexField(64)\nx = CC( -1 +/- 0.001 )\n\na = abs(x)", 
            "title": "Absolute value"
        }, 
        {
            "location": "/acb/#inverse", 
            "text": "#  Base.inv     Method .  inv(x::acb)   Return the multiplicative inverse of  x , i.e.  1/x .   source  Here are some examples of taking the inverse.  CC = ComplexField(64)\nx = CC( -3 +/- 0.001 )\n\na = inv(x)", 
            "title": "Inverse"
        }, 
        {
            "location": "/acb/#shifting", 
            "text": "#  Base.Math.ldexp     Method .  ldexp(x::acb, y::Int)   Return  2^yx . Note that  y  can be positive, zero or negative.   source  #  Base.Math.ldexp     Method .  ldexp(x::acb, y::fmpz)   Return  2^yx . Note that  y  can be positive, zero or negative.   source  Here are some examples of shifting.  CC = ComplexField(64)\nx = CC( -3 +/- 0.001 )\n\na = ldexp(x, 23)\nb = ldexp(x, -ZZ(15))", 
            "title": "Shifting"
        }, 
        {
            "location": "/acb/#miscellaneous-operations", 
            "text": "#  Nemo.trim     Method .  trim(x::acb)   Return an  acb  box containing  x  but which may be more economical, by rounding off insignificant bits from midpoints.   source  #  Nemo.unique_integer     Method .  unique_integer(x::acb)   Return a pair where the first value is a boolean and the second is an  fmpz  integer. The boolean indicates whether the box  x  contains a unique integer. If this is the case, the second return value is set to this unique integer.   source  #  Base.conj     Method .  conj(x::acb)   Return the complex conjugate of  x .   source  #  Base.angle     Method .  angle(x::acb)   Return the angle in radians that the complex vector  x  makes with the positive real axis in a counterclockwise direction.   source  Here are some examples of miscellaneous operations.  CC = ComplexField(64)\nx = CC( -3 +/- 0.001 ,  0.1 )\n\na = trim(x)\nb, c = unique_integer(x)\nd = conj(x)\nf = angle(x)", 
            "title": "Miscellaneous operations"
        }, 
        {
            "location": "/acb/#constants", 
            "text": "const_pi(::AcbField)  Here are some examples of computing complex constants.  CC = ComplexField(200)\n\na = const_pi(CC)", 
            "title": "Constants"
        }, 
        {
            "location": "/acb/#mathematical-functions", 
            "text": "#  Base.sqrt     Method .  sqrt(x::acb)   Return the square root of  x .   source  #  Nemo.rsqrt     Method .  rsqrt(x::acb)   Return the reciprocal of the square root of  x , i.e.  1/\\sqrt{x} .   source  #  Base.log     Method .  log(x::acb)   Return the principal branch of the logarithm of  x .   source  #  Base.log1p     Method .  log1p(x::acb)   Return  \\log(1+x) , evaluated accurately for small  x .   source  #  Base.exp     Method .  exp(x::acb)   Return the exponential of  x .   source  #  Nemo.exppii     Method .  exppii(x::acb)   Return the exponential of  \\pi i x .   source  #  Base.sin     Method .  sin(x::acb)   Return the sine of  x .   source  #  Base.cos     Method .  cos(x::acb)   Return the cosine of  x .   source  #  Base.Math.sinpi     Method .  sinpi(x::acb)   Return the sine of  \\pi x .   source  #  Base.Math.cospi     Method .  cospi(x::acb)   Return the cosine of  \\pi x .   source  #  Base.tan     Method .  tan(x::acb)   Return the tangent of  x .   source  #  Base.Math.cot     Method .  cot(x::acb)   Return the cotangent of  x .   source  #  Nemo.tanpi     Method .  tanpi(x::acb)   Return the tangent of  \\pi x .   source  #  Nemo.cotpi     Method .  cotpi(x::acb)   Return the cotangent of  \\pi x .   source  #  Base.sinh     Method .  sinh(x::acb)   Return the hyperbolic sine of  x .   source  #  Base.cosh     Method .  cosh(x::acb)   Return the hyperbolic cosine of  x .   source  #  Base.tanh     Method .  tanh(x::acb)   Return the hyperbolic tangent of  x .   source  #  Base.Math.coth     Method .  coth(x::acb)   Return the hyperbolic cotangent of  x .   source  #  Base.atan     Method .  atan(x::acb)   Return the arctangent of  x .   source  #  Nemo.logsinpi     Method .  logsinpi(x::acb)   Return  \\log\\sin(\\pi x) , constructed without branch cuts off the real line.   source  #  Base.Math.gamma     Method .  gamma(x::acb)   Return the Gamma function evaluated at  x .   source  #  Base.Math.lgamma     Method .  lgamma(x::acb)   Return the logarithm of the Gamma function evaluated at  x .   source  #  Nemo.rgamma     Method .  rgamma(x::acb)   Return the reciprocal of the Gamma function evaluated at  x .   source  #  Base.Math.digamma     Method .  digamma(x::acb)   Return the  logarithmic derivative of the gamma function evaluated at  x , i.e.  \\psi(x) .   source  #  Base.Math.zeta     Method .  zeta(x::acb)   Return the Riemann zeta function evaluated at  x .   source  #  Nemo.barnesg     Method .  barnesg(x::acb)   Return the Barnes  G -function, evaluated at  x .   source  #  Nemo.logbarnesg     Method .  logbarnesg(x::acb)   Return the logarithm of the Barnes  G -function, evaluated at  x .   source  #  Base.Math.erf     Method .  erf(x::acb)   Return the error function evaluated at  x .   source  #  Base.Math.erfi     Method .  erfi(x::acb)   Return the imaginary error function evaluated at  x .   source  #  Nemo.ei     Method .  ei(x::acb)   Return the exponential integral evaluated at  x .   source  #  Nemo.si     Method .  si(x::acb)   Return the sine integral evaluated at  x .   source  #  Nemo.ci     Method .  ci(x::acb)   Return the exponential cosine integral evaluated at  x .   source  #  Nemo.shi     Method .  shi(x::acb)   Return the hyperbolic sine integral evaluated at  x .   source  #  Nemo.chi     Method .  chi(x::acb)   Return the hyperbolic cosine integral evaluated at  x .   source  #  Nemo.modeta     Method .  modeta(x::acb)   Return the Dedekind eta function  \\eta(\\tau)  at  \\tau = x .   source  #  Nemo.modj     Method .  modj(x::acb)   Return the  j -invariant  j(\\tau)  at  \\tau = x .   source  #  Nemo.modlambda     Method .  modlambda(x::acb)   Return the modular lambda function  \\lambda(\\tau)  at  \\tau = x .   source  #  Nemo.moddelta     Method .  moddelta(x::acb)   Return the modular delta function  \\Delta(\\tau)  at  \\tau = x .   source  #  Nemo.ellipk     Method .  ellipk(x::acb)   Return the complete elliptic integral  K(x) .   source  #  Nemo.ellipe     Method .  ellipe(x::acb)   Return the complete elliptic integral  E(x) .   source  #  Nemo.sincos     Method .  sincos(x::acb)   Return a tuple  s, c  consisting of the sine  s  and cosine  c  of  x .   source  #  Nemo.sincospi     Method .  sincospi(x::acb)   Return a tuple  s, c  consisting of the sine  s  and cosine  c  of  \\pi x .   source  #  Nemo.sinhcosh     Method .  sinhcosh(x::acb)   Return a tuple  s, c  consisting of the hyperbolic sine and cosine of  x .   source  #  Nemo.agm     Method .  agm(x::acb)   Return the arithmetic-geometric mean of  1  and  x .   source  #  Nemo.agm     Method .  agm(x::acb, y::acb)   Return the arithmetic-geometric mean of  x  and  y .   source  #  Base.Math.polygamma     Method .  polygamma(s::acb, a::acb)   Return the generalised polygamma function  \\psi(s,z) .   source  #  Base.Math.zeta     Method .  zeta(s::acb, a::acb)   Return the Hurwitz zeta function  \\zeta(s,a) .   source  #  Nemo.risingfac     Method .  risingfac(x::acb, n::Int)   Return the rising factorial  x(x + 1)\\ldots (x + n - 1)  as an Acb.   source  #  Nemo.risingfac2     Method .  risingfac2(x::acb, n::Int)   Return a tuple containing the rising factorial  x(x + 1)\\ldots (x + n - 1)  and its derivative.   source  #  Nemo.polylog     Method .  polylog(s::acb, a::acb)   source  #  Nemo.polylog     Method .  polylog(s::Int, a::acb)   Return the polylogarithm Li _s(a) .   source  #  Nemo.li     Method .  li(x::acb)   Return the logarithmic integral, evaluated at  x .   source  #  Nemo.lioffset     Method .  lioffset(x::acb)   Return the offset logarithmic integral, evaluated at  x .   source  expint(::acb)  #  Base.Math.gamma     Method .  gamma(s::acb, x::acb)   Return the upper incomplete gamma function  \\Gamma(s,x) .   source  #  Base.Math.besselj     Method .  besselj(nu::acb, x::acb)   Return the Bessel function  J_{\\nu}(x) .   source  #  Base.Math.bessely     Method .  bessely(nu::acb, x::acb)   Return the Bessel function  Y_{\\nu}(x) .   source  #  Base.Math.besseli     Method .  besseli(nu::acb, x::acb)   Return the Bessel function  I_{\\nu}(x) .   source  #  Base.Math.besselk     Method .  besselk(nu::acb, x::acb)   Return the Bessel function  K_{\\nu}(x) .   source  #  Nemo.hyp1f1     Method .  hyp1f1(a::acb, b::acb, x::acb)   Return the confluent hypergeometric function  {}_1F1(a,b,x) .   source  #  Nemo.hyp1f1r     Method .  hyp1f1r(a::acb, b::acb, x::acb)   Return the regularized confluent hypergeometric function  {}_1F1(a,b,x) / \\Gamma(b) .   source  #  Nemo.hyperu     Method .  hyperu(a::acb, b::acb, x::acb)   Return the confluent hypergeometric function  U(a,b,x) .   source  #  Nemo.hyp2f1     Method .  hyp2f1(a::acb, b::acb, c::acb, x::acb)   Return the Gauss hypergeometric function  {}_2F_1(a,b,c,x) .   source  #  Nemo.jtheta     Method .  jtheta(z::acb, tau::acb)   Return a tuple of four elements containing the Jacobi theta function values  \\theta_1, \\theta_2, \\theta_3, \\theta_4  evaluated at  z, \\tau .   source  #  Nemo.ellipwp     Method .  ellipwp(z::acb, tau::acb)   Return the Weierstrass elliptic function  \\wp(z,\\tau) .   source  Here are some examples of complex valued mathematical functions.  CC = ComplexField(64)\n\ns = CC(1, 2)\nz = CC( 1.23 ,  3.45 )\n\na = sin(z)^2 + cos(z)^2\nb = zeta(z)\nc = besselj(s, z)\nd = hyp1f1(s, s+1, z)", 
            "title": "Mathematical functions"
        }, 
        {
            "location": "/numberfield/", 
            "text": "Introduction\n\n\nNumber fields are provided in Nemo by Antic. This allows construction of absolute number fields and basic arithmetic computations therein.\n\n\nNumber fields are constructed using the \nAnticNumberField\n function. However, for convenience we define\n\n\nNumberField = AnticNumberField\n\n\n\n\nso that number fields can be constructed using \nNumberField\n rather than \nAnticNumberField\n. \n\n\nThe types of number field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.\n\n\n\n\n\n\n\n\nLibrary\n\n\nField\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nAntic\n\n\n\n\n\\mathbb{Q}[x]/(f)\n\n\n\n\nnf_elem\n\n\nAnticNumberField\n\n\n\n\n\n\n\n\nAll the number field types belong to the \nField\n abstract type and the number field element types belong to the \nFieldElem\n abstract type.\n\n\n\n\nNumber field constructors\n\n\nIn order to construct number field elements in Nemo, one must first construct the number field itself. This is accomplished with one of the following constructors.\n\n\n#\n\n\nNemo.AnticNumberField\n \n \nMethod\n.\n\n\nAnticNumberField(f::fmpq_poly, s::AbstractString)\n\n\n\n\n\n\nReturn a tuple \nR, x\n consisting of the parent object \nR\n and generator \nx\n of the number field \n\\mathbb{Q}/(f)\n where \nf\n is the supplied polynomial. The supplied string \ns\n specifies how the generator of the number field should be printed.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.AnticCyclotomicField\n \n \nMethod\n.\n\n\nAnticCyclotomicField(n::Int, s::AbstractString, t = \n\\$\n)\n\n\n\n\n\n\nReturn a tuple \nR, x\n consisting of the parent object \nR\n and generator \nx\n of the \nn\n-th cyclotomic field, \n\\mathbb{Q}(\\zeta_n)\n. The supplied string \ns\n specifies how the generator of the number field should be printed. If provided, the string \nt\n specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.AnticMaximalRealSubfield\n \n \nMethod\n.\n\n\nAnticMaximalRealSubfield(n::Int, s::AbstractString, t = \n\\$\n)\n\n\n\n\n\n\nReturn a tuple \nR, x\n consisting of the parent object \nR\n and generator \nx\n of the totally real subfield of the \nn\n-th cyclotomic field, \n\\mathbb{Q}(\\zeta_n)\n. The supplied string \ns\n specifies how the generator of the number field should be printed. If provided, the string \nt\n specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.\n\n\n\n\nsource\n\n\nFor convenience we define\n\n\nNumberField = AnticNumberField\nCyclotomicField = AnticCyclotomicField\nMaximalRealSubfield = AnticMaximalRealSubfield\n\n\n\n\nso that one can use the names on the left instead of those on the right.\n\n\nHere are some examples of creating number fields and making use of the resulting parent objects to coerce various elements into those fields.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\nL, b = CyclotomicField(5, \nb\n)\nM, c = MaximalRealSubfield(5, \nc\n, \ny\n)\n\nd = K(3)\nf = L(b)\ng = L(ZZ(11))\nh = L(ZZ(11)//3)\nk = M(x)\n\n\n\n\n\n\nNumber field element constructors\n\n\nOnce a number field is constructed, there are various ways to construct elements in that field.\n\n\nApart from coercing elements into the number field as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(a::AnticNumberField)\n\n\n\n\n\n\nReturn the multiplicative identity, i.e. one, in the given number field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(a::AnticNumberField)\n\n\n\n\n\n\nReturn the multiplicative identity, i.e. one, in the given number field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gen\n \n \nMethod\n.\n\n\ngen(a::AnticNumberField)\n\n\n\n\n\n\nReturn the generator of the given number field.\n\n\n\n\nsource\n\n\nThe easiest way of constructing number field elements is to use element arithmetic with the generator, to construct the desired element by its representation as a polynomial. See the following examples for how to do this.\n\n\nHere are some examples of constructing number field elements.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nb = zero(K)\nc = one(K)\nd = gen(K)\nf = a^2 + 2a - 7\n\n\n\n\n\n\nBasic functionality\n\n\nThe following basic functionality is provided by the default number field implementation in Nemo, to support construction of generic rings over number fields. Any custom number field implementation in Nemo should provide these  functions along with the usual arithmetic operations.\n\n\nparent_type(::Type{nf_elem})\n\n\n\n\nGives the type of the parent object of an Antic number field element.\n\n\nelem_type(R::AnticNumberField)\n\n\n\n\nGiven the parent object for a number field, return the type of elements of the field.\n\n\nBase.hash(a::nf_elem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the number field element \na\n. This should be xor'd with a fixed random hexadecimal specific to the number field type. The hash of the coefficients of the number field element representation should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndeepcopy(a::nf_elem)\n\n\n\n\nConstruct a copy of the given number field element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo number field elements are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::nf_elem, a::nf_elem, b::nf_elem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing number field element \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nmul_red!(c::nf_elem, a::nf_elem, b::nf_elem, red::Bool)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing number field element \nc\n to the result. Reduction modulo the defining polynomial is only performed if \nred\n is set to \ntrue\n. Note that \na\n and \nb\n must be reduced. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nreduce!(x::nf_elem)\n\n\n\n\nReduce the given number field element by the defining polynomial, in-place. This only needs to be done after accumulating values computed by \nmul_red!\n where reduction has not been performed. All standard Nemo number field functions automatically reduce their outputs.\n\n\naddeq!(c::nf_elem, a::nf_elem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven the parent object \nR\n for a number field, the following coercion functions are provided to coerce various elements into the number field. Developers provide these by overloading the \ncall\n operator for the number field parent objects.\n\n\nR()\n\n\n\n\nCoerce zero into the number field.\n\n\nR(n::Integer)\nR(f::fmpz)\nR(f::fmpq)\n\n\n\n\nCoerce an integer or rational value into the number field.\n\n\nR(f::fmpq_poly)\n\n\n\n\nCoerce the given rational polynomial into the number field, i.e. consider the polynomial to be the representation of a number field element and return it.\n\n\nR(f::nf_elem)\n\n\n\n\nTake a number field element that is already in the number field and simply return it. A copy of the original is not made.\n\n\nIn addition to the above, developers of custom number field types must ensure that they provide the equivalent of the function \nbase_ring(R::AnticNumberField)\n which should return \nUnion{}\n. In addition to this they should ensure that each number field element contains a field \nparent\n specifying the parent object of the number field element, or at least supply the equivalent of the function \nparent(a::nf_elem)\n to return the parent object of a number field element.\n\n\n\n\nConversions\n\n\nIf \nR\n is the polynomial ring to which the generating polynomial of a number field belongs, then we can coerce number field elements into the ring \nR\n using the following function.\n\n\nR(b::nf_elem)\n\n\n\n\nCoerce the given number field element into the polynomial ring \nR\n of which the number field is a quotient.\n\n\nHere are some examples of conversions from number field elements.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nf = R(a^2 + 2a + 3)\n\n\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate number field elements. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::AnticNumberField)\n\n\n\n\n\n\nReturns \nUnion{}\n since a number field doesn't depend on any ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::nf_elem)\n\n\n\n\n\n\nReturns \nUnion{}\n since a number field doesn't depend on any ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::nf_elem)\n\n\n\n\n\n\nReturn the parent of the given number field element.\n\n\n\n\nsource\n\n\n#\n\n\nBase.var\n \n \nMethod\n.\n\n\nvar(a::AnticNumberField)\n\n\n\n\n\n\nReturns the identifier (as a symbol, not a string), that is used for printing the generator of the given number field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::nf_elem)\n\n\n\n\n\n\nReturn \ntrue\n if the given number field element is the additive identity of the number field, i.e. zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::nf_elem)\n\n\n\n\n\n\nReturn \ntrue\n if the given number field element is the multiplicative identity of the number field, i.e. one, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::nf_elem)\n\n\n\n\n\n\nReturn \ntrue\n if the given number field element is invertible, i.e. nonzero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isgen\n \n \nMethod\n.\n\n\nisgen(a::nf_elem)\n\n\n\n\n\n\nReturn \ntrue\n if the given number field element is the generator of the number field, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.coeff\n \n \nMethod\n.\n\n\ncoeff(x::nf_elem, n::Int)\n\n\n\n\n\n\nReturn the \nn\n-th coefficient of the polynomial representation of the given number field element. Coefficients are numbered from \n0\n, starting with the constant coefficient.\n\n\n\n\nsource\n\n\n#\n\n\nBase.den\n \n \nMethod\n.\n\n\nden(a::nf_elem)\n\n\n\n\n\n\nReturn the denominator of the polynomial representation of the given number field element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.degree\n \n \nMethod\n.\n\n\ndegree(a::AnticNumberField)\n\n\n\n\n\n\nReturn the degree of the given number field, i.e. the degree of its defining polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.signature\n \n \nMethod\n.\n\n\nsignature(a::AnticNumberField)\n\n\n\n\n\n\nReturn the signature of the given number field, i.e. a tuple \nr, s\n consisting of \nr\n, the number of real embeddings and \ns\n, half the number of complex embeddings.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of number field elements.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nd = a^2 + 2a - 7\nk = zero(K)\nl = one(K)\nm = gen(K)\n\nc = coeff(d, 1)\nisgen(m)\nisone(l)\nq = degree(K)\nr, s = signature(K)\nv = var(R)\nS = parent(a + 1)\nT = base_ring(K)\n\n\n\n\n\n\nArithmetic operations\n\n\nNemo provides all the standard field operations for number field elements, as follows.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n-(a::nf_elem)\n\n\nunary minus\n\n\n\n\n\n\n+(a::nf_elem, b::nf_elem)\n\n\naddition\n\n\n\n\n\n\n-(a::nf_elem, b::nf_elem)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::nf_elem, b::nf_elem)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::nf_elem, b::nf_elem)\n\n\nexact division\n\n\n\n\n\n\n\n\nIn addition, the following ad hoc field operations are defined.\n\n\n\n\n\n\n\n\nFunction\n\n\nOperation\n\n\n\n\n\n\n\n\n\n\n+(a::nf_elem, b::Integer)\n\n\naddition\n\n\n\n\n\n\n+(a::Integer, b::nf_elem)\n\n\naddition\n\n\n\n\n\n\n+(a::nf_elem, b::fmpz)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpz, b::nf_elem)\n\n\naddition\n\n\n\n\n\n\n+(a::nf_elem, b::fmpq)\n\n\naddition\n\n\n\n\n\n\n+(a::fmpq, b::nf_elem)\n\n\naddition\n\n\n\n\n\n\n-(a::nf_elem, b::Integer)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::Integer, b::nf_elem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::nf_elem, b::fmpz)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpz, b::nf_elem)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::nf_elem, b::fmpq)\n\n\nsubtraction\n\n\n\n\n\n\n-(a::fmpq, b::nf_elem)\n\n\nsubtraction\n\n\n\n\n\n\n*(a::nf_elem, b::Integer)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::Integer, b::nf_elem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::nf_elem, b::fmpz)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpz, b::nf_elem)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::nf_elem, b::fmpq)\n\n\nmultiplication\n\n\n\n\n\n\n*(a::fmpq, b::nf_elem)\n\n\nmultiplication\n\n\n\n\n\n\ndivexact(a::nf_elem, b::Integer)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::nf_elem, b::fmpz)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::nf_elem, b::fmpq)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::Integer, b::nf_elem)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::fmpz, b::nf_elem)\n\n\nexact division\n\n\n\n\n\n\ndivexact(a::fmpq, b::nf_elem)\n\n\nexact division\n\n\n\n\n\n\n^(a::nf_elem, b::Int)\n\n\npowering\n\n\n\n\n\n\n\n\nHere are some examples of arithmetic operations on number fields.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nc = a^2 + 2a - 7\nd = 3a^2 - a + 1\n\nf = c + d\ng = c - d\nh = c*d\nk = 3*c\nl = d*ZZ(4)\nm = d*(ZZ(4)//3)\nn = 4 - c\np = divexact(c, 5)\nq = divexact(ZZ(4)//5, d)\nr = c^4\n\n\n\n\n\n\nComparison\n\n\nNemo provides the comparison operation \n==\n for number field elements. Julia then automatically provides the corresponding \n!=\n operation. Here are the functions provided.\n\n\n\n\nFunction\n\n\n==(a::nf_elem, b::nf_elem)\n\n\nIn addition, the following ad hoc comparisons are provided, Julia again providing the corresponding \n!=\n operators.\n\n\n\n\nFunction\n\n\n==(a::nf_elem, b::Integer) ==(a::nf_elem, b::fmpz) ==(a::nf_elem, b::fmpq) ==(a::Integer, b::nf_elem) ==(a::fmpz, b::nf_elem) ==(a::fmpq, b::nf_elem)\n\n\nHere are some examples of comparisons.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nc = 3a^2 - a + 1\nd = a^2 + 2a - 7\n\nc != d\nc == 3a^2 - a + 1\nc == 3\nZZ(4) == d\nZZ(5)//7 != c\n\n\n\n\n\n\nDivisibility\n\n\n#\n\n\nNemo.divides\n \n \nMethod\n.\n\n\ndivides(f::nf_elem, g::nf_elem)\n\n\n\n\n\n\nReturns a pair consisting of a flag which is set to \ntrue\n if \ng\n divides \nf\n and \nfalse\n otherwise, and a number field element \nh\n such that \nf = gh\n if such exists. If not, the value of \nh\n is undetermined.\n\n\n\n\nsource\n\n\nHere are some examples of divisibility testing.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nc = 3a^2 - a + 1\nd = a^2 + 2a - 7\n\nflag, q = divides(c*d, c)\n\n\n\n\n\n\nInversion\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(a::nf_elem)\n\n\n\n\n\n\nReturn \na^{-1}\n. Requires \na \\neq 0\n.\n\n\n\n\nsource\n\n\nHere are some examples of inversion.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nc = 3a^2 - a + 1\n\nd = inv(c)\n\n\n\n\n\n\nNorm and trace\n\n\n#\n\n\nBase.LinAlg.norm\n \n \nMethod\n.\n\n\nnorm(a::nf_elem)\n\n\n\n\n\n\nReturn the absolute norm of \na\n. The result will be a rational number.\n\n\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.trace\n \n \nMethod\n.\n\n\nnorm(a::nf_elem)\n\n\n\n\n\n\nReturn the absolute trace of \na\n. The result will be a rational number.\n\n\n\n\nsource\n\n\nHere are some examples of computing the norm and trace.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nK, a = NumberField(x^3 + 3x + 1, \na\n)\n\nc = 3a^2 - a + 1\n\nd = norm(c)\nf = trace(c)", 
            "title": "Number fields"
        }, 
        {
            "location": "/numberfield/#introduction", 
            "text": "Number fields are provided in Nemo by Antic. This allows construction of absolute number fields and basic arithmetic computations therein.  Number fields are constructed using the  AnticNumberField  function. However, for convenience we define  NumberField = AnticNumberField  so that number fields can be constructed using  NumberField  rather than  AnticNumberField .   The types of number field elements in Nemo are given in the following table, along with the libraries that provide them and the associated types of the parent objects.     Library  Field  Element type  Parent type      Antic   \\mathbb{Q}[x]/(f)   nf_elem  AnticNumberField     All the number field types belong to the  Field  abstract type and the number field element types belong to the  FieldElem  abstract type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/numberfield/#number-field-constructors", 
            "text": "In order to construct number field elements in Nemo, one must first construct the number field itself. This is accomplished with one of the following constructors.  #  Nemo.AnticNumberField     Method .  AnticNumberField(f::fmpq_poly, s::AbstractString)   Return a tuple  R, x  consisting of the parent object  R  and generator  x  of the number field  \\mathbb{Q}/(f)  where  f  is the supplied polynomial. The supplied string  s  specifies how the generator of the number field should be printed.   source  #  Nemo.AnticCyclotomicField     Method .  AnticCyclotomicField(n::Int, s::AbstractString, t =  \\$ )   Return a tuple  R, x  consisting of the parent object  R  and generator  x  of the  n -th cyclotomic field,  \\mathbb{Q}(\\zeta_n) . The supplied string  s  specifies how the generator of the number field should be printed. If provided, the string  t  specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.   source  #  Nemo.AnticMaximalRealSubfield     Method .  AnticMaximalRealSubfield(n::Int, s::AbstractString, t =  \\$ )   Return a tuple  R, x  consisting of the parent object  R  and generator  x  of the totally real subfield of the  n -th cyclotomic field,  \\mathbb{Q}(\\zeta_n) . The supplied string  s  specifies how the generator of the number field should be printed. If provided, the string  t  specifies how the generator of the polynomial ring from which the number field is constructed, should be printed. If it is not supplied, a default dollar sign will be used to represent the variable.   source  For convenience we define  NumberField = AnticNumberField\nCyclotomicField = AnticCyclotomicField\nMaximalRealSubfield = AnticMaximalRealSubfield  so that one can use the names on the left instead of those on the right.  Here are some examples of creating number fields and making use of the resulting parent objects to coerce various elements into those fields.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\nL, b = CyclotomicField(5,  b )\nM, c = MaximalRealSubfield(5,  c ,  y )\n\nd = K(3)\nf = L(b)\ng = L(ZZ(11))\nh = L(ZZ(11)//3)\nk = M(x)", 
            "title": "Number field constructors"
        }, 
        {
            "location": "/numberfield/#number-field-element-constructors", 
            "text": "Once a number field is constructed, there are various ways to construct elements in that field.  Apart from coercing elements into the number field as above, we offer the following functions.  #  Base.zero     Method .  zero(a::AnticNumberField)   Return the multiplicative identity, i.e. one, in the given number field.   source  #  Base.one     Method .  one(a::AnticNumberField)   Return the multiplicative identity, i.e. one, in the given number field.   source  #  Nemo.gen     Method .  gen(a::AnticNumberField)   Return the generator of the given number field.   source  The easiest way of constructing number field elements is to use element arithmetic with the generator, to construct the desired element by its representation as a polynomial. See the following examples for how to do this.  Here are some examples of constructing number field elements.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nb = zero(K)\nc = one(K)\nd = gen(K)\nf = a^2 + 2a - 7", 
            "title": "Number field element constructors"
        }, 
        {
            "location": "/numberfield/#basic-functionality", 
            "text": "The following basic functionality is provided by the default number field implementation in Nemo, to support construction of generic rings over number fields. Any custom number field implementation in Nemo should provide these  functions along with the usual arithmetic operations.  parent_type(::Type{nf_elem})  Gives the type of the parent object of an Antic number field element.  elem_type(R::AnticNumberField)  Given the parent object for a number field, return the type of elements of the field.  Base.hash(a::nf_elem, h::UInt)  Return a  UInt  hexadecimal hash of the number field element  a . This should be xor'd with a fixed random hexadecimal specific to the number field type. The hash of the coefficients of the number field element representation should be xor'd with the supplied parameter  h  as part of computing the hash.  deepcopy(a::nf_elem)  Construct a copy of the given number field element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo number field elements are mutable and so returning shallow copies is not sufficient.  mul!(c::nf_elem, a::nf_elem, b::nf_elem)  Multiply  a  by  b  and set the existing number field element  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  mul_red!(c::nf_elem, a::nf_elem, b::nf_elem, red::Bool)  Multiply  a  by  b  and set the existing number field element  c  to the result. Reduction modulo the defining polynomial is only performed if  red  is set to  true . Note that  a  and  b  must be reduced. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  reduce!(x::nf_elem)  Reduce the given number field element by the defining polynomial, in-place. This only needs to be done after accumulating values computed by  mul_red!  where reduction has not been performed. All standard Nemo number field functions automatically reduce their outputs.  addeq!(c::nf_elem, a::nf_elem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given the parent object  R  for a number field, the following coercion functions are provided to coerce various elements into the number field. Developers provide these by overloading the  call  operator for the number field parent objects.  R()  Coerce zero into the number field.  R(n::Integer)\nR(f::fmpz)\nR(f::fmpq)  Coerce an integer or rational value into the number field.  R(f::fmpq_poly)  Coerce the given rational polynomial into the number field, i.e. consider the polynomial to be the representation of a number field element and return it.  R(f::nf_elem)  Take a number field element that is already in the number field and simply return it. A copy of the original is not made.  In addition to the above, developers of custom number field types must ensure that they provide the equivalent of the function  base_ring(R::AnticNumberField)  which should return  Union{} . In addition to this they should ensure that each number field element contains a field  parent  specifying the parent object of the number field element, or at least supply the equivalent of the function  parent(a::nf_elem)  to return the parent object of a number field element.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/numberfield/#conversions", 
            "text": "If  R  is the polynomial ring to which the generating polynomial of a number field belongs, then we can coerce number field elements into the ring  R  using the following function.  R(b::nf_elem)  Coerce the given number field element into the polynomial ring  R  of which the number field is a quotient.  Here are some examples of conversions from number field elements.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nf = R(a^2 + 2a + 3)", 
            "title": "Conversions"
        }, 
        {
            "location": "/numberfield/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate number field elements. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(a::AnticNumberField)   Returns  Union{}  since a number field doesn't depend on any ring.   source  #  Nemo.base_ring     Method .  base_ring(a::nf_elem)   Returns  Union{}  since a number field doesn't depend on any ring.   source  #  Base.parent     Method .  parent(a::nf_elem)   Return the parent of the given number field element.   source  #  Base.var     Method .  var(a::AnticNumberField)   Returns the identifier (as a symbol, not a string), that is used for printing the generator of the given number field.   source  #  Nemo.iszero     Method .  iszero(a::nf_elem)   Return  true  if the given number field element is the additive identity of the number field, i.e. zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::nf_elem)   Return  true  if the given number field element is the multiplicative identity of the number field, i.e. one, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::nf_elem)   Return  true  if the given number field element is invertible, i.e. nonzero, otherwise return  false .   source  #  Nemo.isgen     Method .  isgen(a::nf_elem)   Return  true  if the given number field element is the generator of the number field, otherwise return  false .   source  #  Nemo.coeff     Method .  coeff(x::nf_elem, n::Int)   Return the  n -th coefficient of the polynomial representation of the given number field element. Coefficients are numbered from  0 , starting with the constant coefficient.   source  #  Base.den     Method .  den(a::nf_elem)   Return the denominator of the polynomial representation of the given number field element.   source  #  Nemo.degree     Method .  degree(a::AnticNumberField)   Return the degree of the given number field, i.e. the degree of its defining polynomial.   source  #  Nemo.signature     Method .  signature(a::AnticNumberField)   Return the signature of the given number field, i.e. a tuple  r, s  consisting of  r , the number of real embeddings and  s , half the number of complex embeddings.   source  Here are some examples of basic manipulation of number field elements.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nd = a^2 + 2a - 7\nk = zero(K)\nl = one(K)\nm = gen(K)\n\nc = coeff(d, 1)\nisgen(m)\nisone(l)\nq = degree(K)\nr, s = signature(K)\nv = var(R)\nS = parent(a + 1)\nT = base_ring(K)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/numberfield/#arithmetic-operations", 
            "text": "Nemo provides all the standard field operations for number field elements, as follows.     Function  Operation      -(a::nf_elem)  unary minus    +(a::nf_elem, b::nf_elem)  addition    -(a::nf_elem, b::nf_elem)  subtraction    *(a::nf_elem, b::nf_elem)  multiplication    divexact(a::nf_elem, b::nf_elem)  exact division     In addition, the following ad hoc field operations are defined.     Function  Operation      +(a::nf_elem, b::Integer)  addition    +(a::Integer, b::nf_elem)  addition    +(a::nf_elem, b::fmpz)  addition    +(a::fmpz, b::nf_elem)  addition    +(a::nf_elem, b::fmpq)  addition    +(a::fmpq, b::nf_elem)  addition    -(a::nf_elem, b::Integer)  subtraction    -(a::Integer, b::nf_elem)  subtraction    -(a::nf_elem, b::fmpz)  subtraction    -(a::fmpz, b::nf_elem)  subtraction    -(a::nf_elem, b::fmpq)  subtraction    -(a::fmpq, b::nf_elem)  subtraction    *(a::nf_elem, b::Integer)  multiplication    *(a::Integer, b::nf_elem)  multiplication    *(a::nf_elem, b::fmpz)  multiplication    *(a::fmpz, b::nf_elem)  multiplication    *(a::nf_elem, b::fmpq)  multiplication    *(a::fmpq, b::nf_elem)  multiplication    divexact(a::nf_elem, b::Integer)  exact division    divexact(a::nf_elem, b::fmpz)  exact division    divexact(a::nf_elem, b::fmpq)  exact division    divexact(a::Integer, b::nf_elem)  exact division    divexact(a::fmpz, b::nf_elem)  exact division    divexact(a::fmpq, b::nf_elem)  exact division    ^(a::nf_elem, b::Int)  powering     Here are some examples of arithmetic operations on number fields.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nc = a^2 + 2a - 7\nd = 3a^2 - a + 1\n\nf = c + d\ng = c - d\nh = c*d\nk = 3*c\nl = d*ZZ(4)\nm = d*(ZZ(4)//3)\nn = 4 - c\np = divexact(c, 5)\nq = divexact(ZZ(4)//5, d)\nr = c^4", 
            "title": "Arithmetic operations"
        }, 
        {
            "location": "/numberfield/#comparison", 
            "text": "Nemo provides the comparison operation  ==  for number field elements. Julia then automatically provides the corresponding  !=  operation. Here are the functions provided.", 
            "title": "Comparison"
        }, 
        {
            "location": "/numberfield/#function", 
            "text": "==(a::nf_elem, b::nf_elem)  In addition, the following ad hoc comparisons are provided, Julia again providing the corresponding  !=  operators.", 
            "title": "Function"
        }, 
        {
            "location": "/numberfield/#function_1", 
            "text": "==(a::nf_elem, b::Integer) ==(a::nf_elem, b::fmpz) ==(a::nf_elem, b::fmpq) ==(a::Integer, b::nf_elem) ==(a::fmpz, b::nf_elem) ==(a::fmpq, b::nf_elem)  Here are some examples of comparisons.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nc = 3a^2 - a + 1\nd = a^2 + 2a - 7\n\nc != d\nc == 3a^2 - a + 1\nc == 3\nZZ(4) == d\nZZ(5)//7 != c", 
            "title": "Function"
        }, 
        {
            "location": "/numberfield/#divisibility", 
            "text": "#  Nemo.divides     Method .  divides(f::nf_elem, g::nf_elem)   Returns a pair consisting of a flag which is set to  true  if  g  divides  f  and  false  otherwise, and a number field element  h  such that  f = gh  if such exists. If not, the value of  h  is undetermined.   source  Here are some examples of divisibility testing.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nc = 3a^2 - a + 1\nd = a^2 + 2a - 7\n\nflag, q = divides(c*d, c)", 
            "title": "Divisibility"
        }, 
        {
            "location": "/numberfield/#inversion", 
            "text": "#  Base.inv     Method .  inv(a::nf_elem)   Return  a^{-1} . Requires  a \\neq 0 .   source  Here are some examples of inversion.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nc = 3a^2 - a + 1\n\nd = inv(c)", 
            "title": "Inversion"
        }, 
        {
            "location": "/numberfield/#norm-and-trace", 
            "text": "#  Base.LinAlg.norm     Method .  norm(a::nf_elem)   Return the absolute norm of  a . The result will be a rational number.   source  #  Base.LinAlg.trace     Method .  norm(a::nf_elem)   Return the absolute trace of  a . The result will be a rational number.   source  Here are some examples of computing the norm and trace.  R, x = PolynomialRing(QQ,  x )\nK, a = NumberField(x^3 + 3x + 1,  a )\n\nc = 3a^2 - a + 1\n\nd = norm(c)\nf = trace(c)", 
            "title": "Norm and trace"
        }, 
        {
            "location": "/maximalorder/", 
            "text": "Introduction\n\n\nNemo previously provided maximal orders of absolute number fields via the Pari C library. However, Pari will be made optional in future.\n\n\nFor maximal orders there is the Hecke.jl project, which is designed to work as a series of Nemo plugin modules. The Hecke types fit into the Nemo abstract type hierarchy and so can be used recursively just as for all other Nemo types.\n\n\nDetails of Hecke can be found here:\n\n\n\n\nhttp://hecke.readthedocs.io/en/latest/\n (Documentation)\n\n\nhttps://github.com/thofma/Hecke.jl\n (Source code)", 
            "title": "Maximal orders"
        }, 
        {
            "location": "/maximalorder/#introduction", 
            "text": "Nemo previously provided maximal orders of absolute number fields via the Pari C library. However, Pari will be made optional in future.  For maximal orders there is the Hecke.jl project, which is designed to work as a series of Nemo plugin modules. The Hecke types fit into the Nemo abstract type hierarchy and so can be used recursively just as for all other Nemo types.  Details of Hecke can be found here:   http://hecke.readthedocs.io/en/latest/  (Documentation)  https://github.com/thofma/Hecke.jl  (Source code)", 
            "title": "Introduction"
        }, 
        {
            "location": "/classgroup/", 
            "text": "Introduction\n\n\nNemo previously provided class groups of absolute number fields via the Pari C library. However, Pari will be made optional in future.\n\n\nFor class groups there is the Hecke.jl project, which is designed to work as a series of Nemo plugin modules. The Hecke types fit into the Nemo abstract type hierarchy and so can be used recursively just as for all other Nemo types.\n\n\nDetails of Hecke can be found here:\n\n\n\n\nhttp://hecke.readthedocs.io/en/latest/\n (Documentation)\n\n\nhttps://github.com/thofma/Hecke.jl\n (Source code)", 
            "title": "Class groups"
        }, 
        {
            "location": "/classgroup/#introduction", 
            "text": "Nemo previously provided class groups of absolute number fields via the Pari C library. However, Pari will be made optional in future.  For class groups there is the Hecke.jl project, which is designed to work as a series of Nemo plugin modules. The Hecke types fit into the Nemo abstract type hierarchy and so can be used recursively just as for all other Nemo types.  Details of Hecke can be found here:   http://hecke.readthedocs.io/en/latest/  (Documentation)  https://github.com/thofma/Hecke.jl  (Source code)", 
            "title": "Introduction"
        }, 
        {
            "location": "/perm/", 
            "text": "Introduction\n\n\nNemo provides rudimentary support for permutation groups. These are mainly used for permutations of rows of matrices.\n\n\nPermutation groups are created using the \nPermGroup\n (inner) constructor. However, for convenience we define\n\n\nPermutationGroup = PermGroup\n\n\n\n\nso that permutation groups can be created using \nPermutationGroup\n instead of \nPermGroup\n.\n\n\nThe types of permutations in Nemo are given by the following table, along with the libraries that provide them and the associated types of the parent objects.\n\n\n\n\n\n\n\n\nLibrary\n\n\nGroup\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nNative\n\n\n\n\nS_n\n\n\n\n\nperm\n\n\nPermGroup\n\n\n\n\n\n\n\n\nAll the permutation group types belong to the \nGroup\n abstract type and the corresponding permutation element types belong to the \nGroupElem\n abstract type.\n\n\n\n\nPermutation group constructors\n\n\nIn order to construct permutations in Nemo, one must first construct the permutation group they belong to. This is accomplished with the following constructor.\n\n\nPermGroup(n::Int)\n\n\n\n\nConstruct the permutation group on \nn\n points. The function returns the parent object representing the group.\n\n\nHere are some examples of creating a permutation group and using the parent object to create a permutation (the identity permutation).\n\n\nG = PermutationGroup(5)\n\np = G()\n\n\n\n\n\n\nPermutation constructors\n\n\nOnce a permutation group is constructed, there are various ways to construct permutations in that group.\n\n\nApart from the identity permutation coercion as above, we offer the following functions.\n\n\n#\n\n\nBase.eye\n \n \nMethod\n.\n\n\neye(G::PermGroup)\n\n\n\n\n\n\nReturn the identity permutation for the given permutation group.\n\n\n\n\nsource\n\n\nNote that permutations consist of lists of \nn\n integers numbered from \n1\n to \nn\n. If the \ni\n-th entry of a permuation is \nj\n, this corresponds to sending \ni \\to j\n in the permutation.\n\n\nHere are some examples of creating permutations.\n\n\nG = PermutationGroup(5)\n\np = eye(G)\n\n\n\n\n\n\nBasic functionality\n\n\nThe following basic functionality is provided by the default permutation group implementation in Nemo, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in Nemo should provide these  functions along with the usual group element arithmetic.\n\n\nparent_type(::Type{perm})\n\n\n\n\nGives the type of the parent object of a permutation group element.\n\n\nelem_type(R::PermGroup)\n\n\n\n\nGiven the parent object for a permutation group, return the type of elements of the group.\n\n\nBase.hash(a::perm, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the permutation element \na\n. This should be xor'd with a fixed random hexadecimal specific to the permutation group type. The hash of the entries of the permutation should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndeepcopy(a::perm)\n\n\n\n\nConstruct a copy of the given permutation group element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo permutation group elements are mutable and so returning shallow copies is not sufficient.\n\n\ngetindex(a::perm, n::Int)\n\n\n\n\nAllows access to entry \nn\n of the given permutation via the syntas \na[n]\n. Note that entries are \n1\n-indexed.\n\n\nsetindex!(a::perm, d::Int, n::Int)\n\n\n\n\nSet the \nn\n-th entry of the given permutation to \nd\n. This allows Julia to provide the syntax \na[n] = d\n for setting entries of a permuation. Note that entries are \n1\n-indexed.\n\n\nGiven the parent object \nG\n for a permutation group, the following coercion functions are provided to coerce various elements into the permutation group. Developers provide these by overloading the \ncall\n operator for the permutation group parent objects.\n\n\nR()\n\n\n\n\nReturn the identity permutation.\n\n\nR(A::Array{Int, 1})\n\n\n\n\nReturn the permutation whose entries are given by the elements of the supplied vector.\n\n\nR(p::perm)\n\n\n\n\nTake a permutation that is already in the permutation group and simply return it. A copy of the original is not made.\n\n\nIn addition to the above, developers of custom permutation group types must ensure that each permutation element contains a field \nparent\n specifying the parent object of the permutation group element, or at least supply the equivalent of the function \nparent(a::perm)\n to return the parent object of a permutation group element.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate permutation group elements. Also see the section on basic functionality above.\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::perm)\n\n\n\n\n\n\nReturn the parent of the given permutation group element.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parity\n \n \nMethod\n.\n\n\nparity(a::perm)\n\n\n\n\n\n\nReturn the parity of the given permutation, i.e. the parity of the number of transpositions that compose it. The function returns \n1\n if the parity is odd otherwise it returns \n0\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of permutations.\n\n\nG = PermutationGroup(5)\n\np = G([1, 3, 5, 2, 4])\n\nR = parent(p)\na = parity(p)\n\n\n\n\n\n\nArithmetic operators\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a::perm, b::perm)\n\n\n\n\n\n\nReturn the composition of the two permutations, i.e. \na\\circ b\n. In other words, the permutation corresponding to applying \nb\n first, then \na\n, is returned.\n\n\n\n\nsource\n\n\nHere are some examples of arithmetic operations.\n\n\nG = PermutationGroup(5)\n\np = G([1, 3, 5, 2, 4])\nq = G([5, 4, 1, 3, 2])\n\na = p*q\n\n\n\n\n\n\nComparison\n\n\n``@docs ==(::perm, ::perm)\n\n\n\nHere are some examples of comparison.\n\n\n\n\n\nG = PermutationGroup(5)\n\n\np = G([1, 3, 5, 2, 4]) q = G([5, 4, 1, 3, 2])\n\n\np == q\n\n\n\n## Inversion\n\n\n\n\n\n@docs inv(::perm)\n\n\n\nHere are some examples of inversion.\n\n\n\n\n\nG = PermutationGroup(5)\n\n\np = G([1, 3, 5, 2, 4])\n\n\na = inv(p) ```", 
            "title": "Permutation groups"
        }, 
        {
            "location": "/perm/#introduction", 
            "text": "Nemo provides rudimentary support for permutation groups. These are mainly used for permutations of rows of matrices.  Permutation groups are created using the  PermGroup  (inner) constructor. However, for convenience we define  PermutationGroup = PermGroup  so that permutation groups can be created using  PermutationGroup  instead of  PermGroup .  The types of permutations in Nemo are given by the following table, along with the libraries that provide them and the associated types of the parent objects.     Library  Group  Element type  Parent type      Native   S_n   perm  PermGroup     All the permutation group types belong to the  Group  abstract type and the corresponding permutation element types belong to the  GroupElem  abstract type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/perm/#permutation-group-constructors", 
            "text": "In order to construct permutations in Nemo, one must first construct the permutation group they belong to. This is accomplished with the following constructor.  PermGroup(n::Int)  Construct the permutation group on  n  points. The function returns the parent object representing the group.  Here are some examples of creating a permutation group and using the parent object to create a permutation (the identity permutation).  G = PermutationGroup(5)\n\np = G()", 
            "title": "Permutation group constructors"
        }, 
        {
            "location": "/perm/#permutation-constructors", 
            "text": "Once a permutation group is constructed, there are various ways to construct permutations in that group.  Apart from the identity permutation coercion as above, we offer the following functions.  #  Base.eye     Method .  eye(G::PermGroup)   Return the identity permutation for the given permutation group.   source  Note that permutations consist of lists of  n  integers numbered from  1  to  n . If the  i -th entry of a permuation is  j , this corresponds to sending  i \\to j  in the permutation.  Here are some examples of creating permutations.  G = PermutationGroup(5)\n\np = eye(G)", 
            "title": "Permutation constructors"
        }, 
        {
            "location": "/perm/#basic-functionality", 
            "text": "The following basic functionality is provided by the default permutation group implementation in Nemo, to support construction of other generic constructions over permutation groups. Any custom permutation group implementation in Nemo should provide these  functions along with the usual group element arithmetic.  parent_type(::Type{perm})  Gives the type of the parent object of a permutation group element.  elem_type(R::PermGroup)  Given the parent object for a permutation group, return the type of elements of the group.  Base.hash(a::perm, h::UInt)  Return a  UInt  hexadecimal hash of the permutation element  a . This should be xor'd with a fixed random hexadecimal specific to the permutation group type. The hash of the entries of the permutation should be xor'd with the supplied parameter  h  as part of computing the hash.  deepcopy(a::perm)  Construct a copy of the given permutation group element and return it. This function must recursively construct copies of all of the internal data in the given element. Nemo permutation group elements are mutable and so returning shallow copies is not sufficient.  getindex(a::perm, n::Int)  Allows access to entry  n  of the given permutation via the syntas  a[n] . Note that entries are  1 -indexed.  setindex!(a::perm, d::Int, n::Int)  Set the  n -th entry of the given permutation to  d . This allows Julia to provide the syntax  a[n] = d  for setting entries of a permuation. Note that entries are  1 -indexed.  Given the parent object  G  for a permutation group, the following coercion functions are provided to coerce various elements into the permutation group. Developers provide these by overloading the  call  operator for the permutation group parent objects.  R()  Return the identity permutation.  R(A::Array{Int, 1})  Return the permutation whose entries are given by the elements of the supplied vector.  R(p::perm)  Take a permutation that is already in the permutation group and simply return it. A copy of the original is not made.  In addition to the above, developers of custom permutation group types must ensure that each permutation element contains a field  parent  specifying the parent object of the permutation group element, or at least supply the equivalent of the function  parent(a::perm)  to return the parent object of a permutation group element.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/perm/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate permutation group elements. Also see the section on basic functionality above.  #  Base.parent     Method .  parent(a::perm)   Return the parent of the given permutation group element.   source  #  Base.parity     Method .  parity(a::perm)   Return the parity of the given permutation, i.e. the parity of the number of transpositions that compose it. The function returns  1  if the parity is odd otherwise it returns  0 .   source  Here are some examples of basic manipulation of permutations.  G = PermutationGroup(5)\n\np = G([1, 3, 5, 2, 4])\n\nR = parent(p)\na = parity(p)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/perm/#arithmetic-operators", 
            "text": "#  Base.:*     Method .  *(a::perm, b::perm)   Return the composition of the two permutations, i.e.  a\\circ b . In other words, the permutation corresponding to applying  b  first, then  a , is returned.   source  Here are some examples of arithmetic operations.  G = PermutationGroup(5)\n\np = G([1, 3, 5, 2, 4])\nq = G([5, 4, 1, 3, 2])\n\na = p*q", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/perm/#comparison", 
            "text": "``@docs ==(::perm, ::perm)  \nHere are some examples of comparison.  G = PermutationGroup(5)  p = G([1, 3, 5, 2, 4]) q = G([5, 4, 1, 3, 2])  p == q  \n## Inversion  @docs inv(::perm)  \nHere are some examples of inversion.  G = PermutationGroup(5)  p = G([1, 3, 5, 2, 4])  a = inv(p) ```", 
            "title": "Comparison"
        }, 
        {
            "location": "/factor/", 
            "text": "Introduction\n\n\nNemo provides a unified interface to handle factorizations using the \nFact\n objects. These can only be constructed using the factor function for the respective ring elements. This is best illustrated by an example.\n\n\njulia\n fac = factor(ZZ(-6000361807272228723606))\n-1 * 2 * 229^3 * 43669^3 * 3\n\njulia\n unit(fac)\n-1\n\njulia\n -6000361807272228723606 == unit(fac) * prod([ p^e for (p, e) in fac])\ntrue\n\njulia\n for (p, e) in fac; println(\n$p $e\n); end\n2 1\n229 3\n43669 3\n3 1\n\njulia\n 229 in fac\ntrue\n\njulia\n fac[229]\n3\n\n\n\n\n\n\nBasic functionality\n\n\nObjects of type \nFac\n are iterable, that is, if \na\n is an object of type \nFac\n, then \nfor (p, e) in a\n will iterate through all pairs \n(p, e)\n, where \np\n is a factor and \ne\n the corresponding exponent.\n\n\nin{T}(a::T, ::Fac{T})\ngetindex{T}(::Fac{T}, T)\nlength(::Fac)\nunit(::Fac)", 
            "title": "Factorization"
        }, 
        {
            "location": "/factor/#introduction", 
            "text": "Nemo provides a unified interface to handle factorizations using the  Fact  objects. These can only be constructed using the factor function for the respective ring elements. This is best illustrated by an example.  julia  fac = factor(ZZ(-6000361807272228723606))\n-1 * 2 * 229^3 * 43669^3 * 3\n\njulia  unit(fac)\n-1\n\njulia  -6000361807272228723606 == unit(fac) * prod([ p^e for (p, e) in fac])\ntrue\n\njulia  for (p, e) in fac; println( $p $e ); end\n2 1\n229 3\n43669 3\n3 1\n\njulia  229 in fac\ntrue\n\njulia  fac[229]\n3", 
            "title": "Introduction"
        }, 
        {
            "location": "/factor/#basic-functionality", 
            "text": "Objects of type  Fac  are iterable, that is, if  a  is an object of type  Fac , then  for (p, e) in a  will iterate through all pairs  (p, e) , where  p  is a factor and  e  the corresponding exponent.  in{T}(a::T, ::Fac{T})\ngetindex{T}(::Fac{T}, T)\nlength(::Fac)\nunit(::Fac)", 
            "title": "Basic functionality"
        }
    ]
}
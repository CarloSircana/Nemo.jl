{
    "docs": [
        {
            "location": "/", 
            "text": "Nemo\n\n\nIntroduction\n\n\nNemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.\n\n\n\n\nhttp://nemocas.org\n (Website)\n\n\nhttps://github.com/Nemocas/Nemo.jl\n (Source code)\n\n\nhttp://nemo.readthedocs.org/en/latest/\n (Online documentation)\n\n\n\n\nThe features of Nemo so far include:\n\n\n\n\nMultiprecision integers and rationals\n\n\nIntegers modulo n\n\n\np-adic numbers\n\n\nFinite fields (prime and non-prime order)\n\n\nNumber field arithmetic\n\n\nMaximal orders of number fields\n\n\nArithmetic of ideals in maximal orders\n\n\nArbitrary precision real and complex balls\n\n\nUnivariate polynomials and matrices over the above\n\n\nGeneric polynomials, power series, fraction fields, residue rings and matrices\n\n\n\n\nInstallation\n\n\nTo use Nemo we require Julia 0.4 or higher. Please see\n\nhttp://julialang.org/downloads\n for instructions on how to obtain\njulia for your system.\n\n\nAt the Julia prompt simply type\n\n\njulia\n Pkg.add(\nNemo\n)\njulia\n Pkg.build(\nNemo\n)\n\n\n\n\nAlternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https://cloud.sagemath.com/).\n\n\nQuick start\n\n\nHere are some examples of using Nemo.\n\n\nThis example computes recursive univariate polynomials.\n\n\njulia\n using Nemo\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia\n T, z = PolynomialRing(S, \nz\n)\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia\n f = x + y + z + 1\nz+(y+(x+1))\n\njulia\n p = f^30; # semicolon supresses output\n\njulia\n @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)\n\n\n\n\nHere is an example using generic recursive ring constructions.\n\n\njulia\n using Nemo\n\njulia\n R, x = FiniteField(7, 11, \nx\n)\n(Finite field of degree 11 over F_7,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia\n T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia\n U, z = PolynomialRing(T, \nz\n)\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia\n f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia\n g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia\n s = f^12;\n\njulia\n t = (s + g)^12;\n\njulia\n @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)\n\n\n\n\nHere is an example using matrices.\n\n\njulia\n using Nemo\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia\n @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)\n\n\n\n\nAnd here is an example with power series.\n\n\njulia\n using Nemo\n\njulia\n R, x = QQ[\nx\n]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia\n S, t = PowerSeriesRing(R, 100, \nt\n)\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia\n u = t + O(t^100)\nt+O(t^100)\n\njulia\n @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/#introduction", 
            "text": "Nemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.   http://nemocas.org  (Website)  https://github.com/Nemocas/Nemo.jl  (Source code)  http://nemo.readthedocs.org/en/latest/  (Online documentation)   The features of Nemo so far include:   Multiprecision integers and rationals  Integers modulo n  p-adic numbers  Finite fields (prime and non-prime order)  Number field arithmetic  Maximal orders of number fields  Arithmetic of ideals in maximal orders  Arbitrary precision real and complex balls  Univariate polynomials and matrices over the above  Generic polynomials, power series, fraction fields, residue rings and matrices", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Nemo we require Julia 0.4 or higher. Please see http://julialang.org/downloads  for instructions on how to obtain\njulia for your system.  At the Julia prompt simply type  julia  Pkg.add( Nemo )\njulia  Pkg.build( Nemo )  Alternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https://cloud.sagemath.com/).", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here are some examples of using Nemo.  This example computes recursive univariate polynomials.  julia  using Nemo\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia  T, z = PolynomialRing(S,  z )\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia  f = x + y + z + 1\nz+(y+(x+1))\n\njulia  p = f^30; # semicolon supresses output\n\njulia  @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)  Here is an example using generic recursive ring constructions.  julia  using Nemo\n\njulia  R, x = FiniteField(7, 11,  x )\n(Finite field of degree 11 over F_7,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia  T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia  U, z = PolynomialRing(T,  z )\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia  f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia  g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia  s = f^12;\n\njulia  t = (s + g)^12;\n\njulia  @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)  Here is an example using matrices.  julia  using Nemo\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia  @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)  And here is an example with power series.  julia  using Nemo\n\njulia  R, x = QQ[ x ]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia  S, t = PowerSeriesRing(R, 100,  t )\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia  u = t + O(t^100)\nt+O(t^100)\n\njulia  @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Quick start"
        }, 
        {
            "location": "/about/", 
            "text": "Nemo\n\n\nWhat is Nemo?\n\n\nNemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering\n\n\n\n\nCommutative Algebra\n\n\nNumber Theory\n\n\nGroup Theory\n\n\n\n\nNemo consists of wrappers of specialised C/C++ libraries:\n\n\n\n\nFlint    [http://flintlib.org/]\n\n\nArb      [http://fredrikj.net/arb/]\n\n\nAntic    [https://github.com/wbhart/antic/]\n\n\nSingular [https://www.singular.uni-kl.de/]\n\n\nPari     [http://pari.math.u-bordeaux.fr/]\n\n\n\n\nIt will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.\n\n\nNemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include\n\n\n\n\nUnivariate polynomial rings\n\n\nPower series rings\n\n\nResidue rings (modulo principal ideals)\n\n\nFraction fields\n\n\nMatrices\n\n\n\n\nWhy Julia?\n\n\nJulia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.\n\n\nThe benefits of Julia include\n\n\n\n\nFamiliar imperative syntax\n\n\nJIT compilation (provides near native performance, even for highly generic code)\n\n\nREPL console (cuts down on development time)\n\n\nParametric types (allows for fast generic constructions over other data types)\n\n\nPowerful metaprogramming facilities\n\n\nOperator overloading\n\n\nMultiple dispatch (dispatch on every argument of a function)\n\n\nEfficient native C interface (no wrapper overhead)\n\n\nExperimental C++ interface\n\n\nDynamic type inference\n\n\nBuilt-in bignums\n\n\nAble to be embedded in C programs\n\n\nHigh performance collection types (dictionaries, iterators, arrays, etc.)\n\n\nJupyter support (for web based notebooks)\n\n\n\n\nThe main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "About Nemo"
        }, 
        {
            "location": "/about/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/about/#what-is-nemo", 
            "text": "Nemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering   Commutative Algebra  Number Theory  Group Theory   Nemo consists of wrappers of specialised C/C++ libraries:   Flint    [http://flintlib.org/]  Arb      [http://fredrikj.net/arb/]  Antic    [https://github.com/wbhart/antic/]  Singular [https://www.singular.uni-kl.de/]  Pari     [http://pari.math.u-bordeaux.fr/]   It will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.  Nemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include   Univariate polynomial rings  Power series rings  Residue rings (modulo principal ideals)  Fraction fields  Matrices", 
            "title": "What is Nemo?"
        }, 
        {
            "location": "/about/#why-julia", 
            "text": "Julia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.  The benefits of Julia include   Familiar imperative syntax  JIT compilation (provides near native performance, even for highly generic code)  REPL console (cuts down on development time)  Parametric types (allows for fast generic constructions over other data types)  Powerful metaprogramming facilities  Operator overloading  Multiple dispatch (dispatch on every argument of a function)  Efficient native C interface (no wrapper overhead)  Experimental C++ interface  Dynamic type inference  Built-in bignums  Able to be embedded in C programs  High performance collection types (dictionaries, iterators, arrays, etc.)  Jupyter support (for web based notebooks)   The main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "Why Julia?"
        }, 
        {
            "location": "/types/", 
            "text": "Types in Nemo\n\n\nOn this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations. \n\n\nIn contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.\n\n\nIntroduction\n\n\nJulia provides two levels of types that we make use of\n\n\n\n\nabstract types\n\n\nconcrete types\n\n\n\n\nConcrete types are just like the usual types everyone is familiar with from C or C++.\n\n\nAbstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.\n\n\nTo write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter, \nT\n say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter \nT\n must belong to.\n\n\nWe use the symbol \n:\n in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type \nInt64\n for 64 bit machine integers belongs to the Julia abstract type\n\nInteger\n. Thus \nInt \n: Integer\n returns \ntrue\n.\n\n\nHere is some Julia code illustrating this with a more complex example. We create an abstract type called\n\nShape\n and two user defined concrete types \nsquare\n and \ncircle\n belonging to \nShape\n. We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type \nT\n belonging to the abstract type \nShape\n.\n\n\nNote that in the type definitions of \nsquare\n and \ncircle\n we specify that those types belong to the\nabstract type \nShape\n using the \n:\n operator.\n\n\nabstract Shape\n\ntype square \n: Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle \n: Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T \n: Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)\n\n\n\n\nThe abstract type hierarchy in Nemo\n\n\nAbstract types in Julia can also belong to one another in a hierarchy. For example, the \nNemo.Field\n\nabstract type belongs to the \nNemo.Ring\n abstract type. An object representing a field in Nemo has type\nbelonging to \nNemo.Field\n. But because we define the inclusion \nNemo.Field \n: Nemo.Ring\n in Nemo, the\ntype of such an object also automatically belongs to \nNemo.Ring\n. This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.\n\n\nIn Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type\n\nGenPolyRing\n to model a generic polynomial ring, and elements of that polynomial ring would have\ntype \nGenPoly\n. \n\n\nIn order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains. \n\n\n\n\nAll objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.\n\n\nWhy types aren't enough\n\n\nNaively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.\n\n\nAs an example, consider the ring \nR = \\mathbb{Z}/n\\mathbb{Z}\n for a multiprecision integer \nn\n. If we\nwere to model the ring \nR\n as a type, then the type would somehow need to contain the modulus\n\nn\n. This is not possible in Julia, and in fact it is not desirable either.\n\n\nJulia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings \n\\mathbb{Z}/n\\mathbb{Z}\n would be needed\nand every function we use would be recompiled over and over for each different \nn\n. This would result \nin a huge delay as the compiler is invoked many times.\n\n\nFor this reason, the modulus \nn\n needs to be attached to the \nelements\n of the ring, not to type\nassociated with those elements.\n\n\nBut now we have a problem. How do we create new elements of the ring \n\\mathbb{Z}/n\\mathbb{Z}\n given only\nthe type? Suppose all rings \n\\mathbb{Z}/n\\mathbb{Z}\n were represented by the same type \nZmod\n say. How\nwould we create \na = 3 \\pmod{7}\n? We could not write \na = Zmod(3)\n since the modulus \n7\n is not contained\nin the type \nZmod\n.\n\n\nWe could of course use the notation \na = Zmod(3, 7)\n, but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as \na = ZZ(7)\n and cases where they take a modulus, such as \na = Zmod(3, 7)\n.\n\n\nThe way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called \nparent\n objects can contain extra information,\nsuch as the modulus \nn\n. \n\n\nIn order to create new elements of \n\\mathbb{Z}/n\\mathbb{Z}\n as above, we overload the \ncall\n operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.\n\n\nIn the following Nemo example, we create the parent object \nR\n corresponding to the ring\n\n\\mathbb{Z}/7\\mathbb{Z}\n. We then create a new element \na\n of this ring by calling the parent object\n\nR\n, just as though \nR\n were a type with a constructor accepting an \nInt\n parameter. \n\n\nR = ResidueRing(ZZ, 7)\na = R(3)\n\n\n\n\nThis example creates the element \na = 3 \\pmod{7}\n. \n\n\nThe important point is that unlike a type, a parent object such as \nR\n can contain additional information\nthat a type cannot contain, such as the modulus \n7\n of the ring in this example, or context objects\nrequired by C libraries in other examples.\n\n\nMore complex example of parent objects\n\n\nHere is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.\n\n\njulia\n using Nemo\n\njulia\n R, x = ZZ[\nx\n]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia\n typeof(R)\nNemo.FmpzPolyRing\n\njulia\n typeof(f)\nNemo.fmpz_poly\n\njulia\n parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia\n typeof(R) \n: PolyRing\ntrue\n\njulia\n typeof(f) \n: PolyElem\ntrue\n\njulia\n parent(f) == R\ntrue\n\n\n\n\nConcrete types in Nemo\n\n\nFinally we come to all the concrete types in Nemo. \n\n\nThese are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).\n\n\nBelow we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess. \n\n\nFor example, \nfmpz\n belongs to the abstract type \nRingElem\n and \nFlintIntegerRing\n belongs to \nRing\n.\nSimilarly \nPoly{T}\n belongs to \nPolyElem\n whereas \nPolynomialRing{T}\n belongs to \nPolyRing\n. We also\nhave that \nfmpz_poly\n belongs to \nPolyElem\n and \nFmpzPolyRing\n belongs to \nPolyRing\n, and so on.\n\n\nAll the generic types are parameterised by a type \nT\n which is the type of the \nelements\n of the ring\nthey are defined over. \n\n\n\n\n\n\nGeneric\n\n\n\n\nGenPoly{T}\n (\nGenPolyRing{T}\n)\n\n\nGenRelSeries{T}\n (\nGenRelSeriesRing{T}\n)\n\n\nGenRes{T}\n (\nGenResRing{T}\n)\n\n\nGenFrac{T}\n (\nGenFracField{T}\n)\n\n\nGenMat{T}\n (\nGenMatSpace{T}\n)\n\n\n\n\n\n\n\n\nFlint\n\n\n\n\nfmpz\n (\nFlintIntegerRing\n)\n\n\nfmpq\n (\nFlintRationalField\n)\n\n\nfq_nmod\n (\nFqNmodFiniteField\n)\n\n\nfq\n (\nFqFiniteField\n)\n\n\npadic\n (\nFlintPadicField\n)\n\n\nfmpz_poly\n (\nFmpzPolyRing\n)\n\n\nfmpq_poly\n (\nFmpqPolyRing\n)\n\n\nnmod_poly\n (\nNmodPolyRing\n)\n\n\nfmpz_mod_poly\n (\nFmpzModPolyRing\n)\n\n\nfq_poly\n (\nFqPolyRing\n)\n\n\nfq_nmod_poly\n (\nFqNmodPolyRing\n)\n\n\nfmpz_series\n (\nFmpzSeriesRing\n)\n\n\nfmpq_series\n (\nFmpqSeriesRing\n)\n\n\nfmpz_mod_series\n (\nFmpzModSeriesRing\n)\n\n\nfq_nmod_series\n (\nFqNmodSeriesRing\n)\n\n\nfq_series\n (\nFqSeriesRing\n)\n\n\nfmpz_mat\n (\nFmpzMatSpace\n)\n\n\nnmod_mat\n (\nNmodMatSpace\n)\n\n\nperm\n (\nFlintPermGroup\n)\n\n\n\n\n\n\n\n\nAntic\n\n\n\n\nnf_elem\n (\nAnticNumberField\n)\n\n\n\n\n\n\n\n\nArb\n\n\n\n\narb\n (\nArbField\n)\n\n\nacb\n (\nAcbField\n)\n\n\n\n\n\n\n\n\nPari\n\n\n\n\npari_int\n (\nPariIntegerRing\n)\n\n\npari_rat\n (\nPariRationalField\n)\n\n\npari_vec{T}\n (\nPariVector{T}\n)\n\n\npari_poly{T}\n (\nPariPolyRing{T}\n)\n\n\npari_polmod{T}\n (\nPariPolModRing{T}\n)\n\n\npari_maximal_order_elem\n (\nPariMaximalOrder\n)\n\n\nPariIdeal\n (\nPariIdealSet\n)\n\n\nno element type (\nPariNumberField\n)\n\n\nPariFactor{T}\n (no parent type)", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#types-in-nemo", 
            "text": "On this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations.   In contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#introduction", 
            "text": "Julia provides two levels of types that we make use of   abstract types  concrete types   Concrete types are just like the usual types everyone is familiar with from C or C++.  Abstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.  To write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter,  T  say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter  T  must belong to.  We use the symbol  :  in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type  Int64  for 64 bit machine integers belongs to the Julia abstract type Integer . Thus  Int  : Integer  returns  true .  Here is some Julia code illustrating this with a more complex example. We create an abstract type called Shape  and two user defined concrete types  square  and  circle  belonging to  Shape . We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type  T  belonging to the abstract type  Shape .  Note that in the type definitions of  square  and  circle  we specify that those types belong to the\nabstract type  Shape  using the  :  operator.  abstract Shape\n\ntype square  : Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle  : Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T  : Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)", 
            "title": "Introduction"
        }, 
        {
            "location": "/types/#the-abstract-type-hierarchy-in-nemo", 
            "text": "Abstract types in Julia can also belong to one another in a hierarchy. For example, the  Nemo.Field \nabstract type belongs to the  Nemo.Ring  abstract type. An object representing a field in Nemo has type\nbelonging to  Nemo.Field . But because we define the inclusion  Nemo.Field  : Nemo.Ring  in Nemo, the\ntype of such an object also automatically belongs to  Nemo.Ring . This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.  In Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type GenPolyRing  to model a generic polynomial ring, and elements of that polynomial ring would have\ntype  GenPoly .   In order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains.    All objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.", 
            "title": "The abstract type hierarchy in Nemo"
        }, 
        {
            "location": "/types/#why-types-arent-enough", 
            "text": "Naively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.  As an example, consider the ring  R = \\mathbb{Z}/n\\mathbb{Z}  for a multiprecision integer  n . If we\nwere to model the ring  R  as a type, then the type would somehow need to contain the modulus n . This is not possible in Julia, and in fact it is not desirable either.  Julia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings  \\mathbb{Z}/n\\mathbb{Z}  would be needed\nand every function we use would be recompiled over and over for each different  n . This would result \nin a huge delay as the compiler is invoked many times.  For this reason, the modulus  n  needs to be attached to the  elements  of the ring, not to type\nassociated with those elements.  But now we have a problem. How do we create new elements of the ring  \\mathbb{Z}/n\\mathbb{Z}  given only\nthe type? Suppose all rings  \\mathbb{Z}/n\\mathbb{Z}  were represented by the same type  Zmod  say. How\nwould we create  a = 3 \\pmod{7} ? We could not write  a = Zmod(3)  since the modulus  7  is not contained\nin the type  Zmod .  We could of course use the notation  a = Zmod(3, 7) , but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as  a = ZZ(7)  and cases where they take a modulus, such as  a = Zmod(3, 7) .  The way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called  parent  objects can contain extra information,\nsuch as the modulus  n .   In order to create new elements of  \\mathbb{Z}/n\\mathbb{Z}  as above, we overload the  call  operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.  In the following Nemo example, we create the parent object  R  corresponding to the ring \\mathbb{Z}/7\\mathbb{Z} . We then create a new element  a  of this ring by calling the parent object R , just as though  R  were a type with a constructor accepting an  Int  parameter.   R = ResidueRing(ZZ, 7)\na = R(3)  This example creates the element  a = 3 \\pmod{7} .   The important point is that unlike a type, a parent object such as  R  can contain additional information\nthat a type cannot contain, such as the modulus  7  of the ring in this example, or context objects\nrequired by C libraries in other examples.", 
            "title": "Why types aren't enough"
        }, 
        {
            "location": "/types/#more-complex-example-of-parent-objects", 
            "text": "Here is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.  julia  using Nemo\n\njulia  R, x = ZZ[ x ]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia  typeof(R)\nNemo.FmpzPolyRing\n\njulia  typeof(f)\nNemo.fmpz_poly\n\njulia  parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia  typeof(R)  : PolyRing\ntrue\n\njulia  typeof(f)  : PolyElem\ntrue\n\njulia  parent(f) == R\ntrue", 
            "title": "More complex example of parent objects"
        }, 
        {
            "location": "/types/#concrete-types-in-nemo", 
            "text": "Finally we come to all the concrete types in Nemo.   These are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).  Below we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess.   For example,  fmpz  belongs to the abstract type  RingElem  and  FlintIntegerRing  belongs to  Ring .\nSimilarly  Poly{T}  belongs to  PolyElem  whereas  PolynomialRing{T}  belongs to  PolyRing . We also\nhave that  fmpz_poly  belongs to  PolyElem  and  FmpzPolyRing  belongs to  PolyRing , and so on.  All the generic types are parameterised by a type  T  which is the type of the  elements  of the ring\nthey are defined over.     Generic   GenPoly{T}  ( GenPolyRing{T} )  GenRelSeries{T}  ( GenRelSeriesRing{T} )  GenRes{T}  ( GenResRing{T} )  GenFrac{T}  ( GenFracField{T} )  GenMat{T}  ( GenMatSpace{T} )     Flint   fmpz  ( FlintIntegerRing )  fmpq  ( FlintRationalField )  fq_nmod  ( FqNmodFiniteField )  fq  ( FqFiniteField )  padic  ( FlintPadicField )  fmpz_poly  ( FmpzPolyRing )  fmpq_poly  ( FmpqPolyRing )  nmod_poly  ( NmodPolyRing )  fmpz_mod_poly  ( FmpzModPolyRing )  fq_poly  ( FqPolyRing )  fq_nmod_poly  ( FqNmodPolyRing )  fmpz_series  ( FmpzSeriesRing )  fmpq_series  ( FmpqSeriesRing )  fmpz_mod_series  ( FmpzModSeriesRing )  fq_nmod_series  ( FqNmodSeriesRing )  fq_series  ( FqSeriesRing )  fmpz_mat  ( FmpzMatSpace )  nmod_mat  ( NmodMatSpace )  perm  ( FlintPermGroup )     Antic   nf_elem  ( AnticNumberField )     Arb   arb  ( ArbField )  acb  ( AcbField )     Pari   pari_int  ( PariIntegerRing )  pari_rat  ( PariRationalField )  pari_vec{T}  ( PariVector{T} )  pari_poly{T}  ( PariPolyRing{T} )  pari_polmod{T}  ( PariPolModRing{T} )  pari_maximal_order_elem  ( PariMaximalOrder )  PariIdeal  ( PariIdealSet )  no element type ( PariNumberField )  PariFactor{T}  (no parent type)", 
            "title": "Concrete types in Nemo"
        }, 
        {
            "location": "/constructors/", 
            "text": "Constructing mathematical objects in Nemo\n\n\nConstructing objects in Julia\n\n\nIn Julia, one constructs objects of a given type by calling a type constructor. This is simply a function\nwith the same name as the type itself. For example, to construct a \nBigInt\n object in Julia, we simply\ncall the \nBigInt\n constructor:\n\n\nn = BigInt(\n1234567898765434567898765434567876543456787654567890\n)\n\n\n\n\nJulia also uses constructors to convert between types. For example, to convert an \nInt\n to a \nBigInt\n:\n\n\nm = BigInt(123)\n\n\n\n\nHow we construct objects in Nemo\n\n\nAs we explained in the previous section, Julia types don't contain enough information to properly model\nthe ring of integers modulo \nn\n for a multiprecision modulus \nn\n. Instead of using types to construct\nobjects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.\n\n\nConsider the following simple example, to create a Flint multiprecision integer:\n\n\nn = ZZ(\n12345678765456787654567890987654567898765678909876567890\n)\n\n\n\n\nHere \nZZ\n is not a Julia type, but a callable object. However, for most purposes one can think of such\na parent object \nZZ\n as though it were a type.\n\n\nConstructing parent objects\n\n\nFor more complicated groups, rings, fields, etc., one first needs to construct the parent object before\none can use it to construct element objects.\n\n\nNemo provides a set of functions for constructing such parent objects. For example, to create a parent\nobject for polynomials over the integers, we use the \nPolynomialRing\n parent object constructor.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nf = x^3 + 3x + 1\ng = R(12)\n\n\n\n\nIn this example, \nR\n is the parent object and we use it to convert the \nInt\n value \n12\n to an element\nof the polynomial ring \n\\mathbb{Z}[x]\n.\n\n\nList of parent object constructors\n\n\nFor convenience, we provide a list of all the parent object constructors in Nemo and explain what domains\nthey represent.\n\n\n\n\n\n\n\n\nMathematics\n\n\nNemo constructor\n\n\n\n\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}\n\n\n\n\nR = ZZ\n\n\n\n\n\n\n\n\nR = \\mathbb{Q}\n\n\n\n\nR = QQ\n\n\n\n\n\n\n\n\nR = \\mathbb{F}_{p^n}\n\n\n\n\nR, a = FiniteField(p, n, \"a\")\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}/n\\mathbb{Z}\n\n\n\n\nR = ResidueRing(ZZ, n)\n\n\n\n\n\n\n\n\nS = R[x]\n\n\n\n\nS, x = PolynomialRing(R, \"x\")\n\n\n\n\n\n\n\n\nS = R[x]\n (to precision \nn\n)\n\n\nS, x = PowerSeriesRing(R, n, \"x\")\n\n\n\n\n\n\n\n\nS = \\mbox{Frac}_R\n\n\n\n\nS = FractionField(R)\n\n\n\n\n\n\n\n\nS = R/(f)\n\n\n\n\nS = ResidueRing(R, f)\n\n\n\n\n\n\n\n\nS = \\mbox{Mat}_{m\\times n}(R)\n\n\n\n\nS = MatrixSpace(R, m, n)\n\n\n\n\n\n\n\n\nS = \\mathbb{Q}[x]/(f)\n\n\n\n\nS, a = NumberField(f, \"a\")\n\n\n\n\n\n\n\n\nO = \\mathcal{O}_K\n\n\n\n\nS = MaximalOrder(K)\n\n\n\n\n\n\nideal \nI\n of \nO = \\mathcal{O}_K\n\n\n\n\nI = Ideal(O, gens, ...)", 
            "title": "Parent object constructors"
        }, 
        {
            "location": "/constructors/#constructing-mathematical-objects-in-nemo", 
            "text": "", 
            "title": "Constructing mathematical objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-objects-in-julia", 
            "text": "In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function\nwith the same name as the type itself. For example, to construct a  BigInt  object in Julia, we simply\ncall the  BigInt  constructor:  n = BigInt( 1234567898765434567898765434567876543456787654567890 )  Julia also uses constructors to convert between types. For example, to convert an  Int  to a  BigInt :  m = BigInt(123)", 
            "title": "Constructing objects in Julia"
        }, 
        {
            "location": "/constructors/#how-we-construct-objects-in-nemo", 
            "text": "As we explained in the previous section, Julia types don't contain enough information to properly model\nthe ring of integers modulo  n  for a multiprecision modulus  n . Instead of using types to construct\nobjects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.  Consider the following simple example, to create a Flint multiprecision integer:  n = ZZ( 12345678765456787654567890987654567898765678909876567890 )  Here  ZZ  is not a Julia type, but a callable object. However, for most purposes one can think of such\na parent object  ZZ  as though it were a type.", 
            "title": "How we construct objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-parent-objects", 
            "text": "For more complicated groups, rings, fields, etc., one first needs to construct the parent object before\none can use it to construct element objects.  Nemo provides a set of functions for constructing such parent objects. For example, to create a parent\nobject for polynomials over the integers, we use the  PolynomialRing  parent object constructor.  R, x = PolynomialRing(ZZ,  x )\nf = x^3 + 3x + 1\ng = R(12)  In this example,  R  is the parent object and we use it to convert the  Int  value  12  to an element\nof the polynomial ring  \\mathbb{Z}[x] .", 
            "title": "Constructing parent objects"
        }, 
        {
            "location": "/constructors/#list-of-parent-object-constructors", 
            "text": "For convenience, we provide a list of all the parent object constructors in Nemo and explain what domains\nthey represent.     Mathematics  Nemo constructor       R = \\mathbb{Z}   R = ZZ     R = \\mathbb{Q}   R = QQ     R = \\mathbb{F}_{p^n}   R, a = FiniteField(p, n, \"a\")     R = \\mathbb{Z}/n\\mathbb{Z}   R = ResidueRing(ZZ, n)     S = R[x]   S, x = PolynomialRing(R, \"x\")     S = R[x]  (to precision  n )  S, x = PowerSeriesRing(R, n, \"x\")     S = \\mbox{Frac}_R   S = FractionField(R)     S = R/(f)   S = ResidueRing(R, f)     S = \\mbox{Mat}_{m\\times n}(R)   S = MatrixSpace(R, m, n)     S = \\mathbb{Q}[x]/(f)   S, a = NumberField(f, \"a\")     O = \\mathcal{O}_K   S = MaximalOrder(K)    ideal  I  of  O = \\mathcal{O}_K   I = Ideal(O, gens, ...)", 
            "title": "List of parent object constructors"
        }, 
        {
            "location": "/build/polynomial/", 
            "text": "Introduction\n\n\nNemo allow the creation of dense, univariate polynomials over any computable ring \nR\n. There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the polynomial types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenPoly{T}\n\n\nGenPolyRing{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_poly\n\n\nFmpzPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n (small \nn\n)\n\n\nFlint\n\n\nnmod_poly\n\n\nNmodPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n (large \nn\n)\n\n\nFlint\n\n\nfmpz_mod_poly\n\n\nFmpzModPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Q}\n\n\n\n\nFlint\n\n\nfmpq_poly\n\n\nFmpqPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (small \nn\n)\n\n\nFlint\n\n\nfq_nmod_poly\n\n\nFqNmodPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (large \nn\n)\n\n\nFlint\n\n\nfq_poly\n\n\nFqPolyRing\n\n\n\n\n\n\n\n\nThe string representation of the variable and the base ring \nR\n of a generic polynomial is stored in its parent object. \n\n\nAll polynomial element types belong to the abstract type \nPolyElem\n and all of the polynomial ring types belong to the abstract type \nPolyRing\n. This enables one to write generic functions that can accept any Nemo polynomial type.\n\n\n\n\nPolynomial ring constructors\n\n\nIn order to construct polynomials in Nemo, one must first construct the polynomial ring itself. This is accomplished with the following constructor.\n\n\n#\n\n\nNemo.PolynomialRing\n \n \nMethod\n.\n\n\nPolynomialRing(R::Ring, s::AbstractString{}; cached::Bool = true)\n\n\n\n\n\n\nGiven a base ring \nR\n and string \ns\n specifying how the generator (variable) should be printed, return a tuple \nS, x\n representing the new polynomial ring \nS = R[x]\n and the generator \nx\n of the ring. By default the parent object \nS\n will depend only on \nR\n and \nx\n and will be cached. Setting the optional argument \ncached\n to \nfalse\n will prevent the parent object \nS\n from being cached.\n\n\n\n\nsource\n\n\nA shorthand version of this function is provided: given a base ring \nR\n, we abbreviate the constructor as follows.\n\n\nR[\nx\n]\n\n\n\n\nHere are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = QQ[\nz\n]\n\nf = R()\ng = R(123)\nh = S(ZZ(1234))\nk = S(x + 1)\nm = T(z + 1)\n\n\n\n\n\n\nPolynomial element constructors\n\n\nOnce a polynomial ring is constructed, there are various ways to construct polynomials in that ring.\n\n\nThe easiest way is simply using the generator returned by the \nPolynomialRing\n constructor and and build up the polynomial using basic arithmetic. Julia has quite flexible notation for the construction of polynomials in this way.\n\n\nIn addition we provide the following functions for constructing certain useful polynomials.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::PolyRing)\n\n\n\n\n\n\nReturn the zero polynomial in the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::PolyRing)\n\n\n\n\n\n\nReturn the constant polynomial \n1\n in the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gen\n \n \nMethod\n.\n\n\ngen(R::PolyRing)\n\n\n\n\n\n\nReturn the generator of the given polynomial ring.\n\n\n\n\nsource\n\n\nHere are some examples of constructing polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1\n\nh = zero(S)\nk = one(R)\nm = gen(S)\n\n\n\n\n\n\nBasic functionality\n\n\nAll univariate polynomial modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own polynomial module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom univariate polynomial types in Nemo. \n\n\nWe write \nT\n for the type of the polynomials in the polynomial ring.\n\n\nAll of these functions are provided for all existing polynomial types in Nemo.\n\n\nparent_type{T \n: PolyElem}(::Type{T})\n\n\n\n\nGiven the type of polynomial elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::PolyRing)\n\n\n\n\nGiven a parent object for the polynomial ring, return the type of elements of the polynomial ring.\n\n\nBase.hash(a::PolyElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the polynomial \na\n. This should be xor'd with a fixed random hexadecimal specific to the polynomial type. The hash of each coefficient should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\nfit!(a::PolyElem, n::Int)\n\n\n\n\nBy reallocating if necessary, ensure that the given polynomial has space for at least \nn\n coefficients. This function does not change the length of the polynomial and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.\n\n\nnormalise(a::PolyElem, n::Int)\n\n\n\n\nReturn the normalised length of the given polynomial, assuming its current length is \nn\n. Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the polynomial. That can be done with a subsequent call to \nset_length!\n using the length returned by \nnormalise\n.\n\n\nset_length!(a::PolyElem, n::Int)\n\n\n\n\nSet the length of an existing polynomial that has sufficient space allocated, i.e. a polynomial for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial type has a field, \nlength\n, which corresponds to the current length of the polynomial, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.\n\n\nlength(a::PolyElem)\n\n\n\n\nReturn the current length (not the number of allocated coefficients), of the given polynomial. Note that this function only needs to be provided by a developer for a custome polynomial type if the Julia type definition for polynomial elements doesn't contain a field \nlength\n corresponding to the current length of the polynomial. Otherwise the supplied generic implementation will work.\n\n\ncoeff(a::PolyElem, n::Int)\n\n\n\n\nReturn the degree \nn\n coefficient of the given polynomial. Note coefficients are numbered from \nn = 0\n for the constant coefficient. If \nn\n is bigger then the degree of the polynomial, the function returns a zero coefficient. We require \nn \\geq 0\n. \n\n\nsetcoeff!{T \n: RingElem}(a::PolyElem{T}, n::Int, c::T)\n\n\n\n\nSet the coefficient of the degree \nn\n term of the given polynomial to the given value \na\n. The polynomial is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.\n\n\ndeepcopy(a::PolyElem)\n\n\n\n\nConstruct a copy of the given polynomial and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo polynomials are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::PolyElem, a::PolyElem, b::PolyElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing polynomial \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::PolyElem, a::PolyElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a polynomial ring, the following coercion functions are provided to coerce various elements into the polynomial ring. Developers provide these by overloading the \ncall\n operator for the polynomial parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the ring \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the polynomial ring \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(A::Array{T, 1})\n\n\n\n\nTake an array of elements in the base ring, of type \nT\n and construct the polynomial with those coefficients, starting with the constant coefficient.\n\n\nS(f::PolyElem)\n\n\n\n\nTake a polynomial that is already in the ring \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the polynomial ring. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom polynomials must ensure the parent object of a polynomial type constains a field \nbase_ring\n specifying the base ring, a field \nS\n containing a symbol (not a string) representing the variable name of the polynomial ring. They must also ensure that each polynomial element contains a field \nparent\n specifying the parent object of the polynomial.\n\n\nTypically a developer will also overload the \nPolynomialRing\n generic function to create polynomials of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(R::PolyRing)\n\n\n\n\n\n\nReturn the base ring of the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::PolyElem)\n\n\n\n\n\n\nReturn the base ring of the polynomial ring of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::PolyElem)\n\n\n\n\n\n\nReturn the parent of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nBase.var\n \n \nMethod\n.\n\n\nvar(a::PolyRing)\n\n\n\n\n\n\nReturn the internal name of the generator of the polynomial ring. Note that this is returned as a \nSymbol\n not a \nString\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.degree\n \n \nMethod\n.\n\n\ndegree(a::PolyElem)\n\n\n\n\n\n\nReturn the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus{T \n: ResElem}(a::PolyElem{T})\n\n\n\n\n\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lead\n \n \nMethod\n.\n\n\nlead(x::PolyElem)\n\n\n\n\n\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is the constant polynomial \n1\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isgen\n \n \nMethod\n.\n\n\nisgen(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is the constant generator of its polynomial ring, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is a unit in its polynomial ring, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.den\n \n \nMethod\n.\n\n\nden(a::fmpq_poly)\n\n\n\n\n\n\nReturn the least common denominator of the coefficients of the polynomial \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(QQ, \nz\n)\n\na = zero(S)\nb = one(S)\n\nc = ZZ(1)//2*z^2 + ZZ(1)//3\nd = x*y^2 + (x + 1)*y + 3\n\nU = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)\n\nf = lead(d)\n\ng = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo polynomials. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x)\n\n\n\n\nUnary minus operator.\n\n\nsource\n\n\n-(a::PolyElem)\n\n\n\n\n\n\nReturn \n-a\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::PolyElem, b::PolyElem)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\nThe following ad hoc operators are also provided.\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::Integer, b::PolyElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::fmpz, b::PolyElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(x, y...)\n\n\n\n\nAddition operator. \nx+y+z+...\n calls this function with all arguments, i.e. \n+(x, y, z, ...)\n.\n\n\nsource\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+(a::Integer, b::PolyElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+(a::fmpz, b::PolyElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::Integer, b::PolyElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::fmpz, b::PolyElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::Integer, b::PolyElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::fmpz, b::PolyElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\n#\n\n\nBase.^\n \n \nMethod\n.\n\n\n^(x, y)\n\n\n\n\nExponentiation operator.\n\n\nsource\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for polynomials in Nemo.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::PolyElem{T}, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n. Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::PolyElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::T, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \n \nMethod\n.\n\n\nisequal{T \n: RingElem}(x::PolyElem{T}, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n exactly, otherwise return \nfalse\n. This function is useful in cases where the coefficients of the polynomial are inexact, e.g. power series. Only if the power series are precisely the same, to the same precision, are they declared equal by this function.\n\n\n\n\nsource\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::PolyElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::T, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::PolyElem, y::Integer)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::Integer, y::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::PolyElem, y::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::fmpz, y::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of comparisons.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)\n\n\n\n\n\n\nTruncation\n\n\n#\n\n\nBase.truncate\n \n \nMethod\n.\n\n\ntruncate(a::PolyElem, n::Int)\n\n\n\n\n\n\nReturn \na\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.mullow\n \n \nMethod\n.\n\n\nmullow{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T}, n::Int)\n\n\n\n\n\n\nReturn \na\\times b\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\nHere are some examples of truncated operations.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)\n\n\n\n\n\n\nReversal\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(x::PolyElem, len::Int)\n\n\n\n\n\n\nReturn the reverse of the polynomial \nx\n, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length).  The resulting polynomial is normalised. If \nlen\n is negative we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(x::PolyElem)\n\n\n\n\n\n\nReturn the reverse of the polynomial \nx\n, i.e. the leading coefficient of \nx\n becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n\nsource\n\n\nHere are some examples of reversal.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nNemo.shift_left\n \n \nMethod\n.\n\n\nshift_left(x::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted left by \nn\n terms, i.e. multiplied by \nx^n\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.shift_right\n \n \nMethod\n.\n\n\nshift_right(f::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted right by \nn\n terms, i.e. divided by \nx^n\n.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)\n\n\n\n\n\n\nModulo arithmetic\n\n\nFor polynomials over a field or residue ring, we can reduce modulo a given polynomial. This isn't always well-defined in the case of a residue ring, but when it is well-defined, we obtain the correct result. If Nemo encounters an impossible inverse, an exception will be raised.\n\n\n#\n\n\nNemo.mulmod\n \n \nMethod\n.\n\n\nmulmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T}, d::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b \\pmod{d}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::Int, d::PolyElem{T})\n\n\n\n\n\n\nReturn \na^b \\pmod{d}\n. There are no restrictions on \nb\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \nx^e \\pmod{y}\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.invmod\n \n \nMethod\n.\n\n\ninvmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na^{-1} \\pmod{d}\n.\n\n\n\n\nsource\n\n\nHere are some examples of modular arithmetic.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S, \ny\n)\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)\n\n\n\n\n\n\nEuclidean division\n\n\nFor polynomials over a field, we have a euclidean domain, and in many cases for polynomials over a residue ring things behave as though we had a euclidean domain so long as we don't hit an impossible inverse. For such rings we define euclidean division of polynomials. If an impossible inverse is hit, we raise an exception.\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod{T \n: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn \nf \\pmod{g}\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.divrem\n \n \nMethod\n.\n\n\ndivrem{T \n: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(q, r)\n such that \nf = qg + r\n where \nq\n is the euclidean quotient of \nf\n by \ng\n.\n\n\n\n\nsource\n\n\nHere are some examples of euclidean division.\n\n\nR = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T, \ny\n)\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)\n\n\n\n\n\n\nPseudodivision\n\n\nGiven two polynomials \na, b\n, pseudodivision computes polynomials \nq\n and \nr\n with length\n(r) <\n length\n(b)\n such that \nL^d a = bq + r,\n where \nd =\n length\n(a) -\n length\n(b) + 1\n and \nL\n is the leading coefficient of \nb\n.\n\n\nWe call \nq\n the pseudoquotient and \nr\n the pseudoremainder.\n\n\n#\n\n\nNemo.pseudorem\n \n \nMethod\n.\n\n\npseudorem{T \n: RingElem}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn the pseudoremainder of \na\n divided by \nb\n. If \nb = 0\n we throw a  \nDivideError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.pseudodivrem\n \n \nMethod\n.\n\n\npseudodivrem{T \n: RingElem}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(q, r)\n consisting of the pseudoquotient and pseudoremainder  of \na\n divided by \nb\n. If \nb = 0\n we throw a \nDivideError()\n.\n\n\n\n\nsource\n\n\nHere are some examples of pseudodivision.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)\n\n\n\n\n\n\nContent, primitive part, GCD and LCM\n\n\nIn Nemo, we allow computation of the greatest common divisor of polynomials over any ring. This is enabled by making use of pseudoremainders when we aren't working over a euclidean domain or something mimicking such a domain. In certain cases this allows us to return a greatest common divisor when it otherwise wouldn't be possible. However, a greatest common divisor is not necessarily unique, or even well-defined.\n\n\nIf an impossible inverse is encountered whilst computing the greatest common divisor, an exception is thrown.\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a greatest common divisor of \na\n and \nb\n if it exists.\n\n\n\n\nsource\n\n\n#\n\n\nBase.lcm\n \n \nMethod\n.\n\n\nlcm{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a least common multiple of \na\n and \nb\n if it exists.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.content\n \n \nMethod\n.\n\n\ncontent(a::PolyElem)\n\n\n\n\n\n\nReturn the content of \na\n, i.e. the greatest common divisor of its coefficients.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.primpart\n \n \nMethod\n.\n\n\nprimpart(a::PolyElem)\n\n\n\n\n\n\nReturn the primitive part of \na\n, i.e. the polynomial divided by its content.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcdx\n \n \nMethod\n.\n\n\ngcdx{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(r, s, t)\n such that \nr\n is the resultant of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcdx\n \n \nMethod\n.\n\n\ngcdx{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(r, s, t)\n such that \nr\n is the resultant of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\ngcdx{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(g, s, t)\n such that \ng\n is the greatest common divisor of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gcdinv\n \n \nMethod\n.\n\n\ngcdinv{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(g, s)\n such that \ng\n is the greatest common divisor of \na\n and \nb\n and such that \ns = a^{-1} \\pmod{b}\n. This function is useful for inverting modulo a polynomial and checking that it really was invertible.\n\n\n\n\nsource\n\n\nHere are some examples of content, primitive part and GCD.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nk = x*y^2 + (x + 1)*y + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1\n\nn = content(k)\np = primpart(k*(x^2 + 1))\nq = gcd(k*m, l*m)\nr = lcm(k*m, l*m)\n\nR, x = PolynomialRing(QQ, \nx\n)\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T, \nz\n)\n\ng = z^3 + 2z + 1\nh = z^5 + 1\n\nr, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)\n\n\n\n\n\n\nEvaluation, composition and substitution\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate(a::PolyElem, b::Integer)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.compose\n \n \nMethod\n.\n\n\ncompose(a::PolyElem, b::PolyElem)\n\n\n\n\n\n\nCompose the polynomial \na\n with the polynomial \nb\n and return the result, i.e. return \na\\circ b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.subst\n \n \nMethod\n.\n\n\nsubst{T \n: RingElem}(f::PolyElem{T}, a::Any)\n\n\n\n\n\n\nEvaluate the polynomial \nf\n at \na\n. Note that \na\n can be anything, whether a ring element or not.\n\n\n\n\nsource\n\n\nWe also overload the functional notation so that the polynomial \nf\n can be evaluated at \na\n by writing \nf(a)\n. This feature is only available with  Julia 0.5 however.\n\n\nHere are some examples of polynomial evaluation, composition and substitution.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nM = R[x + 1 2x; x - 3 2x - 1]\n\nh = evaluate(f, 3)\nk = evaluate(f, x^2 + 2x + 1)\nm = compose(f, g)\nn = subst(f, M)\np = f(M)\nk = f(23)\n\n\n\n\n\n\nDerivative and integral\n\n\n#\n\n\nNemo.derivative\n \n \nMethod\n.\n\n\nderivative(a::PolyElem)\n\n\n\n\n\n\nReturn the derivative of the polynomial \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.integral\n \n \nMethod\n.\n\n\nintegral{T \n: Union{ResElem, FieldElem}}(x::PolyElem{T})\n\n\n\n\n\n\nReturn the integral of the polynomial \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of integral and derivative.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(QQ, \nz\n)\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U, \nw\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)   \n\n\n\n\n\n\nResultant and discriminant\n\n\n#\n\n\nNemo.resultant\n \n \nMethod\n.\n\n\nresultant{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn the resultant of the \na\n and \nb\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.discriminant\n \n \nMethod\n.\n\n\ndiscriminant(a::PolyElem)\n\n\n\n\n\n\nReturn the discrimnant of the given polynomial.\n\n\n\n\nsource\n\n\nHere are some examples of computing the resultant and discriminant.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)\n\n\n\n\n\n\nNewton representation\n\n\n#\n\n\nNemo.monomial_to_newton!\n \n \nMethod\n.\n\n\nmonomial_to_newton!{T \n: RingElem}(P::Array{T, 1}, roots::Array{T, 1})\n\n\n\n\n\n\nConverts a polynomial \np\n, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots \nr_0, r_1, \\ldots, r_{n-2}\n. In other words, this determines output coefficients \nc_i\n such that \nc_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})\n is equal to the input polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.newton_to_monomial!\n \n \nMethod\n.\n\n\nnewton_to_monomial!{T \n: RingElem}(P::Array{T, 1}, roots::Array{T, 1})\n\n\n\n\n\n\nConverts a polynomial \np\n, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots \nr_0, r_1, \\ldots, r_{n-2}\n to the standard monomial basis. In other words, this evaluates \nc_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})\n where \nc_i\n are the input coefficients given by \np\n.\n\n\n\n\nsource\n\n\nHere are some examples of conversion to and from Newton representation.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)\n\n\n\n\n\n\nInterpolation\n\n\n#\n\n\nNemo.interpolate\n \n \nMethod\n.\n\n\ninterpolate{T \n: RingElem}(S::PolyRing, x::Array{T, 1}, y::Array{T, 1})\n\n\n\n\n\n\nGiven two arrays of values \nxs\n and \nys\n of the same length \nn\n, find the polynomial \nf\n in the polynomial ring \nR\n of length at most \nn\n such that \nf\n has the value \nys\n at the points \nxs\n. The values in the arrays \nxs\n and \nys\n must belong to the base ring of the polynomial ring \nR\n.\n\n\n\n\nsource\n\n\nHere is an example of interpolation.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nxs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]\n\nf = interpolate(S, xs, ys)\n\n\n\n\n\n\nSignature\n\n\nSignature is only available for certain coefficient rings.\n\n\n#\n\n\nNemo.signature\n \n \nMethod\n.\n\n\nsignature(f::fmpz_poly)\n\n\n\n\n\n\nReturn the signature of the polynomial \nf\n, i.e. a tuple \n(r, s)\n such that \nr\n is the number of real roots of \nf\n and \ns\n is half the number of complex roots.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.signature\n \n \nMethod\n.\n\n\nsignature(f::fmpq_poly)\n\n\n\n\n\n\nReturn the signature of \nf\n, i.e. a tuple \n(r, s)\n where \nr\n is the number of real roots of \nf\n and \ns\n is half the number of complex roots.\n\n\n\n\nsource\n\n\nHere is an example of signature.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)\n\n\n\n\n\n\nLifting\n\n\nWhen working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from \n\\mathbb{Z}/n\\mathbb{Z}\n to \n\\mathbb{Z}\n.\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nfunction lift(R::FmpzPolyRing, y::nmod_poly)\n\n\n\n\n\n\nLift from a polynomial over \n\\mathbb{Z}/n\\mathbb{Z}\n to a polynomial over \n\\mathbb{Z}\n with minimal reduced nonnegative coefficients. The ring \nR\n specifies the ring to lift into.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nfunction lift(R::FmpzPolyRing, y::fmpz_mod_poly)\n\n\n\n\n\n\nLift from a polynomial over \n\\mathbb{Z}/n\\mathbb{Z}\n to a polynomial over \n\\mathbb{Z}\n with minimal reduced nonnegative coefficients. The ring \nR\n specifies the ring to lift into.\n\n\n\n\nsource\n\n\nHere is an example of lifting.\n\n\nR = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R, \nx\n)\nT, y = PolynomialRing(ZZ, \ny\n)\n\nf = x^2 + 2x + 1\n\na = lift(T, f)\n\n\n\n\n\n\nFactorisation\n\n\nPolynomials can only be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.\n\n\n#\n\n\nNemo.isirreducible\n \n \nMethod\n.\n\n\nisirreducible(x::nmod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is irreducible, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isirreducible\n \n \nMethod\n.\n\n\nisirreducible(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is irreducible, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issquarefree\n \n \nMethod\n.\n\n\nissquarefree(x::nmod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is squarefree, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issquarefree\n \n \nMethod\n.\n\n\nissquarefree(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is squarefree, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.factor\n \n \nMethod\n.\n\n\nfactor(x::nmod_poly)\n\n\n\n\n\n\nReturn the factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.factor\n \n \nMethod\n.\n\n\nfactor(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_squarefree\n \n \nMethod\n.\n\n\nfactor_squarefree(x::nmod_poly)\n\n\n\n\n\n\nReturn the squarefree factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_squarefree\n \n \nMethod\n.\n\n\nfactor_squarefree(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the squarefree factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_distinct_deg\n \n \nMethod\n.\n\n\nfactor_distinct_deg(x::nmod_poly)\n\n\n\n\n\n\nReturn the distinct degree factorisation of a squarefree polynomial \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_distinct_deg\n \n \nMethod\n.\n\n\nfactor_distinct_deg(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the distinct degree factorisation of a squarefree polynomial \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of factorisation.\n\n\nR = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R, \nx\n)\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))\n\n\n\n\n\n\nSpecial functions\n\n\nThe following special functions can be computed for any polynomial ring. Typically one uses the generator \nx\n of a polynomial ring to get the respective special polynomials expressed in terms of that generator.\n\n\n#\n\n\nNemo.chebyshev_t\n \n \nMethod\n.\n\n\nchebyshev_t(n::Int, x::PolyElem)\n\n\n\n\n\n\nReturn the Chebyshev polynomial of the first kind \nT_n(x)\n, defined by  \nT_n(x) = \\cos(n \\cos^{-1}(x))\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chebyshev_u\n \n \nMethod\n.\n\n\nchebyshev_u(n::Int, x::PolyElem)\n\n\n\n\n\n\nReturn the Chebyshev polynomial of the first kind \nU_n(x)\n, defined by  \n(n+1) U_n(x) = T'_{n+1}(x)\n.\n\n\n\n\nsource\n\n\nThe following special polynomials are only available for certain base rings.\n\n\n#\n\n\nNemo.cyclotomic\n \n \nMethod\n.\n\n\ncyclotomic(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nn\nth cyclotomic polynomial, defined as \n\\Phi_n(x) = \\prod_{\\omega} (x-\\omega),\n where \n\\omega\n runs over all the  \nn\nth primitive roots of unity.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.swinnerton_dyer\n \n \nMethod\n.\n\n\nswinnerton_dyer(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the Swinnerton-Dyer polynomial \nS_n\n, defined as the integer  polynomial \nS_n = \\prod (x \\pm \\sqrt{2} \\pm \\sqrt{3} \\pm \\sqrt{5} \\pm \\ldots \\pm \\sqrt{p_n})\n  where \np_n\n denotes the \nn\n-th prime number and all combinations of signs are taken. This polynomial has degree \n2^n\n and is irreducible over the integers (it is the minimal polynomial of \n\\sqrt{2} + \\ldots + \\sqrt{p_n}\n).\n\n\n\n\nsource\n\n\n#\n\n\nNemo.cos_minpoly\n \n \nMethod\n.\n\n\ncos_minpoly(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the minimal polynomial of \n2 \\cos(2 \\pi / n)\n. For suitable choice of  \nn\n, this gives the minimal polynomial of \n2 \\cos(a \\pi)\n or \n2 \\sin(a \\pi)\n for any rational \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.theta_qexp\n \n \nMethod\n.\n\n\ntheta_qexp(e::Int, n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nq\n-expansion to length \nn\n of the Jacobi theta function raised to the power \nr\n, i.e. \n\\vartheta(q)^r\n where  \n\\vartheta(q) = 1 + \\sum_{k=1}^{\\infty} q^{k^2}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.eta_qexp\n \n \nMethod\n.\n\n\neta_qexp(e::Int, n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nq\n-expansion to length \nn\n of the Dedekind eta function (without  the leading factor \nq^{1/24}\n) raised to the power \nr\n, i.e. \n(q^{-1/24} \\eta(q))^r = \\prod_{k=1}^{\\infty} (1 - q^k)^r\n. In particular, \nr = -1\n gives the generating function of the partition function \np(k)\n, and \nr = 24\n gives, after multiplication by \nq\n, the modular discriminant \n\\Delta(q)\n which generates the Ramanujan tau function \n\\tau(k)\n.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Univariate polynomials"
        }, 
        {
            "location": "/build/polynomial/#introduction", 
            "text": "Nemo allow the creation of dense, univariate polynomials over any computable ring  R . There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.  The following table shows each of the polynomial types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenPoly{T}  GenPolyRing{T}     \\mathbb{Z}   Flint  fmpz_poly  FmpzPolyRing     \\mathbb{Z}/n\\mathbb{Z}  (small  n )  Flint  nmod_poly  NmodPolyRing     \\mathbb{Z}/n\\mathbb{Z}  (large  n )  Flint  fmpz_mod_poly  FmpzModPolyRing     \\mathbb{Q}   Flint  fmpq_poly  FmpqPolyRing     \\mathbb{F}_{p^n}  (small  n )  Flint  fq_nmod_poly  FqNmodPolyRing     \\mathbb{F}_{p^n}  (large  n )  Flint  fq_poly  FqPolyRing     The string representation of the variable and the base ring  R  of a generic polynomial is stored in its parent object.   All polynomial element types belong to the abstract type  PolyElem  and all of the polynomial ring types belong to the abstract type  PolyRing . This enables one to write generic functions that can accept any Nemo polynomial type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/build/polynomial/#polynomial-ring-constructors", 
            "text": "In order to construct polynomials in Nemo, one must first construct the polynomial ring itself. This is accomplished with the following constructor.  #  Nemo.PolynomialRing     Method .  PolynomialRing(R::Ring, s::AbstractString{}; cached::Bool = true)   Given a base ring  R  and string  s  specifying how the generator (variable) should be printed, return a tuple  S, x  representing the new polynomial ring  S = R[x]  and the generator  x  of the ring. By default the parent object  S  will depend only on  R  and  x  and will be cached. Setting the optional argument  cached  to  false  will prevent the parent object  S  from being cached.   source  A shorthand version of this function is provided: given a base ring  R , we abbreviate the constructor as follows.  R[ x ]  Here are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = QQ[ z ]\n\nf = R()\ng = R(123)\nh = S(ZZ(1234))\nk = S(x + 1)\nm = T(z + 1)", 
            "title": "Polynomial ring constructors"
        }, 
        {
            "location": "/build/polynomial/#polynomial-element-constructors", 
            "text": "Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.  The easiest way is simply using the generator returned by the  PolynomialRing  constructor and and build up the polynomial using basic arithmetic. Julia has quite flexible notation for the construction of polynomials in this way.  In addition we provide the following functions for constructing certain useful polynomials.  #  Base.zero     Method .  zero(R::PolyRing)   Return the zero polynomial in the given polynomial ring.   source  #  Base.one     Method .  one(R::PolyRing)   Return the constant polynomial  1  in the given polynomial ring.   source  #  Nemo.gen     Method .  gen(R::PolyRing)   Return the generator of the given polynomial ring.   source  Here are some examples of constructing polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1\n\nh = zero(S)\nk = one(R)\nm = gen(S)", 
            "title": "Polynomial element constructors"
        }, 
        {
            "location": "/build/polynomial/#basic-functionality", 
            "text": "All univariate polynomial modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own polynomial module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom univariate polynomial types in Nemo.   We write  T  for the type of the polynomials in the polynomial ring.  All of these functions are provided for all existing polynomial types in Nemo.  parent_type{T  : PolyElem}(::Type{T})  Given the type of polynomial elements, should return the type of the corresponding parent object.  elem_type(R::PolyRing)  Given a parent object for the polynomial ring, return the type of elements of the polynomial ring.  Base.hash(a::PolyElem, h::UInt)  Return a  UInt  hexadecimal hash of the polynomial  a . This should be xor'd with a fixed random hexadecimal specific to the polynomial type. The hash of each coefficient should be xor'd with the supplied parameter  h  as part of computing the hash.  fit!(a::PolyElem, n::Int)  By reallocating if necessary, ensure that the given polynomial has space for at least  n  coefficients. This function does not change the length of the polynomial and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.  normalise(a::PolyElem, n::Int)  Return the normalised length of the given polynomial, assuming its current length is  n . Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the polynomial. That can be done with a subsequent call to  set_length!  using the length returned by  normalise .  set_length!(a::PolyElem, n::Int)  Set the length of an existing polynomial that has sufficient space allocated, i.e. a polynomial for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial type has a field,  length , which corresponds to the current length of the polynomial, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.  length(a::PolyElem)  Return the current length (not the number of allocated coefficients), of the given polynomial. Note that this function only needs to be provided by a developer for a custome polynomial type if the Julia type definition for polynomial elements doesn't contain a field  length  corresponding to the current length of the polynomial. Otherwise the supplied generic implementation will work.  coeff(a::PolyElem, n::Int)  Return the degree  n  coefficient of the given polynomial. Note coefficients are numbered from  n = 0  for the constant coefficient. If  n  is bigger then the degree of the polynomial, the function returns a zero coefficient. We require  n \\geq 0 .   setcoeff!{T  : RingElem}(a::PolyElem{T}, n::Int, c::T)  Set the coefficient of the degree  n  term of the given polynomial to the given value  a . The polynomial is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.  deepcopy(a::PolyElem)  Construct a copy of the given polynomial and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo polynomials are mutable and so returning shallow copies is not sufficient.  mul!(c::PolyElem, a::PolyElem, b::PolyElem)  Multiply  a  by  b  and set the existing polynomial  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::PolyElem, a::PolyElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a polynomial ring, the following coercion functions are provided to coerce various elements into the polynomial ring. Developers provide these by overloading the  call  operator for the polynomial parent objects.  S()  Coerce zero into the ring  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the polynomial ring  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(A::Array{T, 1})  Take an array of elements in the base ring, of type  T  and construct the polynomial with those coefficients, starting with the constant coefficient.  S(f::PolyElem)  Take a polynomial that is already in the ring  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the polynomial ring. This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom polynomials must ensure the parent object of a polynomial type constains a field  base_ring  specifying the base ring, a field  S  containing a symbol (not a string) representing the variable name of the polynomial ring. They must also ensure that each polynomial element contains a field  parent  specifying the parent object of the polynomial.  Typically a developer will also overload the  PolynomialRing  generic function to create polynomials of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/build/polynomial/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(R::PolyRing)   Return the base ring of the given polynomial ring.   source  #  Nemo.base_ring     Method .  base_ring(a::PolyElem)   Return the base ring of the polynomial ring of the given polynomial.   source  #  Base.parent     Method .  parent(a::PolyElem)   Return the parent of the given polynomial.   source  #  Base.var     Method .  var(a::PolyRing)   Return the internal name of the generator of the polynomial ring. Note that this is returned as a  Symbol  not a  String .   source  #  Nemo.degree     Method .  degree(a::PolyElem)   Return the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.   source  #  Nemo.modulus     Method .  modulus{T  : ResElem}(a::PolyElem{T})   Return the modulus of the coefficients of the given polynomial.   source  #  Nemo.lead     Method .  lead(x::PolyElem)   Return the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.   source  #  Nemo.iszero     Method .  iszero(a::PolyElem)   Return  true  if the given polynomial is zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::PolyElem)   Return  true  if the given polynomial is the constant polynomial  1 , otherwise return  false .   source  #  Nemo.isgen     Method .  isgen(a::PolyElem)   Return  true  if the given polynomial is the constant generator of its polynomial ring, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::PolyElem)   Return  true  if the given polynomial is a unit in its polynomial ring, otherwise return  false .   source  #  Base.den     Method .  den(a::fmpq_poly)   Return the least common denominator of the coefficients of the polynomial  a .   source  Here are some examples of basic manipulation of polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(QQ,  z )\n\na = zero(S)\nb = one(S)\n\nc = ZZ(1)//2*z^2 + ZZ(1)//3\nd = x*y^2 + (x + 1)*y + 3\n\nU = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)\n\nf = lead(d)\n\ng = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/build/polynomial/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo polynomials. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  #  Base.-     Method .  -(x)  Unary minus operator.  source  -(a::PolyElem)   Return  -a .   source  #  Base.+     Method .  +{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a + b .   source  +{T  : RingElem}(a::T, b::PolyElem{T})   Return  a + b .   source  +{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a - b .   source  -{T  : RingElem}(a::T, b::PolyElem{T})   Return  a - b .   source  -{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::T, b::PolyElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact(a::PolyElem, b::PolyElem)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  divexact(a::PolyElem, b::Integer)   Return  a/b  where the quotient is expected to be exact.   source  divexact(a::PolyElem, b::fmpz)   Return  a/b  where the quotient is expected to be exact.   source  The following ad hoc operators are also provided.  #  Base.+     Method .  +(a::Integer, b::PolyElem)   Return  a + b .   source  #  Base.+     Method .  +(a::PolyElem, b::Integer)   Return  a + b .   source  #  Base.+     Method .  +(a::fmpz, b::PolyElem)   Return  a + b .   source  #  Base.+     Method .  +(a::PolyElem, b::fmpz)   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::T, b::PolyElem{T})   Return  a + b .   source  #  Base.+     Method .  +(x, y...)  Addition operator.  x+y+z+...  calls this function with all arguments, i.e.  +(x, y, z, ...) .  source  +{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a + b .   source  +{T  : RingElem}(a::T, b::PolyElem{T})   Return  a + b .   source  +(a::Integer, b::PolyElem)   Return  a + b .   source  +(a::fmpz, b::PolyElem)   Return  a + b .   source  +{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a + b .   source  +(a::PolyElem, b::Integer)   Return  a + b .   source  +(a::PolyElem, b::fmpz)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::Integer, b::PolyElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::PolyElem, b::Integer)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::fmpz, b::PolyElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::PolyElem, b::fmpz)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::T, b::PolyElem{T})   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::Integer, b::PolyElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::PolyElem, b::Integer)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::fmpz, b::PolyElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::PolyElem, b::fmpz)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::T, b::PolyElem{T})   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  #  Nemo.divexact     Method .  divexact(a::PolyElem, b::Integer)   Return  a/b  where the quotient is expected to be exact.   source  #  Nemo.divexact     Method .  divexact(a::PolyElem, b::fmpz)   Return  a/b  where the quotient is expected to be exact.   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  #  Base.^     Method .  ^(x, y)  Exponentiation operator.  source  If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/build/polynomial/#comparison-operators", 
            "text": "The following comparison operators are implemented for polynomials in Nemo.  #  Base.==     Method .  =={T  : RingElem}(x::PolyElem{T}, y::PolyElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false . Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.   source  =={T  : RingElem}(x::PolyElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  =={T  : RingElem}(x::T, y::PolyElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.isequal     Method .  isequal{T  : RingElem}(x::PolyElem{T}, y::PolyElem{T})   Return  true  if  x == y  exactly, otherwise return  false . This function is useful in cases where the coefficients of the polynomial are inexact, e.g. power series. Only if the power series are precisely the same, to the same precision, are they declared equal by this function.   source  In addition we have the following ad hoc comparison operators.  #  Base.==     Method .  =={T  : RingElem}(x::PolyElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  =={T  : RingElem}(x::T, y::PolyElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::PolyElem, y::Integer)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::Integer, y::PolyElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::PolyElem, y::fmpz)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::fmpz, y::PolyElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  Here are some examples of comparisons.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/build/polynomial/#truncation", 
            "text": "#  Base.truncate     Method .  truncate(a::PolyElem, n::Int)   Return  a  truncated to  n  terms.   source  #  Nemo.mullow     Method .  mullow{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T}, n::Int)   Return  a\\times b  truncated to  n  terms.   source  Here are some examples of truncated operations.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)", 
            "title": "Truncation"
        }, 
        {
            "location": "/build/polynomial/#reversal", 
            "text": "#  Base.reverse     Method .  reverse(x::PolyElem, len::Int)   Return the reverse of the polynomial  x , thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length).  The resulting polynomial is normalised. If  len  is negative we throw a  DomainError() .   source  #  Base.reverse     Method .  reverse(x::PolyElem)   Return the reverse of the polynomial  x , i.e. the leading coefficient of  x  becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.   source  Here are some examples of reversal.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)", 
            "title": "Reversal"
        }, 
        {
            "location": "/build/polynomial/#shifting", 
            "text": "#  Nemo.shift_left     Method .  shift_left(x::PolyElem, n::Int)   Return the polynomial  f  shifted left by  n  terms, i.e. multiplied by  x^n .   source  #  Nemo.shift_right     Method .  shift_right(f::PolyElem, n::Int)   Return the polynomial  f  shifted right by  n  terms, i.e. divided by  x^n .   source  Here are some examples of shifting.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)", 
            "title": "Shifting"
        }, 
        {
            "location": "/build/polynomial/#modulo-arithmetic", 
            "text": "For polynomials over a field or residue ring, we can reduce modulo a given polynomial. This isn't always well-defined in the case of a residue ring, but when it is well-defined, we obtain the correct result. If Nemo encounters an impossible inverse, an exception will be raised.  #  Nemo.mulmod     Method .  mulmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T}, d::PolyElem{T})   Return  a\\times b \\pmod{d} .   source  #  Nemo.powmod     Method .  powmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::Int, d::PolyElem{T})   Return  a^b \\pmod{d} . There are no restrictions on  b .   source  #  Nemo.powmod     Method .  powmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)   Return  x^e \\pmod{y} .   source  #  Base.invmod     Method .  invmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return  a^{-1} \\pmod{d} .   source  Here are some examples of modular arithmetic.  R, x = PolynomialRing(QQ,  x )\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S,  y )\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)", 
            "title": "Modulo arithmetic"
        }, 
        {
            "location": "/build/polynomial/#euclidean-division", 
            "text": "For polynomials over a field, we have a euclidean domain, and in many cases for polynomials over a residue ring things behave as though we had a euclidean domain so long as we don't hit an impossible inverse. For such rings we define euclidean division of polynomials. If an impossible inverse is hit, we raise an exception.  #  Base.mod     Method .  mod{T  : Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})   Return  f \\pmod{g} .   source  #  Base.divrem     Method .  divrem{T  : Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})   Return a tuple  (q, r)  such that  f = qg + r  where  q  is the euclidean quotient of  f  by  g .   source  Here are some examples of euclidean division.  R = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T,  y )\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)", 
            "title": "Euclidean division"
        }, 
        {
            "location": "/build/polynomial/#pseudodivision", 
            "text": "Given two polynomials  a, b , pseudodivision computes polynomials  q  and  r  with length (r) <  length (b)  such that  L^d a = bq + r,  where  d =  length (a) -  length (b) + 1  and  L  is the leading coefficient of  b .  We call  q  the pseudoquotient and  r  the pseudoremainder.  #  Nemo.pseudorem     Method .  pseudorem{T  : RingElem}(f::PolyElem{T}, g::PolyElem{T})   Return the pseudoremainder of  a  divided by  b . If  b = 0  we throw a   DivideError() .   source  #  Nemo.pseudodivrem     Method .  pseudodivrem{T  : RingElem}(f::PolyElem{T}, g::PolyElem{T})   Return a tuple  (q, r)  consisting of the pseudoquotient and pseudoremainder  of  a  divided by  b . If  b = 0  we throw a  DivideError() .   source  Here are some examples of pseudodivision.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)", 
            "title": "Pseudodivision"
        }, 
        {
            "location": "/build/polynomial/#content-primitive-part-gcd-and-lcm", 
            "text": "In Nemo, we allow computation of the greatest common divisor of polynomials over any ring. This is enabled by making use of pseudoremainders when we aren't working over a euclidean domain or something mimicking such a domain. In certain cases this allows us to return a greatest common divisor when it otherwise wouldn't be possible. However, a greatest common divisor is not necessarily unique, or even well-defined.  If an impossible inverse is encountered whilst computing the greatest common divisor, an exception is thrown.  #  Base.gcd     Method .  gcd{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a greatest common divisor of  a  and  b  if it exists.   source  #  Base.lcm     Method .  lcm{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a least common multiple of  a  and  b  if it exists.   source  #  Nemo.content     Method .  content(a::PolyElem)   Return the content of  a , i.e. the greatest common divisor of its coefficients.   source  #  Nemo.primpart     Method .  primpart(a::PolyElem)   Return the primitive part of  a , i.e. the polynomial divided by its content.   source  #  Base.gcdx     Method .  gcdx{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (r, s, t)  such that  r  is the resultant of  a  and  b  and such that  r = a\\times s + b\\times t .   source  #  Base.gcdx     Method .  gcdx{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (r, s, t)  such that  r  is the resultant of  a  and  b  and such that  r = a\\times s + b\\times t .   source  gcdx{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (g, s, t)  such that  g  is the greatest common divisor of  a  and  b  and such that  r = a\\times s + b\\times t .   source  #  Nemo.gcdinv     Method .  gcdinv{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (g, s)  such that  g  is the greatest common divisor of  a  and  b  and such that  s = a^{-1} \\pmod{b} . This function is useful for inverting modulo a polynomial and checking that it really was invertible.   source  Here are some examples of content, primitive part and GCD.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nk = x*y^2 + (x + 1)*y + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1\n\nn = content(k)\np = primpart(k*(x^2 + 1))\nq = gcd(k*m, l*m)\nr = lcm(k*m, l*m)\n\nR, x = PolynomialRing(QQ,  x )\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T,  z )\n\ng = z^3 + 2z + 1\nh = z^5 + 1\n\nr, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)", 
            "title": "Content, primitive part, GCD and LCM"
        }, 
        {
            "location": "/build/polynomial/#evaluation-composition-and-substitution", 
            "text": "#  Nemo.evaluate     Method .  evaluate{T  : RingElem}(a::PolyElem{T}, b::T)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.evaluate     Method .  evaluate(a::PolyElem, b::Integer)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.evaluate     Method .  evaluate(a::PolyElem, b::fmpz)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.compose     Method .  compose(a::PolyElem, b::PolyElem)   Compose the polynomial  a  with the polynomial  b  and return the result, i.e. return  a\\circ b .   source  #  Nemo.subst     Method .  subst{T  : RingElem}(f::PolyElem{T}, a::Any)   Evaluate the polynomial  f  at  a . Note that  a  can be anything, whether a ring element or not.   source  We also overload the functional notation so that the polynomial  f  can be evaluated at  a  by writing  f(a) . This feature is only available with  Julia 0.5 however.  Here are some examples of polynomial evaluation, composition and substitution.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nM = R[x + 1 2x; x - 3 2x - 1]\n\nh = evaluate(f, 3)\nk = evaluate(f, x^2 + 2x + 1)\nm = compose(f, g)\nn = subst(f, M)\np = f(M)\nk = f(23)", 
            "title": "Evaluation, composition and substitution"
        }, 
        {
            "location": "/build/polynomial/#derivative-and-integral", 
            "text": "#  Nemo.derivative     Method .  derivative(a::PolyElem)   Return the derivative of the polynomial  a .   source  #  Nemo.integral     Method .  integral{T  : Union{ResElem, FieldElem}}(x::PolyElem{T})   Return the integral of the polynomial  a .   source  Here are some examples of integral and derivative.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(QQ,  z )\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U,  w )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)", 
            "title": "Derivative and integral"
        }, 
        {
            "location": "/build/polynomial/#resultant-and-discriminant", 
            "text": "#  Nemo.resultant     Method .  resultant{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return the resultant of the  a  and  b .   source  #  Nemo.discriminant     Method .  discriminant(a::PolyElem)   Return the discrimnant of the given polynomial.   source  Here are some examples of computing the resultant and discriminant.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)", 
            "title": "Resultant and discriminant"
        }, 
        {
            "location": "/build/polynomial/#newton-representation", 
            "text": "#  Nemo.monomial_to_newton!     Method .  monomial_to_newton!{T  : RingElem}(P::Array{T, 1}, roots::Array{T, 1})   Converts a polynomial  p , given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots  r_0, r_1, \\ldots, r_{n-2} . In other words, this determines output coefficients  c_i  such that  c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})  is equal to the input polynomial.   source  #  Nemo.newton_to_monomial!     Method .  newton_to_monomial!{T  : RingElem}(P::Array{T, 1}, roots::Array{T, 1})   Converts a polynomial  p , given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots  r_0, r_1, \\ldots, r_{n-2}  to the standard monomial basis. In other words, this evaluates  c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})  where  c_i  are the input coefficients given by  p .   source  Here are some examples of conversion to and from Newton representation.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)", 
            "title": "Newton representation"
        }, 
        {
            "location": "/build/polynomial/#interpolation", 
            "text": "#  Nemo.interpolate     Method .  interpolate{T  : RingElem}(S::PolyRing, x::Array{T, 1}, y::Array{T, 1})   Given two arrays of values  xs  and  ys  of the same length  n , find the polynomial  f  in the polynomial ring  R  of length at most  n  such that  f  has the value  ys  at the points  xs . The values in the arrays  xs  and  ys  must belong to the base ring of the polynomial ring  R .   source  Here is an example of interpolation.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nxs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]\n\nf = interpolate(S, xs, ys)", 
            "title": "Interpolation"
        }, 
        {
            "location": "/build/polynomial/#signature", 
            "text": "Signature is only available for certain coefficient rings.  #  Nemo.signature     Method .  signature(f::fmpz_poly)   Return the signature of the polynomial  f , i.e. a tuple  (r, s)  such that  r  is the number of real roots of  f  and  s  is half the number of complex roots.   source  #  Nemo.signature     Method .  signature(f::fmpq_poly)   Return the signature of  f , i.e. a tuple  (r, s)  where  r  is the number of real roots of  f  and  s  is half the number of complex roots.   source  Here is an example of signature.  R, x = PolynomialRing(ZZ,  x )\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)", 
            "title": "Signature"
        }, 
        {
            "location": "/build/polynomial/#lifting", 
            "text": "When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from  \\mathbb{Z}/n\\mathbb{Z}  to  \\mathbb{Z} .  #  Nemo.lift     Method .  function lift(R::FmpzPolyRing, y::nmod_poly)   Lift from a polynomial over  \\mathbb{Z}/n\\mathbb{Z}  to a polynomial over  \\mathbb{Z}  with minimal reduced nonnegative coefficients. The ring  R  specifies the ring to lift into.   source  #  Nemo.lift     Method .  function lift(R::FmpzPolyRing, y::fmpz_mod_poly)   Lift from a polynomial over  \\mathbb{Z}/n\\mathbb{Z}  to a polynomial over  \\mathbb{Z}  with minimal reduced nonnegative coefficients. The ring  R  specifies the ring to lift into.   source  Here is an example of lifting.  R = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R,  x )\nT, y = PolynomialRing(ZZ,  y )\n\nf = x^2 + 2x + 1\n\na = lift(T, f)", 
            "title": "Lifting"
        }, 
        {
            "location": "/build/polynomial/#factorisation", 
            "text": "Polynomials can only be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.  #  Nemo.isirreducible     Method .  isirreducible(x::nmod_poly)   Return  true  if  x  is irreducible, otherwise return  false .   source  #  Nemo.isirreducible     Method .  isirreducible(x::fmpz_mod_poly)   Return  true  if  x  is irreducible, otherwise return  false .   source  #  Nemo.issquarefree     Method .  issquarefree(x::nmod_poly)   Return  true  if  x  is squarefree, otherwise return  false .   source  #  Nemo.issquarefree     Method .  issquarefree(x::fmpz_mod_poly)   Return  true  if  x  is squarefree, otherwise return  false .   source  #  Base.factor     Method .  factor(x::nmod_poly)   Return the factorisation of  x .   source  #  Base.factor     Method .  factor(x::fmpz_mod_poly)   Return the factorisation of  x .   source  #  Nemo.factor_squarefree     Method .  factor_squarefree(x::nmod_poly)   Return the squarefree factorisation of  x .   source  #  Nemo.factor_squarefree     Method .  factor_squarefree(x::fmpz_mod_poly)   Return the squarefree factorisation of  x .   source  #  Nemo.factor_distinct_deg     Method .  factor_distinct_deg(x::nmod_poly)   Return the distinct degree factorisation of a squarefree polynomial  x .   source  #  Nemo.factor_distinct_deg     Method .  factor_distinct_deg(x::fmpz_mod_poly)   Return the distinct degree factorisation of a squarefree polynomial  x .   source  Here are some examples of factorisation.  R = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R,  x )\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))", 
            "title": "Factorisation"
        }, 
        {
            "location": "/build/polynomial/#special-functions", 
            "text": "The following special functions can be computed for any polynomial ring. Typically one uses the generator  x  of a polynomial ring to get the respective special polynomials expressed in terms of that generator.  #  Nemo.chebyshev_t     Method .  chebyshev_t(n::Int, x::PolyElem)   Return the Chebyshev polynomial of the first kind  T_n(x) , defined by   T_n(x) = \\cos(n \\cos^{-1}(x)) .   source  #  Nemo.chebyshev_u     Method .  chebyshev_u(n::Int, x::PolyElem)   Return the Chebyshev polynomial of the first kind  U_n(x) , defined by   (n+1) U_n(x) = T'_{n+1}(x) .   source  The following special polynomials are only available for certain base rings.  #  Nemo.cyclotomic     Method .  cyclotomic(n::Int, x::fmpz_poly)   Return the  n th cyclotomic polynomial, defined as  \\Phi_n(x) = \\prod_{\\omega} (x-\\omega),  where  \\omega  runs over all the   n th primitive roots of unity.   source  #  Nemo.swinnerton_dyer     Method .  swinnerton_dyer(n::Int, x::fmpz_poly)   Return the Swinnerton-Dyer polynomial  S_n , defined as the integer  polynomial  S_n = \\prod (x \\pm \\sqrt{2} \\pm \\sqrt{3} \\pm \\sqrt{5} \\pm \\ldots \\pm \\sqrt{p_n})   where  p_n  denotes the  n -th prime number and all combinations of signs are taken. This polynomial has degree  2^n  and is irreducible over the integers (it is the minimal polynomial of  \\sqrt{2} + \\ldots + \\sqrt{p_n} ).   source  #  Nemo.cos_minpoly     Method .  cos_minpoly(n::Int, x::fmpz_poly)   Return the minimal polynomial of  2 \\cos(2 \\pi / n) . For suitable choice of   n , this gives the minimal polynomial of  2 \\cos(a \\pi)  or  2 \\sin(a \\pi)  for any rational  a .   source  #  Nemo.theta_qexp     Method .  theta_qexp(e::Int, n::Int, x::fmpz_poly)   Return the  q -expansion to length  n  of the Jacobi theta function raised to the power  r , i.e.  \\vartheta(q)^r  where   \\vartheta(q) = 1 + \\sum_{k=1}^{\\infty} q^{k^2} .   source  #  Nemo.eta_qexp     Method .  eta_qexp(e::Int, n::Int, x::fmpz_poly)   Return the  q -expansion to length  n  of the Dedekind eta function (without  the leading factor  q^{1/24} ) raised to the power  r , i.e.  (q^{-1/24} \\eta(q))^r = \\prod_{k=1}^{\\infty} (1 - q^k)^r . In particular,  r = -1  gives the generating function of the partition function  p(k) , and  r = 24  gives, after multiplication by  q , the modular discriminant  \\Delta(q)  which generates the Ramanujan tau function  \\tau(k) .   source  Here are some examples of special functions.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Special functions"
        }
    ]
}
{
    "docs": [
        {
            "location": "/", 
            "text": "Nemo\n\n\nIntroduction\n\n\nNemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.\n\n\n\n\nhttp://nemocas.org\n (Website)\n\n\nhttps://github.com/Nemocas/Nemo.jl\n (Source code)\n\n\nhttp://nemo.readthedocs.org/en/latest/\n (Online documentation)\n\n\n\n\nThe features of Nemo so far include:\n\n\n\n\nMultiprecision integers and rationals\n\n\nIntegers modulo n\n\n\np-adic numbers\n\n\nFinite fields (prime and non-prime order)\n\n\nNumber field arithmetic\n\n\nMaximal orders of number fields\n\n\nArithmetic of ideals in maximal orders\n\n\nArbitrary precision real and complex balls\n\n\nUnivariate polynomials and matrices over the above\n\n\nGeneric polynomials, power series, fraction fields, residue rings and matrices\n\n\n\n\nInstallation\n\n\nTo use Nemo we require Julia 0.4 or higher. Please see\n\nhttp://julialang.org/downloads\n for instructions on how to obtain\njulia for your system.\n\n\nAt the Julia prompt simply type\n\n\njulia\n Pkg.add(\nNemo\n)\njulia\n Pkg.build(\nNemo\n)\n\n\n\n\nAlternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https://cloud.sagemath.com/).\n\n\nQuick start\n\n\nHere are some examples of using Nemo.\n\n\nThis example computes recursive univariate polynomials.\n\n\njulia\n using Nemo\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia\n T, z = PolynomialRing(S, \nz\n)\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia\n f = x + y + z + 1\nz+(y+(x+1))\n\njulia\n p = f^30; # semicolon supresses output\n\njulia\n @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)\n\n\n\n\nHere is an example using generic recursive ring constructions.\n\n\njulia\n using Nemo\n\njulia\n R, x = FiniteField(7, 11, \nx\n)\n(Finite field of degree 11 over F_7,x)\n\njulia\n S, y = PolynomialRing(R, \ny\n)\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia\n T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia\n U, z = PolynomialRing(T, \nz\n)\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia\n f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia\n g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia\n s = f^12;\n\njulia\n t = (s + g)^12;\n\njulia\n @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)\n\n\n\n\nHere is an example using matrices.\n\n\njulia\n using Nemo\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n R, x = PolynomialRing(ZZ, \nx\n)\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n M = MatrixSpace(R, 40, 40)();\n\njulia\n for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia\n @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)\n\n\n\n\nAnd here is an example with power series.\n\n\njulia\n using Nemo\n\njulia\n R, x = QQ[\nx\n]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia\n S, t = PowerSeriesRing(R, 100, \nt\n)\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia\n u = t + O(t^100)\nt+O(t^100)\n\njulia\n @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/#introduction", 
            "text": "Nemo is a computer algebra package for the Julia programming language, maintained by William Hart, \nTommy Hofmann, Claus Fieker, Fredrik Johansson with additional code by Oleksandr Motsak and other\ncontributors.   http://nemocas.org  (Website)  https://github.com/Nemocas/Nemo.jl  (Source code)  http://nemo.readthedocs.org/en/latest/  (Online documentation)   The features of Nemo so far include:   Multiprecision integers and rationals  Integers modulo n  p-adic numbers  Finite fields (prime and non-prime order)  Number field arithmetic  Maximal orders of number fields  Arithmetic of ideals in maximal orders  Arbitrary precision real and complex balls  Univariate polynomials and matrices over the above  Generic polynomials, power series, fraction fields, residue rings and matrices", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Nemo we require Julia 0.4 or higher. Please see http://julialang.org/downloads  for instructions on how to obtain\njulia for your system.  At the Julia prompt simply type  julia  Pkg.add( Nemo )\njulia  Pkg.build( Nemo )  Alternatively, if you don't want to set Julia up yourself, Julia and Nemo are available on\n[https://cloud.sagemath.com/] (https://cloud.sagemath.com/).", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here are some examples of using Nemo.  This example computes recursive univariate polynomials.  julia  using Nemo\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,y)\n\njulia  T, z = PolynomialRing(S,  z )\n(Univariate Polynomial Ring in z over Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring,z)\n\njulia  f = x + y + z + 1\nz+(y+(x+1))\n\njulia  p = f^30; # semicolon supresses output\n\njulia  @time q = p*(p+1);\n  0.325521 seconds (140.64 k allocations: 3.313 MB)  Here is an example using generic recursive ring constructions.  julia  using Nemo\n\njulia  R, x = FiniteField(7, 11,  x )\n(Finite field of degree 11 over F_7,x)\n\njulia  S, y = PolynomialRing(R,  y )\n(Univariate Polynomial Ring in y over Finite field of degree 11 over F_7,y)\n\njulia  T = ResidueRing(S, y^3 + 3x*y + 1)\nResidue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1)\n\njulia  U, z = PolynomialRing(T,  z )\n(Univariate Polynomial Ring in z over Residue ring of Univariate Polynomial Ring in y over Finite field of degree 11 over F_7 modulo y^3+(3*x)*y+(1),z)\n\njulia  f = (3y^2 + y + x)*z^2 + ((x + 2)*y^2 + x + 1)*z + 4x*y + 3;\n\njulia  g = (7y^2 - y + 2x + 7)*z^2 + (3y^2 + 4x + 1)*z + (2x + 1)*y + 1;\n\njulia  s = f^12;\n\njulia  t = (s + g)^12;\n\njulia  @time resultant(s, t)\n  0.426612 seconds (705.88 k allocations: 52.346 MB, 2.79% gc time)\n(x^10+4*x^8+6*x^7+3*x^6+4*x^5+x^4+6*x^3+5*x^2+x)*y^2+(5*x^10+x^8+4*x^7+3*x^5+5*x^4+3*x^3+x^2+x+6)*y+(2*x^10+6*x^9+5*x^8+5*x^7+x^6+6*x^5+5*x^4+4*x^3+x+3)  Here is an example using matrices.  julia  using Nemo\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  R, x = PolynomialRing(ZZ,  x )\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  M = MatrixSpace(R, 40, 40)();\n\njulia  for i in 1:40\n          for j in 1:40\n             M[i, j] = R(map(fmpz, rand(-20:20, 3)))\n          end\n       end\n\njulia  @time det(M);\n  0.174888 seconds (268.40 k allocations: 26.537 MB, 4.47% gc time)  And here is an example with power series.  julia  using Nemo\n\njulia  R, x = QQ[ x ]\n(Univariate Polynomial Ring in x over Rational Field,x)\n\njulia  S, t = PowerSeriesRing(R, 100,  t )\n(Univariate power series ring in t over Univariate Polynomial Ring in x over Rational Field,t+O(t^101))\n\njulia  u = t + O(t^100)\nt+O(t^100)\n\njulia  @time divexact((u*exp(x*u)), (exp(u)-1));\n  0.042663 seconds (64.01 k allocations: 1.999 MB, 15.40% gc time)", 
            "title": "Quick start"
        }, 
        {
            "location": "/about/", 
            "text": "Nemo\n\n\nWhat is Nemo?\n\n\nNemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering\n\n\n\n\nCommutative Algebra\n\n\nNumber Theory\n\n\nGroup Theory\n\n\n\n\nNemo consists of wrappers of specialised C/C++ libraries:\n\n\n\n\nFlint    [http://flintlib.org/]\n\n\nArb      [http://fredrikj.net/arb/]\n\n\nAntic    [https://github.com/wbhart/antic/]\n\n\nSingular [https://www.singular.uni-kl.de/]\n\n\nPari     [http://pari.math.u-bordeaux.fr/]\n\n\n\n\nIt will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.\n\n\nNemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include\n\n\n\n\nUnivariate polynomial rings\n\n\nPower series rings\n\n\nResidue rings (modulo principal ideals)\n\n\nFraction fields\n\n\nMatrices\n\n\n\n\nWhy Julia?\n\n\nJulia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.\n\n\nThe benefits of Julia include\n\n\n\n\nFamiliar imperative syntax\n\n\nJIT compilation (provides near native performance, even for highly generic code)\n\n\nREPL console (cuts down on development time)\n\n\nParametric types (allows for fast generic constructions over other data types)\n\n\nPowerful metaprogramming facilities\n\n\nOperator overloading\n\n\nMultiple dispatch (dispatch on every argument of a function)\n\n\nEfficient native C interface (no wrapper overhead)\n\n\nExperimental C++ interface\n\n\nDynamic type inference\n\n\nBuilt-in bignums\n\n\nAble to be embedded in C programs\n\n\nHigh performance collection types (dictionaries, iterators, arrays, etc.)\n\n\nJupyter support (for web based notebooks)\n\n\n\n\nThe main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "About Nemo"
        }, 
        {
            "location": "/about/#nemo", 
            "text": "", 
            "title": "Nemo"
        }, 
        {
            "location": "/about/#what-is-nemo", 
            "text": "Nemo is a computer algebra package for the Julia programming language. Our aim is to provide a highly\nperformant computer algebra package covering   Commutative Algebra  Number Theory  Group Theory   Nemo consists of wrappers of specialised C/C++ libraries:   Flint    [http://flintlib.org/]  Arb      [http://fredrikj.net/arb/]  Antic    [https://github.com/wbhart/antic/]  Singular [https://www.singular.uni-kl.de/]  Pari     [http://pari.math.u-bordeaux.fr/]   It will also eventually provide interfaces to interpreted library code from other computer algebra\nsystems such as Gap and Singular.  Nemo also provides implementations of generic algorithms and mathematical data structures. So far the\nfully recursive constructions include   Univariate polynomial rings  Power series rings  Residue rings (modulo principal ideals)  Fraction fields  Matrices", 
            "title": "What is Nemo?"
        }, 
        {
            "location": "/about/#why-julia", 
            "text": "Julia is a sophisticated, modern programming language which is designed to be both performant and\nflexible. It was written by mathematicians, for mathematicians.  The benefits of Julia include   Familiar imperative syntax  JIT compilation (provides near native performance, even for highly generic code)  REPL console (cuts down on development time)  Parametric types (allows for fast generic constructions over other data types)  Powerful metaprogramming facilities  Operator overloading  Multiple dispatch (dispatch on every argument of a function)  Efficient native C interface (no wrapper overhead)  Experimental C++ interface  Dynamic type inference  Built-in bignums  Able to be embedded in C programs  High performance collection types (dictionaries, iterators, arrays, etc.)  Jupyter support (for web based notebooks)   The main benefits for Nemo are the parametric type system and JIT compilation. The former allows us to\nmodel many mathematical types, e.g. generic polynomial rings over an arbitrary base ring. The latter\nspeeds up the runtime performance, even of highly generic mathematical procedures.", 
            "title": "Why Julia?"
        }, 
        {
            "location": "/types/", 
            "text": "Types in Nemo\n\n\nOn this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations. \n\n\nIn contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.\n\n\nIntroduction\n\n\nJulia provides two levels of types that we make use of\n\n\n\n\nabstract types\n\n\nconcrete types\n\n\n\n\nConcrete types are just like the usual types everyone is familiar with from C or C++.\n\n\nAbstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.\n\n\nTo write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter, \nT\n say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter \nT\n must belong to.\n\n\nWe use the symbol \n:\n in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type \nInt64\n for 64 bit machine integers belongs to the Julia abstract type\n\nInteger\n. Thus \nInt \n: Integer\n returns \ntrue\n.\n\n\nHere is some Julia code illustrating this with a more complex example. We create an abstract type called\n\nShape\n and two user defined concrete types \nsquare\n and \ncircle\n belonging to \nShape\n. We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type \nT\n belonging to the abstract type \nShape\n.\n\n\nNote that in the type definitions of \nsquare\n and \ncircle\n we specify that those types belong to the\nabstract type \nShape\n using the \n:\n operator.\n\n\nabstract Shape\n\ntype square \n: Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle \n: Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T \n: Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)\n\n\n\n\nThe abstract type hierarchy in Nemo\n\n\nAbstract types in Julia can also belong to one another in a hierarchy. For example, the \nNemo.Field\n\nabstract type belongs to the \nNemo.Ring\n abstract type. An object representing a field in Nemo has type\nbelonging to \nNemo.Field\n. But because we define the inclusion \nNemo.Field \n: Nemo.Ring\n in Nemo, the\ntype of such an object also automatically belongs to \nNemo.Ring\n. This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.\n\n\nIn Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type\n\nGenPolyRing\n to model a generic polynomial ring, and elements of that polynomial ring would have\ntype \nGenPoly\n. \n\n\nIn order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains. \n\n\n\n\nAll objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.\n\n\nWhy types aren't enough\n\n\nNaively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.\n\n\nAs an example, consider the ring \nR = \\mathbb{Z}/n\\mathbb{Z}\n for a multiprecision integer \nn\n. If we\nwere to model the ring \nR\n as a type, then the type would somehow need to contain the modulus\n\nn\n. This is not possible in Julia, and in fact it is not desirable either.\n\n\nJulia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings \n\\mathbb{Z}/n\\mathbb{Z}\n would be needed\nand every function we use would be recompiled over and over for each different \nn\n. This would result \nin a huge delay as the compiler is invoked many times.\n\n\nFor this reason, the modulus \nn\n needs to be attached to the \nelements\n of the ring, not to type\nassociated with those elements.\n\n\nBut now we have a problem. How do we create new elements of the ring \n\\mathbb{Z}/n\\mathbb{Z}\n given only\nthe type? Suppose all rings \n\\mathbb{Z}/n\\mathbb{Z}\n were represented by the same type \nZmod\n say. How\nwould we create \na = 3 \\pmod{7}\n? We could not write \na = Zmod(3)\n since the modulus \n7\n is not contained\nin the type \nZmod\n.\n\n\nWe could of course use the notation \na = Zmod(3, 7)\n, but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as \na = ZZ(7)\n and cases where they take a modulus, such as \na = Zmod(3, 7)\n.\n\n\nThe way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called \nparent\n objects can contain extra information,\nsuch as the modulus \nn\n. \n\n\nIn order to create new elements of \n\\mathbb{Z}/n\\mathbb{Z}\n as above, we overload the \ncall\n operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.\n\n\nIn the following Nemo example, we create the parent object \nR\n corresponding to the ring\n\n\\mathbb{Z}/7\\mathbb{Z}\n. We then create a new element \na\n of this ring by calling the parent object\n\nR\n, just as though \nR\n were a type with a constructor accepting an \nInt\n parameter. \n\n\nR = ResidueRing(ZZ, 7)\na = R(3)\n\n\n\n\nThis example creates the element \na = 3 \\pmod{7}\n. \n\n\nThe important point is that unlike a type, a parent object such as \nR\n can contain additional information\nthat a type cannot contain, such as the modulus \n7\n of the ring in this example, or context objects\nrequired by C libraries in other examples.\n\n\nMore complex example of parent objects\n\n\nHere is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.\n\n\njulia\n using Nemo\n\njulia\n R, x = ZZ[\nx\n]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia\n f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia\n typeof(R)\nNemo.FmpzPolyRing\n\njulia\n typeof(f)\nNemo.fmpz_poly\n\njulia\n parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia\n typeof(R) \n: PolyRing\ntrue\n\njulia\n typeof(f) \n: PolyElem\ntrue\n\njulia\n parent(f) == R\ntrue\n\n\n\n\nConcrete types in Nemo\n\n\nFinally we come to all the concrete types in Nemo. \n\n\nThese are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).\n\n\nBelow we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess. \n\n\nFor example, \nfmpz\n belongs to the abstract type \nRingElem\n and \nFlintIntegerRing\n belongs to \nRing\n.\nSimilarly \nPoly{T}\n belongs to \nPolyElem\n whereas \nPolynomialRing{T}\n belongs to \nPolyRing\n. We also\nhave that \nfmpz_poly\n belongs to \nPolyElem\n and \nFmpzPolyRing\n belongs to \nPolyRing\n, and so on.\n\n\nAll the generic types are parameterised by a type \nT\n which is the type of the \nelements\n of the ring\nthey are defined over. \n\n\n\n\n\n\nGeneric\n\n\n\n\nGenPoly{T}\n (\nGenPolyRing{T}\n)\n\n\nGenRelSeries{T}\n (\nGenRelSeriesRing{T}\n)\n\n\nGenRes{T}\n (\nGenResRing{T}\n)\n\n\nGenFrac{T}\n (\nGenFracField{T}\n)\n\n\nGenMat{T}\n (\nGenMatSpace{T}\n)\n\n\n\n\n\n\n\n\nFlint\n\n\n\n\nfmpz\n (\nFlintIntegerRing\n)\n\n\nfmpq\n (\nFlintRationalField\n)\n\n\nfq_nmod\n (\nFqNmodFiniteField\n)\n\n\nfq\n (\nFqFiniteField\n)\n\n\npadic\n (\nFlintPadicField\n)\n\n\nfmpz_poly\n (\nFmpzPolyRing\n)\n\n\nfmpq_poly\n (\nFmpqPolyRing\n)\n\n\nnmod_poly\n (\nNmodPolyRing\n)\n\n\nfmpz_mod_poly\n (\nFmpzModPolyRing\n)\n\n\nfq_poly\n (\nFqPolyRing\n)\n\n\nfq_nmod_poly\n (\nFqNmodPolyRing\n)\n\n\nfmpz_series\n (\nFmpzSeriesRing\n)\n\n\nfmpq_series\n (\nFmpqSeriesRing\n)\n\n\nfmpz_mod_series\n (\nFmpzModSeriesRing\n)\n\n\nfq_nmod_series\n (\nFqNmodSeriesRing\n)\n\n\nfq_series\n (\nFqSeriesRing\n)\n\n\nfmpz_mat\n (\nFmpzMatSpace\n)\n\n\nnmod_mat\n (\nNmodMatSpace\n)\n\n\nperm\n (\nFlintPermGroup\n)\n\n\n\n\n\n\n\n\nAntic\n\n\n\n\nnf_elem\n (\nAnticNumberField\n)\n\n\n\n\n\n\n\n\nArb\n\n\n\n\narb\n (\nArbField\n)\n\n\nacb\n (\nAcbField\n)\n\n\n\n\n\n\n\n\nPari\n\n\n\n\npari_int\n (\nPariIntegerRing\n)\n\n\npari_rat\n (\nPariRationalField\n)\n\n\npari_vec{T}\n (\nPariVector{T}\n)\n\n\npari_poly{T}\n (\nPariPolyRing{T}\n)\n\n\npari_polmod{T}\n (\nPariPolModRing{T}\n)\n\n\npari_maximal_order_elem\n (\nPariMaximalOrder\n)\n\n\nPariIdeal\n (\nPariIdealSet\n)\n\n\nno element type (\nPariNumberField\n)\n\n\nPariFactor{T}\n (no parent type)", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#types-in-nemo", 
            "text": "On this page we discuss the type hierarchy in Nemo and a concept known as parents. These details are\nquite technical and should be skipped or skimmed by new users of Julia/Nemo. Types are almost never dealt with\ndirectly when scripting Nemo to do mathematical computations.   In contrast, Nemo developers will certainly want to know how we model mathematical objects and the\nrings, fields, groups, etc. that they belong to in Nemo.", 
            "title": "Types in Nemo"
        }, 
        {
            "location": "/types/#introduction", 
            "text": "Julia provides two levels of types that we make use of   abstract types  concrete types   Concrete types are just like the usual types everyone is familiar with from C or C++.  Abstract types can be thought of as collections of types. They are used when writing generic functions\nthat should work for any type in the given collection.  To write a generic function that accepts any type in a given collection of types, we first create an\nabstract type. Then we create the individual concrete types that belong to that abstract type. A generic\nfunction can then be constructed with a type parameter,  T  say, similar to a template parameter in C++.\nThe main difference is that we can specify which abstract type our type parameter  T  must belong to.  We use the symbol  :  in Julia to determine that a given type belongs to a given abstract type. For\nexample the built-in Julia type  Int64  for 64 bit machine integers belongs to the Julia abstract type Integer . Thus  Int  : Integer  returns  true .  Here is some Julia code illustrating this with a more complex example. We create an abstract type called Shape  and two user defined concrete types  square  and  circle  belonging to  Shape . We then show how\nto write methods that accept each of the concrete types and then show how to write a generic function\nfor any type  T  belonging to the abstract type  Shape .  Note that in the type definitions of  square  and  circle  we specify that those types belong to the\nabstract type  Shape  using the  :  operator.  abstract Shape\n\ntype square  : Shape\n   width::Int\n   border_thickness::Int\nend\n\ntype circle  : Shape\n   centre::Tuple{Int, Int}\n   radius::Int\n   border_thickness::Int\nend\n\nfunction area(s::square)\n   return s.width^2\nend\n\nfunction area(s::circle)\n   return pi*s.radius^2\nend\n\nfunction border_thickness{T  : Shape}(s::T)\n   return s.border_thickness\nend\n\ns = square(3, 1)\nc = circle((3, 4), 2, 2)\n\narea(s)\narea(c)\nborder_thickness(s)\nborder_thickness(c)", 
            "title": "Introduction"
        }, 
        {
            "location": "/types/#the-abstract-type-hierarchy-in-nemo", 
            "text": "Abstract types in Julia can also belong to one another in a hierarchy. For example, the  Nemo.Field \nabstract type belongs to the  Nemo.Ring  abstract type. An object representing a field in Nemo has type\nbelonging to  Nemo.Field . But because we define the inclusion  Nemo.Field  : Nemo.Ring  in Nemo, the\ntype of such an object also automatically belongs to  Nemo.Ring . This means that any generic function in\nNemo which is designed to work with ring objects will certainly also work with field objects.  In Nemo we also distinguish between the elements of a field, say, and the field itself, and similarly\nfor groups and rings and all other kinds of domains in Nemo. For example, we have an object of type GenPolyRing  to model a generic polynomial ring, and elements of that polynomial ring would have\ntype  GenPoly .   In order to model this distinction between elements and the domains they belong to, Nemo has two main\nbranches in its abstract type hierarchy, as shown in the following diagram. One branch consists of the\nabstract types for the domains available in Nemo and the other branch is for the abstract types for\nelements of those domains.    All objects in Nemo, whether they represent rings, fields, groups, sets, etc. on the one hand, or ring\nelements, field elements, etc. on the other hand, have concrete types that belong to one of the abstract\ntypes shown above.", 
            "title": "The abstract type hierarchy in Nemo"
        }, 
        {
            "location": "/types/#why-types-arent-enough", 
            "text": "Naively, one may expect that rings in Nemo can be modeled as types and their elements as objects with the\ngiven type. But there are various reasons why this is not a good model.  As an example, consider the ring  R = \\mathbb{Z}/n\\mathbb{Z}  for a multiprecision integer  n . If we\nwere to model the ring  R  as a type, then the type would somehow need to contain the modulus n . This is not possible in Julia, and in fact it is not desirable either.  Julia dispatches on type, and each time we call a generic function with different types, a new version\nof the function is compiled at runtime for performance. But this would be a disaster if we were writing\na multimodular algorithm, say. In such an algorithm many rings  \\mathbb{Z}/n\\mathbb{Z}  would be needed\nand every function we use would be recompiled over and over for each different  n . This would result \nin a huge delay as the compiler is invoked many times.  For this reason, the modulus  n  needs to be attached to the  elements  of the ring, not to type\nassociated with those elements.  But now we have a problem. How do we create new elements of the ring  \\mathbb{Z}/n\\mathbb{Z}  given only\nthe type? Suppose all rings  \\mathbb{Z}/n\\mathbb{Z}  were represented by the same type  Zmod  say. How\nwould we create  a = 3 \\pmod{7} ? We could not write  a = Zmod(3)  since the modulus  7  is not contained\nin the type  Zmod .  We could of course use the notation  a = Zmod(3, 7) , but this would make implementation of generic\nalgorithms very difficult, as they would need to distinguish the case where constructors take a single\nargument, such as  a = ZZ(7)  and cases where they take a modulus, such as  a = Zmod(3, 7) .  The way we get around this in Nemo is to have special (singleton) objects that act like types, but are\nreally just ordinary Julia objects. These objects, called  parent  objects can contain extra information,\nsuch as the modulus  n .   In order to create new elements of  \\mathbb{Z}/n\\mathbb{Z}  as above, we overload the  call  operator\nfor the parent object, making it callable. Making a parent object callable is exactly analogous to\nwriting a constructor for a type.  In the following Nemo example, we create the parent object  R  corresponding to the ring \\mathbb{Z}/7\\mathbb{Z} . We then create a new element  a  of this ring by calling the parent object R , just as though  R  were a type with a constructor accepting an  Int  parameter.   R = ResidueRing(ZZ, 7)\na = R(3)  This example creates the element  a = 3 \\pmod{7} .   The important point is that unlike a type, a parent object such as  R  can contain additional information\nthat a type cannot contain, such as the modulus  7  of the ring in this example, or context objects\nrequired by C libraries in other examples.", 
            "title": "Why types aren't enough"
        }, 
        {
            "location": "/types/#more-complex-example-of-parent-objects", 
            "text": "Here is some Julia/Nemo code which constructs a polynomial ring over the integers, a polynomial in that\nring and then does some introspection to illustrate the various relations between the objects and types.  julia  using Nemo\n\njulia  R, x = ZZ[ x ]\n(Univariate Polynomial Ring in x over Integer Ring,x)\n\njulia  f = x^2 + 3x + 1\nx^2+3*x+1\n\njulia  typeof(R)\nNemo.FmpzPolyRing\n\njulia  typeof(f)\nNemo.fmpz_poly\n\njulia  parent(f)\nUnivariate Polynomial Ring in x over Integer Ring\n\njulia  typeof(R)  : PolyRing\ntrue\n\njulia  typeof(f)  : PolyElem\ntrue\n\njulia  parent(f) == R\ntrue", 
            "title": "More complex example of parent objects"
        }, 
        {
            "location": "/types/#concrete-types-in-nemo", 
            "text": "Finally we come to all the concrete types in Nemo.   These are of two main kinds: those for generic constructions (e.g. generic polynomials over an arbitrary\nring) and those for specific implementations, usually provided by a C library (e.g. polynomials over the\nintegers, provided by Flint).  Below we give the type of each kind of element available in Nemo. In parentheses we list the types of\ntheir corresponding parent objects. Note that these are the types of the element objects and parent\nobjects respectively, not the abstract types to which these types belong, which the reader can easily\nguess.   For example,  fmpz  belongs to the abstract type  RingElem  and  FlintIntegerRing  belongs to  Ring .\nSimilarly  Poly{T}  belongs to  PolyElem  whereas  PolynomialRing{T}  belongs to  PolyRing . We also\nhave that  fmpz_poly  belongs to  PolyElem  and  FmpzPolyRing  belongs to  PolyRing , and so on.  All the generic types are parameterised by a type  T  which is the type of the  elements  of the ring\nthey are defined over.     Generic   GenPoly{T}  ( GenPolyRing{T} )  GenRelSeries{T}  ( GenRelSeriesRing{T} )  GenRes{T}  ( GenResRing{T} )  GenFrac{T}  ( GenFracField{T} )  GenMat{T}  ( GenMatSpace{T} )     Flint   fmpz  ( FlintIntegerRing )  fmpq  ( FlintRationalField )  fq_nmod  ( FqNmodFiniteField )  fq  ( FqFiniteField )  padic  ( FlintPadicField )  fmpz_poly  ( FmpzPolyRing )  fmpq_poly  ( FmpqPolyRing )  nmod_poly  ( NmodPolyRing )  fmpz_mod_poly  ( FmpzModPolyRing )  fq_poly  ( FqPolyRing )  fq_nmod_poly  ( FqNmodPolyRing )  fmpz_series  ( FmpzSeriesRing )  fmpq_series  ( FmpqSeriesRing )  fmpz_mod_series  ( FmpzModSeriesRing )  fq_nmod_series  ( FqNmodSeriesRing )  fq_series  ( FqSeriesRing )  fmpz_mat  ( FmpzMatSpace )  nmod_mat  ( NmodMatSpace )  perm  ( FlintPermGroup )     Antic   nf_elem  ( AnticNumberField )     Arb   arb  ( ArbField )  acb  ( AcbField )     Pari   pari_int  ( PariIntegerRing )  pari_rat  ( PariRationalField )  pari_vec{T}  ( PariVector{T} )  pari_poly{T}  ( PariPolyRing{T} )  pari_polmod{T}  ( PariPolModRing{T} )  pari_maximal_order_elem  ( PariMaximalOrder )  PariIdeal  ( PariIdealSet )  no element type ( PariNumberField )  PariFactor{T}  (no parent type)", 
            "title": "Concrete types in Nemo"
        }, 
        {
            "location": "/constructors/", 
            "text": "Constructing mathematical objects in Nemo\n\n\nConstructing objects in Julia\n\n\nIn Julia, one constructs objects of a given type by calling a type constructor. This is simply a function\nwith the same name as the type itself. For example, to construct a \nBigInt\n object in Julia, we simply\ncall the \nBigInt\n constructor:\n\n\nn = BigInt(\n1234567898765434567898765434567876543456787654567890\n)\n\n\n\n\nJulia also uses constructors to convert between types. For example, to convert an \nInt\n to a \nBigInt\n:\n\n\nm = BigInt(123)\n\n\n\n\nHow we construct objects in Nemo\n\n\nAs we explained in the previous section, Julia types don't contain enough information to properly model\nthe ring of integers modulo \nn\n for a multiprecision modulus \nn\n. Instead of using types to construct\nobjects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.\n\n\nConsider the following simple example, to create a Flint multiprecision integer:\n\n\nn = ZZ(\n12345678765456787654567890987654567898765678909876567890\n)\n\n\n\n\nHere \nZZ\n is not a Julia type, but a callable object. However, for most purposes one can think of such\na parent object \nZZ\n as though it were a type.\n\n\nConstructing parent objects\n\n\nFor more complicated groups, rings, fields, etc., one first needs to construct the parent object before\none can use it to construct element objects.\n\n\nNemo provides a set of functions for constructing such parent objects. For example, to create a parent\nobject for polynomials over the integers, we use the \nPolynomialRing\n parent object constructor.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nf = x^3 + 3x + 1\ng = R(12)\n\n\n\n\nIn this example, \nR\n is the parent object and we use it to convert the \nInt\n value \n12\n to an element\nof the polynomial ring \n\\mathbb{Z}[x]\n.\n\n\nList of parent object constructors\n\n\nFor convenience, we provide a list of all the parent object constructors in Nemo and explain what domains\nthey represent.\n\n\n\n\n\n\n\n\nMathematics\n\n\nNemo constructor\n\n\n\n\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}\n\n\n\n\nR = ZZ\n\n\n\n\n\n\n\n\nR = \\mathbb{Q}\n\n\n\n\nR = QQ\n\n\n\n\n\n\n\n\nR = \\mathbb{F}_{p^n}\n\n\n\n\nR, a = FiniteField(p, n, \"a\")\n\n\n\n\n\n\n\n\nR = \\mathbb{Z}/n\\mathbb{Z}\n\n\n\n\nR = ResidueRing(ZZ, n)\n\n\n\n\n\n\n\n\nS = R[x]\n\n\n\n\nS, x = PolynomialRing(R, \"x\")\n\n\n\n\n\n\n\n\nS = R[x]\n (to precision \nn\n)\n\n\nS, x = PowerSeriesRing(R, n, \"x\")\n\n\n\n\n\n\n\n\nS = \\mbox{Frac}_R\n\n\n\n\nS = FractionField(R)\n\n\n\n\n\n\n\n\nS = R/(f)\n\n\n\n\nS = ResidueRing(R, f)\n\n\n\n\n\n\n\n\nS = \\mbox{Mat}_{m\\times n}(R)\n\n\n\n\nS = MatrixSpace(R, m, n)\n\n\n\n\n\n\n\n\nS = \\mathbb{Q}[x]/(f)\n\n\n\n\nS, a = NumberField(f, \"a\")\n\n\n\n\n\n\n\n\nO = \\mathcal{O}_K\n\n\n\n\nS = MaximalOrder(K)\n\n\n\n\n\n\nideal \nI\n of \nO = \\mathcal{O}_K\n\n\n\n\nI = Ideal(O, gens, ...)", 
            "title": "Parent object constructors"
        }, 
        {
            "location": "/constructors/#constructing-mathematical-objects-in-nemo", 
            "text": "", 
            "title": "Constructing mathematical objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-objects-in-julia", 
            "text": "In Julia, one constructs objects of a given type by calling a type constructor. This is simply a function\nwith the same name as the type itself. For example, to construct a  BigInt  object in Julia, we simply\ncall the  BigInt  constructor:  n = BigInt( 1234567898765434567898765434567876543456787654567890 )  Julia also uses constructors to convert between types. For example, to convert an  Int  to a  BigInt :  m = BigInt(123)", 
            "title": "Constructing objects in Julia"
        }, 
        {
            "location": "/constructors/#how-we-construct-objects-in-nemo", 
            "text": "As we explained in the previous section, Julia types don't contain enough information to properly model\nthe ring of integers modulo  n  for a multiprecision modulus  n . Instead of using types to construct\nobjects, we use special objects that we refer to as parent objects. They behave a lot like Julia types.  Consider the following simple example, to create a Flint multiprecision integer:  n = ZZ( 12345678765456787654567890987654567898765678909876567890 )  Here  ZZ  is not a Julia type, but a callable object. However, for most purposes one can think of such\na parent object  ZZ  as though it were a type.", 
            "title": "How we construct objects in Nemo"
        }, 
        {
            "location": "/constructors/#constructing-parent-objects", 
            "text": "For more complicated groups, rings, fields, etc., one first needs to construct the parent object before\none can use it to construct element objects.  Nemo provides a set of functions for constructing such parent objects. For example, to create a parent\nobject for polynomials over the integers, we use the  PolynomialRing  parent object constructor.  R, x = PolynomialRing(ZZ,  x )\nf = x^3 + 3x + 1\ng = R(12)  In this example,  R  is the parent object and we use it to convert the  Int  value  12  to an element\nof the polynomial ring  \\mathbb{Z}[x] .", 
            "title": "Constructing parent objects"
        }, 
        {
            "location": "/constructors/#list-of-parent-object-constructors", 
            "text": "For convenience, we provide a list of all the parent object constructors in Nemo and explain what domains\nthey represent.     Mathematics  Nemo constructor       R = \\mathbb{Z}   R = ZZ     R = \\mathbb{Q}   R = QQ     R = \\mathbb{F}_{p^n}   R, a = FiniteField(p, n, \"a\")     R = \\mathbb{Z}/n\\mathbb{Z}   R = ResidueRing(ZZ, n)     S = R[x]   S, x = PolynomialRing(R, \"x\")     S = R[x]  (to precision  n )  S, x = PowerSeriesRing(R, n, \"x\")     S = \\mbox{Frac}_R   S = FractionField(R)     S = R/(f)   S = ResidueRing(R, f)     S = \\mbox{Mat}_{m\\times n}(R)   S = MatrixSpace(R, m, n)     S = \\mathbb{Q}[x]/(f)   S, a = NumberField(f, \"a\")     O = \\mathcal{O}_K   S = MaximalOrder(K)    ideal  I  of  O = \\mathcal{O}_K   I = Ideal(O, gens, ...)", 
            "title": "List of parent object constructors"
        }, 
        {
            "location": "/build/polynomial/", 
            "text": "Introduction\n\n\nNemo allow the creation of dense, univariate polynomials over any computable ring \nR\n. There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the polynomial types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenPoly{T}\n\n\nGenPolyRing{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_poly\n\n\nFmpzPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n (small \nn\n)\n\n\nFlint\n\n\nnmod_poly\n\n\nNmodPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n (large \nn\n)\n\n\nFlint\n\n\nfmpz_mod_poly\n\n\nFmpzModPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{Q}\n\n\n\n\nFlint\n\n\nfmpq_poly\n\n\nFmpqPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (small \nn\n)\n\n\nFlint\n\n\nfq_nmod_poly\n\n\nFqNmodPolyRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (large \nn\n)\n\n\nFlint\n\n\nfq_poly\n\n\nFqPolyRing\n\n\n\n\n\n\n\n\nThe string representation of the variable and the base ring \nR\n of a generic polynomial is stored in its parent object. \n\n\nAll polynomial element types belong to the abstract type \nPolyElem\n and all of the polynomial ring types belong to the abstract type \nPolyRing\n. This enables one to write generic functions that can accept any Nemo polynomial type.\n\n\n\n\nPolynomial ring constructors\n\n\nIn order to construct polynomials in Nemo, one must first construct the polynomial ring itself. This is accomplished with the following constructor.\n\n\n#\n\n\nNemo.PolynomialRing\n \n \nMethod\n.\n\n\nPolynomialRing(R::Ring, s::AbstractString{}; cached::Bool = true)\n\n\n\n\n\n\nGiven a base ring \nR\n and string \ns\n specifying how the generator (variable) should be printed, return a tuple \nS, x\n representing the new polynomial ring \nS = R[x]\n and the generator \nx\n of the ring. By default the parent object \nS\n will depend only on \nR\n and \nx\n and will be cached. Setting the optional argument \ncached\n to \nfalse\n will prevent the parent object \nS\n from being cached.\n\n\n\n\nsource\n\n\nA shorthand version of this function is provided: given a base ring \nR\n, we abbreviate the constructor as follows.\n\n\nR[\nx\n]\n\n\n\n\nHere are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = QQ[\nz\n]\n\nf = R()\ng = R(123)\nh = S(ZZ(1234))\nk = S(x + 1)\nm = T(z + 1)\n\n\n\n\n\n\nPolynomial element constructors\n\n\nOnce a polynomial ring is constructed, there are various ways to construct polynomials in that ring.\n\n\nThe easiest way is simply using the generator returned by the \nPolynomialRing\n constructor and and build up the polynomial using basic arithmetic. Julia has quite flexible notation for the construction of polynomials in this way.\n\n\nIn addition we provide the following functions for constructing certain useful polynomials.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::PolyRing)\n\n\n\n\n\n\nReturn the zero polynomial in the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::PolyRing)\n\n\n\n\n\n\nReturn the constant polynomial \n1\n in the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gen\n \n \nMethod\n.\n\n\ngen(R::PolyRing)\n\n\n\n\n\n\nReturn the generator of the given polynomial ring.\n\n\n\n\nsource\n\n\nHere are some examples of constructing polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1\n\nh = zero(S)\nk = one(R)\nm = gen(S)\n\n\n\n\n\n\nBasic functionality\n\n\nAll univariate polynomial modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own polynomial module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom univariate polynomial types in Nemo. \n\n\nWe write \nU\n for the type of the polynomials in the polynomial ring and \nT\n for the type of elements of the coefficient ring.\n\n\nAll of these functions are provided for all existing polynomial types in Nemo.\n\n\nparent_type{U \n: PolyElem}(::Type{U})\n\n\n\n\nGiven the type of polynomial elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::PolyRing)\n\n\n\n\nGiven a parent object for the polynomial ring, return the type of elements of the polynomial ring.\n\n\nBase.hash(a::PolyElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the polynomial \na\n. This should be xor'd with a fixed random hexadecimal specific to the polynomial type. The hash of each coefficient should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\nfit!(a::PolyElem, n::Int)\n\n\n\n\nBy reallocating if necessary, ensure that the given polynomial has space for at least \nn\n coefficients. This function does not change the length of the polynomial and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.\n\n\nnormalise(a::PolyElem, n::Int)\n\n\n\n\nReturn the normalised length of the given polynomial, assuming its current length is \nn\n. Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the polynomial. That can be done with a subsequent call to \nset_length!\n using the length returned by \nnormalise\n.\n\n\nset_length!(a::PolyElem, n::Int)\n\n\n\n\nSet the length of an existing polynomial that has sufficient space allocated, i.e. a polynomial for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial type has a field, \nlength\n, which corresponds to the current length of the polynomial, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.\n\n\nlength(a::PolyElem)\n\n\n\n\nReturn the current length (not the number of allocated coefficients), of the given polynomial. Note that this function only needs to be provided by a developer for a custom polynomial type if the Julia type definition for polynomial elements doesn't contain a field \nlength\n corresponding to the current length of the polynomial. Otherwise the supplied generic implementation will work.\n\n\ncoeff(a::PolyElem, n::Int)\n\n\n\n\nReturn the degree \nn\n coefficient of the given polynomial. Note coefficients are numbered from \nn = 0\n for the constant coefficient. If \nn\n is bigger then the degree of the polynomial, the function returns a zero coefficient. We require \nn \\geq 0\n. \n\n\nsetcoeff!{T \n: RingElem}(a::PolyElem{T}, n::Int, c::T)\n\n\n\n\nSet the coefficient of the degree \nn\n term of the given polynomial to the given value \na\n. The polynomial is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.\n\n\ndeepcopy(a::PolyElem)\n\n\n\n\nConstruct a copy of the given polynomial and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo polynomials are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::PolyElem, a::PolyElem, b::PolyElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing polynomial \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::PolyElem, a::PolyElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a polynomial ring, the following coercion functions are provided to coerce various elements into the polynomial ring. Developers provide these by overloading the \ncall\n operator for the polynomial parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the ring \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the polynomial ring \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(A::Array{T, 1})\n\n\n\n\nTake an array of elements in the base ring, of type \nT\n and construct the polynomial with those coefficients, starting with the constant coefficient.\n\n\nS(f::PolyElem)\n\n\n\n\nTake a polynomial that is already in the ring \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the polynomial ring. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom polynomials must ensure the parent object of a polynomial type constains a field \nbase_ring\n specifying the base ring, a field \nS\n containing a symbol (not a string) representing the variable name of the polynomial ring. They must also ensure that each polynomial element contains a field \nparent\n specifying the parent object of the polynomial.\n\n\nTypically a developer will also overload the \nPolynomialRing\n generic function to create polynomials of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(R::PolyRing)\n\n\n\n\n\n\nReturn the base ring of the given polynomial ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::PolyElem)\n\n\n\n\n\n\nReturn the base ring of the polynomial ring of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::PolyElem)\n\n\n\n\n\n\nReturn the parent of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nBase.var\n \n \nMethod\n.\n\n\nvar(a::PolyRing)\n\n\n\n\n\n\nReturn the internal name of the generator of the polynomial ring. Note that this is returned as a \nSymbol\n not a \nString\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.degree\n \n \nMethod\n.\n\n\ndegree(a::PolyElem)\n\n\n\n\n\n\nReturn the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus{T \n: ResElem}(a::PolyElem{T})\n\n\n\n\n\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lead\n \n \nMethod\n.\n\n\nlead(x::PolyElem)\n\n\n\n\n\n\nReturn the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is zero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is the constant polynomial \n1\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isgen\n \n \nMethod\n.\n\n\nisgen(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is the constant generator of its polynomial ring, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given polynomial is a unit in its polynomial ring, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.den\n \n \nMethod\n.\n\n\nden(a::fmpq_poly)\n\n\n\n\n\n\nReturn the least common denominator of the coefficients of the polynomial \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(QQ, \nz\n)\n\na = zero(S)\nb = one(S)\n\nc = ZZ(1)//2*z^2 + ZZ(1)//3\nd = x*y^2 + (x + 1)*y + 3\n\nU = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)\n\nf = lead(d)\n\ng = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo polynomials. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x)\n\n\n\n\nUnary minus operator.\n\n\nsource\n\n\n-(a::PolyElem)\n\n\n\n\n\n\nReturn \n-a\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\nThe following ad hoc operators are also provided.\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::Integer, b::PolyElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::fmpz, b::PolyElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::Integer, b::PolyElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::fmpz, b::PolyElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::Integer, b::PolyElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::fmpz, b::PolyElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\n#\n\n\nBase.^\n \n \nMethod\n.\n\n\n^(x, y)\n\n\n\n\nExponentiation operator.\n\n\nsource\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on polynomials.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for polynomials in Nemo.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::PolyElem{T}, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n. Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::PolyElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::T, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \n \nMethod\n.\n\n\nisequal{T \n: RingElem}(x::PolyElem{T}, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n exactly, otherwise return \nfalse\n. This function is useful in cases where the coefficients of the polynomial are inexact, e.g. power series. Only if the power series are precisely the same, to the same precision, are they declared equal by this function.\n\n\n\n\nsource\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::PolyElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::T, y::PolyElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::PolyElem, y::Integer)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::Integer, y::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::PolyElem, y::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::fmpz, y::PolyElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of comparisons.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)\n\n\n\n\n\n\nTruncation\n\n\n#\n\n\nBase.truncate\n \n \nMethod\n.\n\n\ntruncate(a::PolyElem, n::Int)\n\n\n\n\n\n\nReturn \na\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.mullow\n \n \nMethod\n.\n\n\nmullow{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T}, n::Int)\n\n\n\n\n\n\nReturn \na\\times b\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\nHere are some examples of truncated operations.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)\n\n\n\n\n\n\nReversal\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(x::PolyElem, len::Int)\n\n\n\n\n\n\nReturn the reverse of the polynomial \nx\n, thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length).  The resulting polynomial is normalised. If \nlen\n is negative we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nMethod\n.\n\n\nreverse(x::PolyElem)\n\n\n\n\n\n\nReturn the reverse of the polynomial \nx\n, i.e. the leading coefficient of \nx\n becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.\n\n\n\n\nsource\n\n\nHere are some examples of reversal.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nNemo.shift_left\n \n \nMethod\n.\n\n\nshift_left(x::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted left by \nn\n terms, i.e. multiplied by \nx^n\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.shift_right\n \n \nMethod\n.\n\n\nshift_right(f::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted right by \nn\n terms, i.e. divided by \nx^n\n.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)\n\n\n\n\n\n\nModulo arithmetic\n\n\nFor polynomials over a field or residue ring, we can reduce modulo a given polynomial. This isn't always well-defined in the case of a residue ring, but when it is well-defined, we obtain the correct result. If Nemo encounters an impossible inverse, an exception will be raised.\n\n\n#\n\n\nNemo.mulmod\n \n \nMethod\n.\n\n\nmulmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T}, d::PolyElem{T})\n\n\n\n\n\n\nReturn \na\\times b \\pmod{d}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::Int, d::PolyElem{T})\n\n\n\n\n\n\nReturn \na^b \\pmod{d}\n. There are no restrictions on \nb\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.powmod\n \n \nMethod\n.\n\n\npowmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \nx^e \\pmod{y}\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.invmod\n \n \nMethod\n.\n\n\ninvmod{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na^{-1} \\pmod{d}\n.\n\n\n\n\nsource\n\n\nHere are some examples of modular arithmetic.\n\n\nR, x = PolynomialRing(QQ, \nx\n)\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S, \ny\n)\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)\n\n\n\n\n\n\nEuclidean division\n\n\nFor polynomials over a field, we have a euclidean domain, and in many cases for polynomials over a residue ring things behave as though we had a euclidean domain so long as we don't hit an impossible inverse. For such rings we define euclidean division of polynomials. If an impossible inverse is hit, we raise an exception.\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod{T \n: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn \nf \\pmod{g}\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.divrem\n \n \nMethod\n.\n\n\ndivrem{T \n: Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(q, r)\n such that \nf = qg + r\n where \nq\n is the euclidean quotient of \nf\n by \ng\n.\n\n\n\n\nsource\n\n\nHere are some examples of euclidean division.\n\n\nR = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T, \ny\n)\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)\n\n\n\n\n\n\nPseudodivision\n\n\nGiven two polynomials \na, b\n, pseudodivision computes polynomials \nq\n and \nr\n with length\n(r) <\n length\n(b)\n such that \nL^d a = bq + r,\n where \nd =\n length\n(a) -\n length\n(b) + 1\n and \nL\n is the leading coefficient of \nb\n.\n\n\nWe call \nq\n the pseudoquotient and \nr\n the pseudoremainder.\n\n\n#\n\n\nNemo.pseudorem\n \n \nMethod\n.\n\n\npseudorem{T \n: RingElem}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn the pseudoremainder of \na\n divided by \nb\n. If \nb = 0\n we throw a  \nDivideError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.pseudodivrem\n \n \nMethod\n.\n\n\npseudodivrem{T \n: RingElem}(f::PolyElem{T}, g::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(q, r)\n consisting of the pseudoquotient and pseudoremainder  of \na\n divided by \nb\n. If \nb = 0\n we throw a \nDivideError()\n.\n\n\n\n\nsource\n\n\nHere are some examples of pseudodivision.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)\n\n\n\n\n\n\nContent, primitive part, GCD and LCM\n\n\nIn Nemo, we allow computation of the greatest common divisor of polynomials over any ring. This is enabled by making use of pseudoremainders when we aren't working over a euclidean domain or something mimicking such a domain. In certain cases this allows us to return a greatest common divisor when it otherwise wouldn't be possible. However, a greatest common divisor is not necessarily unique, or even well-defined.\n\n\nIf an impossible inverse is encountered whilst computing the greatest common divisor, an exception is thrown.\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a greatest common divisor of \na\n and \nb\n if it exists.\n\n\n\n\nsource\n\n\n#\n\n\nBase.lcm\n \n \nMethod\n.\n\n\nlcm{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a least common multiple of \na\n and \nb\n if it exists.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.content\n \n \nMethod\n.\n\n\ncontent(a::PolyElem)\n\n\n\n\n\n\nReturn the content of \na\n, i.e. the greatest common divisor of its coefficients.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.primpart\n \n \nMethod\n.\n\n\nprimpart(a::PolyElem)\n\n\n\n\n\n\nReturn the primitive part of \na\n, i.e. the polynomial divided by its content.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcdx\n \n \nMethod\n.\n\n\ngcdx{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(r, s, t)\n such that \nr\n is the resultant of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.gcdx\n \n \nMethod\n.\n\n\ngcdx{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(r, s, t)\n such that \nr\n is the resultant of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\ngcdx{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(g, s, t)\n such that \ng\n is the greatest common divisor of \na\n and \nb\n and such that \nr = a\\times s + b\\times t\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gcdinv\n \n \nMethod\n.\n\n\ngcdinv{T \n: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn a tuple \n(g, s)\n such that \ng\n is the greatest common divisor of \na\n and \nb\n and such that \ns = a^{-1} \\pmod{b}\n. This function is useful for inverting modulo a polynomial and checking that it really was invertible.\n\n\n\n\nsource\n\n\nHere are some examples of content, primitive part and GCD.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nk = x*y^2 + (x + 1)*y + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1\n\nn = content(k)\np = primpart(k*(x^2 + 1))\nq = gcd(k*m, l*m)\nr = lcm(k*m, l*m)\n\nR, x = PolynomialRing(QQ, \nx\n)\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T, \nz\n)\n\ng = z^3 + 2z + 1\nh = z^5 + 1\n\nr, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)\n\n\n\n\n\n\nEvaluation, composition and substitution\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate(a::PolyElem, b::Integer)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.evaluate\n \n \nMethod\n.\n\n\nevaluate(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nEvaluate the polynomial \na\n at the value \nb\n and return the result.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.compose\n \n \nMethod\n.\n\n\ncompose(a::PolyElem, b::PolyElem)\n\n\n\n\n\n\nCompose the polynomial \na\n with the polynomial \nb\n and return the result, i.e. return \na\\circ b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.subst\n \n \nMethod\n.\n\n\nsubst{T \n: RingElem}(f::PolyElem{T}, a::Any)\n\n\n\n\n\n\nEvaluate the polynomial \nf\n at \na\n. Note that \na\n can be anything, whether a ring element or not.\n\n\n\n\nsource\n\n\nWe also overload the functional notation so that the polynomial \nf\n can be evaluated at \na\n by writing \nf(a)\n. This feature is only available with  Julia 0.5 however.\n\n\nHere are some examples of polynomial evaluation, composition and substitution.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nM = R[x + 1 2x; x - 3 2x - 1]\n\nh = evaluate(f, 3)\nk = evaluate(f, x^2 + 2x + 1)\nm = compose(f, g)\nn = subst(f, M)\np = f(M)\nk = f(23)\n\n\n\n\n\n\nDerivative and integral\n\n\n#\n\n\nNemo.derivative\n \n \nMethod\n.\n\n\nderivative(a::PolyElem)\n\n\n\n\n\n\nReturn the derivative of the polynomial \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.integral\n \n \nMethod\n.\n\n\nintegral{T \n: Union{ResElem, FieldElem}}(x::PolyElem{T})\n\n\n\n\n\n\nReturn the integral of the polynomial \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of integral and derivative.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\nT, z = PolynomialRing(QQ, \nz\n)\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U, \nw\n)\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)   \n\n\n\n\n\n\nResultant and discriminant\n\n\n#\n\n\nNemo.resultant\n \n \nMethod\n.\n\n\nresultant{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn the resultant of the \na\n and \nb\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.discriminant\n \n \nMethod\n.\n\n\ndiscriminant(a::PolyElem)\n\n\n\n\n\n\nReturn the discrimnant of the given polynomial.\n\n\n\n\nsource\n\n\nHere are some examples of computing the resultant and discriminant.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)\n\n\n\n\n\n\nNewton representation\n\n\n#\n\n\nNemo.monomial_to_newton!\n \n \nMethod\n.\n\n\nmonomial_to_newton!{T \n: RingElem}(P::Array{T, 1}, roots::Array{T, 1})\n\n\n\n\n\n\nConverts a polynomial \np\n, given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots \nr_0, r_1, \\ldots, r_{n-2}\n. In other words, this determines output coefficients \nc_i\n such that \nc_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})\n is equal to the input polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.newton_to_monomial!\n \n \nMethod\n.\n\n\nnewton_to_monomial!{T \n: RingElem}(P::Array{T, 1}, roots::Array{T, 1})\n\n\n\n\n\n\nConverts a polynomial \np\n, given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots \nr_0, r_1, \\ldots, r_{n-2}\n to the standard monomial basis. In other words, this evaluates \nc_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})\n where \nc_i\n are the input coefficients given by \np\n.\n\n\n\n\nsource\n\n\nHere are some examples of conversion to and from Newton representation.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)\n\n\n\n\n\n\nInterpolation\n\n\n#\n\n\nNemo.interpolate\n \n \nMethod\n.\n\n\ninterpolate{T \n: RingElem}(S::PolyRing, x::Array{T, 1}, y::Array{T, 1})\n\n\n\n\n\n\nGiven two arrays of values \nxs\n and \nys\n of the same length \nn\n, find the polynomial \nf\n in the polynomial ring \nR\n of length at most \nn\n such that \nf\n has the value \nys\n at the points \nxs\n. The values in the arrays \nxs\n and \nys\n must belong to the base ring of the polynomial ring \nR\n.\n\n\n\n\nsource\n\n\nHere is an example of interpolation.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nxs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]\n\nf = interpolate(S, xs, ys)\n\n\n\n\n\n\nSignature\n\n\nSignature is only available for certain coefficient rings.\n\n\n#\n\n\nNemo.signature\n \n \nMethod\n.\n\n\nsignature(f::fmpz_poly)\n\n\n\n\n\n\nReturn the signature of the polynomial \nf\n, i.e. a tuple \n(r, s)\n such that \nr\n is the number of real roots of \nf\n and \ns\n is half the number of complex roots.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.signature\n \n \nMethod\n.\n\n\nsignature(f::fmpq_poly)\n\n\n\n\n\n\nReturn the signature of \nf\n, i.e. a tuple \n(r, s)\n where \nr\n is the number of real roots of \nf\n and \ns\n is half the number of complex roots.\n\n\n\n\nsource\n\n\nHere is an example of signature.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)\n\n\n\n\n\n\nLifting\n\n\nWhen working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from \n\\mathbb{Z}/n\\mathbb{Z}\n to \n\\mathbb{Z}\n.\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nfunction lift(R::FmpzPolyRing, y::nmod_poly)\n\n\n\n\n\n\nLift from a polynomial over \n\\mathbb{Z}/n\\mathbb{Z}\n to a polynomial over \n\\mathbb{Z}\n with minimal reduced nonnegative coefficients. The ring \nR\n specifies the ring to lift into.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.lift\n \n \nMethod\n.\n\n\nfunction lift(R::FmpzPolyRing, y::fmpz_mod_poly)\n\n\n\n\n\n\nLift from a polynomial over \n\\mathbb{Z}/n\\mathbb{Z}\n to a polynomial over \n\\mathbb{Z}\n with minimal reduced nonnegative coefficients. The ring \nR\n specifies the ring to lift into.\n\n\n\n\nsource\n\n\nHere is an example of lifting.\n\n\nR = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R, \nx\n)\nT, y = PolynomialRing(ZZ, \ny\n)\n\nf = x^2 + 2x + 1\n\na = lift(T, f)\n\n\n\n\n\n\nFactorisation\n\n\nPolynomials can only be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.\n\n\n#\n\n\nNemo.isirreducible\n \n \nMethod\n.\n\n\nisirreducible(x::nmod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is irreducible, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isirreducible\n \n \nMethod\n.\n\n\nisirreducible(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is irreducible, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issquarefree\n \n \nMethod\n.\n\n\nissquarefree(x::nmod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is squarefree, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.issquarefree\n \n \nMethod\n.\n\n\nissquarefree(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn \ntrue\n if \nx\n is squarefree, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.factor\n \n \nMethod\n.\n\n\nfactor(x::nmod_poly)\n\n\n\n\n\n\nReturn the factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.factor\n \n \nMethod\n.\n\n\nfactor(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_squarefree\n \n \nMethod\n.\n\n\nfactor_squarefree(x::nmod_poly)\n\n\n\n\n\n\nReturn the squarefree factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_squarefree\n \n \nMethod\n.\n\n\nfactor_squarefree(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the squarefree factorisation of \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_distinct_deg\n \n \nMethod\n.\n\n\nfactor_distinct_deg(x::nmod_poly)\n\n\n\n\n\n\nReturn the distinct degree factorisation of a squarefree polynomial \nx\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.factor_distinct_deg\n \n \nMethod\n.\n\n\nfactor_distinct_deg(x::fmpz_mod_poly)\n\n\n\n\n\n\nReturn the distinct degree factorisation of a squarefree polynomial \nx\n.\n\n\n\n\nsource\n\n\nHere are some examples of factorisation.\n\n\nR = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R, \nx\n)\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))\n\n\n\n\n\n\nSpecial functions\n\n\nThe following special functions can be computed for any polynomial ring. Typically one uses the generator \nx\n of a polynomial ring to get the respective special polynomials expressed in terms of that generator.\n\n\n#\n\n\nNemo.chebyshev_t\n \n \nMethod\n.\n\n\nchebyshev_t(n::Int, x::PolyElem)\n\n\n\n\n\n\nReturn the Chebyshev polynomial of the first kind \nT_n(x)\n, defined by  \nT_n(x) = \\cos(n \\cos^{-1}(x))\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.chebyshev_u\n \n \nMethod\n.\n\n\nchebyshev_u(n::Int, x::PolyElem)\n\n\n\n\n\n\nReturn the Chebyshev polynomial of the first kind \nU_n(x)\n, defined by  \n(n+1) U_n(x) = T'_{n+1}(x)\n.\n\n\n\n\nsource\n\n\nThe following special polynomials are only available for certain base rings.\n\n\n#\n\n\nNemo.cyclotomic\n \n \nMethod\n.\n\n\ncyclotomic(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nn\nth cyclotomic polynomial, defined as \n\\Phi_n(x) = \\prod_{\\omega} (x-\\omega),\n where \n\\omega\n runs over all the  \nn\nth primitive roots of unity.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.swinnerton_dyer\n \n \nMethod\n.\n\n\nswinnerton_dyer(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the Swinnerton-Dyer polynomial \nS_n\n, defined as the integer  polynomial \nS_n = \\prod (x \\pm \\sqrt{2} \\pm \\sqrt{3} \\pm \\sqrt{5} \\pm \\ldots \\pm \\sqrt{p_n})\n  where \np_n\n denotes the \nn\n-th prime number and all combinations of signs are taken. This polynomial has degree \n2^n\n and is irreducible over the integers (it is the minimal polynomial of \n\\sqrt{2} + \\ldots + \\sqrt{p_n}\n).\n\n\n\n\nsource\n\n\n#\n\n\nNemo.cos_minpoly\n \n \nMethod\n.\n\n\ncos_minpoly(n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the minimal polynomial of \n2 \\cos(2 \\pi / n)\n. For suitable choice of  \nn\n, this gives the minimal polynomial of \n2 \\cos(a \\pi)\n or \n2 \\sin(a \\pi)\n for any rational \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.theta_qexp\n \n \nMethod\n.\n\n\ntheta_qexp(e::Int, n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nq\n-expansion to length \nn\n of the Jacobi theta function raised to the power \nr\n, i.e. \n\\vartheta(q)^r\n where  \n\\vartheta(q) = 1 + \\sum_{k=1}^{\\infty} q^{k^2}\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.eta_qexp\n \n \nMethod\n.\n\n\neta_qexp(e::Int, n::Int, x::fmpz_poly)\n\n\n\n\n\n\nReturn the \nq\n-expansion to length \nn\n of the Dedekind eta function (without  the leading factor \nq^{1/24}\n) raised to the power \nr\n, i.e. \n(q^{-1/24} \\eta(q))^r = \\prod_{k=1}^{\\infty} (1 - q^k)^r\n. In particular, \nr = -1\n gives the generating function of the partition function \np(k)\n, and \nr = 24\n gives, after multiplication by \nq\n, the modular discriminant \n\\Delta(q)\n which generates the Ramanujan tau function \n\\tau(k)\n.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\nR, x = PolynomialRing(ZZ, \nx\n)\nS, y = PolynomialRing(R, \ny\n)\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Univariate polynomials"
        }, 
        {
            "location": "/build/polynomial/#introduction", 
            "text": "Nemo allow the creation of dense, univariate polynomials over any computable ring  R . There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of polynomials over numerous specific rings, usually provided by C/C++ libraries.  The following table shows each of the polynomial types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of polynomial (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenPoly{T}  GenPolyRing{T}     \\mathbb{Z}   Flint  fmpz_poly  FmpzPolyRing     \\mathbb{Z}/n\\mathbb{Z}  (small  n )  Flint  nmod_poly  NmodPolyRing     \\mathbb{Z}/n\\mathbb{Z}  (large  n )  Flint  fmpz_mod_poly  FmpzModPolyRing     \\mathbb{Q}   Flint  fmpq_poly  FmpqPolyRing     \\mathbb{F}_{p^n}  (small  n )  Flint  fq_nmod_poly  FqNmodPolyRing     \\mathbb{F}_{p^n}  (large  n )  Flint  fq_poly  FqPolyRing     The string representation of the variable and the base ring  R  of a generic polynomial is stored in its parent object.   All polynomial element types belong to the abstract type  PolyElem  and all of the polynomial ring types belong to the abstract type  PolyRing . This enables one to write generic functions that can accept any Nemo polynomial type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/build/polynomial/#polynomial-ring-constructors", 
            "text": "In order to construct polynomials in Nemo, one must first construct the polynomial ring itself. This is accomplished with the following constructor.  #  Nemo.PolynomialRing     Method .  PolynomialRing(R::Ring, s::AbstractString{}; cached::Bool = true)   Given a base ring  R  and string  s  specifying how the generator (variable) should be printed, return a tuple  S, x  representing the new polynomial ring  S = R[x]  and the generator  x  of the ring. By default the parent object  S  will depend only on  R  and  x  and will be cached. Setting the optional argument  cached  to  false  will prevent the parent object  S  from being cached.   source  A shorthand version of this function is provided: given a base ring  R , we abbreviate the constructor as follows.  R[ x ]  Here are some examples of creating polynomial rings and making use of the resulting parent objects to coerce various elements into the polynomial ring.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = QQ[ z ]\n\nf = R()\ng = R(123)\nh = S(ZZ(1234))\nk = S(x + 1)\nm = T(z + 1)", 
            "title": "Polynomial ring constructors"
        }, 
        {
            "location": "/build/polynomial/#polynomial-element-constructors", 
            "text": "Once a polynomial ring is constructed, there are various ways to construct polynomials in that ring.  The easiest way is simply using the generator returned by the  PolynomialRing  constructor and and build up the polynomial using basic arithmetic. Julia has quite flexible notation for the construction of polynomials in this way.  In addition we provide the following functions for constructing certain useful polynomials.  #  Base.zero     Method .  zero(R::PolyRing)   Return the zero polynomial in the given polynomial ring.   source  #  Base.one     Method .  one(R::PolyRing)   Return the constant polynomial  1  in the given polynomial ring.   source  #  Nemo.gen     Method .  gen(R::PolyRing)   Return the generator of the given polynomial ring.   source  Here are some examples of constructing polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x^3 + 3x + 21\ng = (x + 1)*y^2 + 2x + 1\n\nh = zero(S)\nk = one(R)\nm = gen(S)", 
            "title": "Polynomial element constructors"
        }, 
        {
            "location": "/build/polynomial/#basic-functionality", 
            "text": "All univariate polynomial modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own polynomial module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom univariate polynomial types in Nemo.   We write  U  for the type of the polynomials in the polynomial ring and  T  for the type of elements of the coefficient ring.  All of these functions are provided for all existing polynomial types in Nemo.  parent_type{U  : PolyElem}(::Type{U})  Given the type of polynomial elements, should return the type of the corresponding parent object.  elem_type(R::PolyRing)  Given a parent object for the polynomial ring, return the type of elements of the polynomial ring.  Base.hash(a::PolyElem, h::UInt)  Return a  UInt  hexadecimal hash of the polynomial  a . This should be xor'd with a fixed random hexadecimal specific to the polynomial type. The hash of each coefficient should be xor'd with the supplied parameter  h  as part of computing the hash.  fit!(a::PolyElem, n::Int)  By reallocating if necessary, ensure that the given polynomial has space for at least  n  coefficients. This function does not change the length of the polynomial and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.  normalise(a::PolyElem, n::Int)  Return the normalised length of the given polynomial, assuming its current length is  n . Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the polynomial. That can be done with a subsequent call to  set_length!  using the length returned by  normalise .  set_length!(a::PolyElem, n::Int)  Set the length of an existing polynomial that has sufficient space allocated, i.e. a polynomial for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial type has a field,  length , which corresponds to the current length of the polynomial, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.  length(a::PolyElem)  Return the current length (not the number of allocated coefficients), of the given polynomial. Note that this function only needs to be provided by a developer for a custom polynomial type if the Julia type definition for polynomial elements doesn't contain a field  length  corresponding to the current length of the polynomial. Otherwise the supplied generic implementation will work.  coeff(a::PolyElem, n::Int)  Return the degree  n  coefficient of the given polynomial. Note coefficients are numbered from  n = 0  for the constant coefficient. If  n  is bigger then the degree of the polynomial, the function returns a zero coefficient. We require  n \\geq 0 .   setcoeff!{T  : RingElem}(a::PolyElem{T}, n::Int, c::T)  Set the coefficient of the degree  n  term of the given polynomial to the given value  a . The polynomial is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.  deepcopy(a::PolyElem)  Construct a copy of the given polynomial and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo polynomials are mutable and so returning shallow copies is not sufficient.  mul!(c::PolyElem, a::PolyElem, b::PolyElem)  Multiply  a  by  b  and set the existing polynomial  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::PolyElem, a::PolyElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a polynomial ring, the following coercion functions are provided to coerce various elements into the polynomial ring. Developers provide these by overloading the  call  operator for the polynomial parent objects.  S()  Coerce zero into the ring  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the polynomial ring  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(A::Array{T, 1})  Take an array of elements in the base ring, of type  T  and construct the polynomial with those coefficients, starting with the constant coefficient.  S(f::PolyElem)  Take a polynomial that is already in the ring  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the polynomial ring. This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom polynomials must ensure the parent object of a polynomial type constains a field  base_ring  specifying the base ring, a field  S  containing a symbol (not a string) representing the variable name of the polynomial ring. They must also ensure that each polynomial element contains a field  parent  specifying the parent object of the polynomial.  Typically a developer will also overload the  PolynomialRing  generic function to create polynomials of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/build/polynomial/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(R::PolyRing)   Return the base ring of the given polynomial ring.   source  #  Nemo.base_ring     Method .  base_ring(a::PolyElem)   Return the base ring of the polynomial ring of the given polynomial.   source  #  Base.parent     Method .  parent(a::PolyElem)   Return the parent of the given polynomial.   source  #  Base.var     Method .  var(a::PolyRing)   Return the internal name of the generator of the polynomial ring. Note that this is returned as a  Symbol  not a  String .   source  #  Nemo.degree     Method .  degree(a::PolyElem)   Return the degree of the given polynomial. This is defined to be one less than the length, even for constant polynomials.   source  #  Nemo.modulus     Method .  modulus{T  : ResElem}(a::PolyElem{T})   Return the modulus of the coefficients of the given polynomial.   source  #  Nemo.lead     Method .  lead(x::PolyElem)   Return the leading coefficient of the given polynomial. This will be the nonzero coefficient of the term with highest degree unless the polynomial in the zero polynomial, in which case a zero coefficient is returned.   source  #  Nemo.iszero     Method .  iszero(a::PolyElem)   Return  true  if the given polynomial is zero, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::PolyElem)   Return  true  if the given polynomial is the constant polynomial  1 , otherwise return  false .   source  #  Nemo.isgen     Method .  isgen(a::PolyElem)   Return  true  if the given polynomial is the constant generator of its polynomial ring, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::PolyElem)   Return  true  if the given polynomial is a unit in its polynomial ring, otherwise return  false .   source  #  Base.den     Method .  den(a::fmpq_poly)   Return the least common denominator of the coefficients of the polynomial  a .   source  Here are some examples of basic manipulation of polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(QQ,  z )\n\na = zero(S)\nb = one(S)\n\nc = ZZ(1)//2*z^2 + ZZ(1)//3\nd = x*y^2 + (x + 1)*y + 3\n\nU = base_ring(S)\nV = base_ring(y + 1)\nv = var(S)\nT = parent(y + 1)\n\nf = lead(d)\n\ng = isgen(y)\nh = isone(b)\nk = iszero(a)\nm = isunit(b)\nn = degree(d)\np = length(b)\nq = den(c)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/build/polynomial/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo polynomials. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  #  Base.-     Method .  -(x)  Unary minus operator.  source  -(a::PolyElem)   Return  -a .   source  #  Base.+     Method .  +{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a + b .   source  +{T  : RingElem}(a::T, b::PolyElem{T})   Return  a + b .   source  +{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a - b .   source  -{T  : RingElem}(a::T, b::PolyElem{T})   Return  a - b .   source  -{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::T, b::PolyElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  The following ad hoc operators are also provided.  #  Base.+     Method .  +(a::Integer, b::PolyElem)   Return  a + b .   source  #  Base.+     Method .  +(a::PolyElem, b::Integer)   Return  a + b .   source  #  Base.+     Method .  +(a::fmpz, b::PolyElem)   Return  a + b .   source  #  Base.+     Method .  +(a::PolyElem, b::fmpz)   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::T, b::PolyElem{T})   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::Integer, b::PolyElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::PolyElem, b::Integer)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::fmpz, b::PolyElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::PolyElem, b::fmpz)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::T, b::PolyElem{T})   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::Integer, b::PolyElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::PolyElem, b::Integer)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::fmpz, b::PolyElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::PolyElem, b::fmpz)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::T, b::PolyElem{T})   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact(a::PolyElem, b::Integer)   Return  a/b  where the quotient is expected to be exact.   source  #  Nemo.divexact     Method .  divexact(a::PolyElem, b::fmpz)   Return  a/b  where the quotient is expected to be exact.   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  #  Base.^     Method .  ^(x, y)  Exponentiation operator.  source  If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on polynomials.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = f - g\nk = f*g\nm = f + g\nn = g - 4\np = fmpz(5) - g\nq = f*7\nr = divexact(f, -1)\ns = divexact(g*(x + 1), x + 1)\nt = f^3", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/build/polynomial/#comparison-operators", 
            "text": "The following comparison operators are implemented for polynomials in Nemo.  #  Base.==     Method .  =={T  : RingElem}(x::PolyElem{T}, y::PolyElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false . Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.   source  =={T  : RingElem}(x::PolyElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  =={T  : RingElem}(x::T, y::PolyElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.isequal     Method .  isequal{T  : RingElem}(x::PolyElem{T}, y::PolyElem{T})   Return  true  if  x == y  exactly, otherwise return  false . This function is useful in cases where the coefficients of the polynomial are inexact, e.g. power series. Only if the power series are precisely the same, to the same precision, are they declared equal by this function.   source  In addition we have the following ad hoc comparison operators.  #  Base.==     Method .  =={T  : RingElem}(x::PolyElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  =={T  : RingElem}(x::T, y::PolyElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::PolyElem, y::Integer)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::Integer, y::PolyElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::PolyElem, y::fmpz)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::fmpz, y::PolyElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  Here are some examples of comparisons.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = x*y^2 + (x + 1)*y + 3\nh = S(3)\n\nf == g\nisequal(f, g)\nf != 3\ng != x\nh == fmpz(3)", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/build/polynomial/#truncation", 
            "text": "#  Base.truncate     Method .  truncate(a::PolyElem, n::Int)   Return  a  truncated to  n  terms.   source  #  Nemo.mullow     Method .  mullow{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T}, n::Int)   Return  a\\times b  truncated to  n  terms.   source  Here are some examples of truncated operations.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = truncate(f, 1)\nk = mullow(f, g, 4)", 
            "title": "Truncation"
        }, 
        {
            "location": "/build/polynomial/#reversal", 
            "text": "#  Base.reverse     Method .  reverse(x::PolyElem, len::Int)   Return the reverse of the polynomial  x , thought of as a polynomial of the given length (the polynomial will be notionally truncated or padded with zeroes before the leading term if necessary to match the specified length).  The resulting polynomial is normalised. If  len  is negative we throw a  DomainError() .   source  #  Base.reverse     Method .  reverse(x::PolyElem)   Return the reverse of the polynomial  x , i.e. the leading coefficient of  x  becomes the constant coefficient of the result, etc. The resulting polynomial is normalised.   source  Here are some examples of reversal.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = reverse(f, 7)\nh = reverse(f)", 
            "title": "Reversal"
        }, 
        {
            "location": "/build/polynomial/#shifting", 
            "text": "#  Nemo.shift_left     Method .  shift_left(x::PolyElem, n::Int)   Return the polynomial  f  shifted left by  n  terms, i.e. multiplied by  x^n .   source  #  Nemo.shift_right     Method .  shift_right(f::PolyElem, n::Int)   Return the polynomial  f  shifted right by  n  terms, i.e. divided by  x^n .   source  Here are some examples of shifting.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\n\ng = shift_left(f, 7)\nh = shift_right(f, 2)", 
            "title": "Shifting"
        }, 
        {
            "location": "/build/polynomial/#modulo-arithmetic", 
            "text": "For polynomials over a field or residue ring, we can reduce modulo a given polynomial. This isn't always well-defined in the case of a residue ring, but when it is well-defined, we obtain the correct result. If Nemo encounters an impossible inverse, an exception will be raised.  #  Nemo.mulmod     Method .  mulmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T}, d::PolyElem{T})   Return  a\\times b \\pmod{d} .   source  #  Nemo.powmod     Method .  powmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::Int, d::PolyElem{T})   Return  a^b \\pmod{d} . There are no restrictions on  b .   source  #  Nemo.powmod     Method .  powmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)   Return  x^e \\pmod{y} .   source  #  Base.invmod     Method .  invmod{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return  a^{-1} \\pmod{d} .   source  Here are some examples of modular arithmetic.  R, x = PolynomialRing(QQ,  x )\nS = ResidueRing(R, x^3 + 3x + 1)\nT, y = PolynomialRing(S,  y )\n\nf = (3*x^2 + x + 2)*y + x^2 + 1\ng = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1\nh = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1\n\ninvmod(f, g)\nmulmod(f, g, h)\npowmod(f, 3, h)", 
            "title": "Modulo arithmetic"
        }, 
        {
            "location": "/build/polynomial/#euclidean-division", 
            "text": "For polynomials over a field, we have a euclidean domain, and in many cases for polynomials over a residue ring things behave as though we had a euclidean domain so long as we don't hit an impossible inverse. For such rings we define euclidean division of polynomials. If an impossible inverse is hit, we raise an exception.  #  Base.mod     Method .  mod{T  : Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})   Return  f \\pmod{g} .   source  #  Base.divrem     Method .  divrem{T  : Union{ResElem, FieldElem}}(f::PolyElem{T}, g::PolyElem{T})   Return a tuple  (q, r)  such that  f = qg + r  where  q  is the euclidean quotient of  f  by  g .   source  Here are some examples of euclidean division.  R = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\nU, y = PolynomialRing(T,  y )\n\nf = y^3 + x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y^2 + (x^3 + 2x + 2)\n\nh = mod(f, g)\nq, r = divrem(f, g)", 
            "title": "Euclidean division"
        }, 
        {
            "location": "/build/polynomial/#pseudodivision", 
            "text": "Given two polynomials  a, b , pseudodivision computes polynomials  q  and  r  with length (r) <  length (b)  such that  L^d a = bq + r,  where  d =  length (a) -  length (b) + 1  and  L  is the leading coefficient of  b .  We call  q  the pseudoquotient and  r  the pseudoremainder.  #  Nemo.pseudorem     Method .  pseudorem{T  : RingElem}(f::PolyElem{T}, g::PolyElem{T})   Return the pseudoremainder of  a  divided by  b . If  b = 0  we throw a   DivideError() .   source  #  Nemo.pseudodivrem     Method .  pseudodivrem{T  : RingElem}(f::PolyElem{T}, g::PolyElem{T})   Return a tuple  (q, r)  consisting of the pseudoquotient and pseudoremainder  of  a  divided by  b . If  b = 0  we throw a  DivideError() .   source  Here are some examples of pseudodivision.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\n\nh = pseudorem(f, g)\nq, r = pseudodivrem(f, g)", 
            "title": "Pseudodivision"
        }, 
        {
            "location": "/build/polynomial/#content-primitive-part-gcd-and-lcm", 
            "text": "In Nemo, we allow computation of the greatest common divisor of polynomials over any ring. This is enabled by making use of pseudoremainders when we aren't working over a euclidean domain or something mimicking such a domain. In certain cases this allows us to return a greatest common divisor when it otherwise wouldn't be possible. However, a greatest common divisor is not necessarily unique, or even well-defined.  If an impossible inverse is encountered whilst computing the greatest common divisor, an exception is thrown.  #  Base.gcd     Method .  gcd{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a greatest common divisor of  a  and  b  if it exists.   source  #  Base.lcm     Method .  lcm{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a least common multiple of  a  and  b  if it exists.   source  #  Nemo.content     Method .  content(a::PolyElem)   Return the content of  a , i.e. the greatest common divisor of its coefficients.   source  #  Nemo.primpart     Method .  primpart(a::PolyElem)   Return the primitive part of  a , i.e. the polynomial divided by its content.   source  #  Base.gcdx     Method .  gcdx{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (r, s, t)  such that  r  is the resultant of  a  and  b  and such that  r = a\\times s + b\\times t .   source  #  Base.gcdx     Method .  gcdx{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (r, s, t)  such that  r  is the resultant of  a  and  b  and such that  r = a\\times s + b\\times t .   source  gcdx{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (g, s, t)  such that  g  is the greatest common divisor of  a  and  b  and such that  r = a\\times s + b\\times t .   source  #  Nemo.gcdinv     Method .  gcdinv{T  : Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})   Return a tuple  (g, s)  such that  g  is the greatest common divisor of  a  and  b  and such that  s = a^{-1} \\pmod{b} . This function is useful for inverting modulo a polynomial and checking that it really was invertible.   source  Here are some examples of content, primitive part and GCD.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nk = x*y^2 + (x + 1)*y + 3\nl = (x + 1)*y + (x^3 + 2x + 2)\nm = y^2 + x + 1\n\nn = content(k)\np = primpart(k*(x^2 + 1))\nq = gcd(k*m, l*m)\nr = lcm(k*m, l*m)\n\nR, x = PolynomialRing(QQ,  x )\nT = ResidueRing(R, x^3 + 3x + 1)\nU, z = PolynomialRing(T,  z )\n\ng = z^3 + 2z + 1\nh = z^5 + 1\n\nr, s, t = gcdx(g, h)\nu, v = gcdinv(g, h)", 
            "title": "Content, primitive part, GCD and LCM"
        }, 
        {
            "location": "/build/polynomial/#evaluation-composition-and-substitution", 
            "text": "#  Nemo.evaluate     Method .  evaluate{T  : RingElem}(a::PolyElem{T}, b::T)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.evaluate     Method .  evaluate(a::PolyElem, b::Integer)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.evaluate     Method .  evaluate(a::PolyElem, b::fmpz)   Evaluate the polynomial  a  at the value  b  and return the result.   source  #  Nemo.compose     Method .  compose(a::PolyElem, b::PolyElem)   Compose the polynomial  a  with the polynomial  b  and return the result, i.e. return  a\\circ b .   source  #  Nemo.subst     Method .  subst{T  : RingElem}(f::PolyElem{T}, a::Any)   Evaluate the polynomial  f  at  a . Note that  a  can be anything, whether a ring element or not.   source  We also overload the functional notation so that the polynomial  f  can be evaluated at  a  by writing  f(a) . This feature is only available with  Julia 0.5 however.  Here are some examples of polynomial evaluation, composition and substitution.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (x + 1)*y + (x^3 + 2x + 2)\nM = R[x + 1 2x; x - 3 2x - 1]\n\nh = evaluate(f, 3)\nk = evaluate(f, x^2 + 2x + 1)\nm = compose(f, g)\nn = subst(f, M)\np = f(M)\nk = f(23)", 
            "title": "Evaluation, composition and substitution"
        }, 
        {
            "location": "/build/polynomial/#derivative-and-integral", 
            "text": "#  Nemo.derivative     Method .  derivative(a::PolyElem)   Return the derivative of the polynomial  a .   source  #  Nemo.integral     Method .  integral{T  : Union{ResElem, FieldElem}}(x::PolyElem{T})   Return the integral of the polynomial  a .   source  Here are some examples of integral and derivative.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\nT, z = PolynomialRing(QQ,  z )\nU = ResidueRing(T, z^3 + 3z + 1)\nV, w = PolynomialRing(U,  w )\n\nf = x*y^2 + (x + 1)*y + 3\ng = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4\n\nh = derivative(f)\nk = integral(g)", 
            "title": "Derivative and integral"
        }, 
        {
            "location": "/build/polynomial/#resultant-and-discriminant", 
            "text": "#  Nemo.resultant     Method .  resultant{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return the resultant of the  a  and  b .   source  #  Nemo.discriminant     Method .  discriminant(a::PolyElem)   Return the discrimnant of the given polynomial.   source  Here are some examples of computing the resultant and discriminant.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = 6(x + 1)*y + (x^3 + 2x + 2)\n\nh = resultant(f, g)\nk = discriminant(f)", 
            "title": "Resultant and discriminant"
        }, 
        {
            "location": "/build/polynomial/#newton-representation", 
            "text": "#  Nemo.monomial_to_newton!     Method .  monomial_to_newton!{T  : RingElem}(P::Array{T, 1}, roots::Array{T, 1})   Converts a polynomial  p , given as an array of coefficients, in-place from its coefficients given in the standard monomial basis to the Newton basis for the roots  r_0, r_1, \\ldots, r_{n-2} . In other words, this determines output coefficients  c_i  such that  c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})  is equal to the input polynomial.   source  #  Nemo.newton_to_monomial!     Method .  newton_to_monomial!{T  : RingElem}(P::Array{T, 1}, roots::Array{T, 1})   Converts a polynomial  p , given as an array of coefficients, in-place from its coefficients given in the Newton basis for the roots  r_0, r_1, \\ldots, r_{n-2}  to the standard monomial basis. In other words, this evaluates  c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \\ldots + c_{n-1}(x-r_0)(x-r_1)\\cdots(x-r_{n-2})  where  c_i  are the input coefficients given by  p .   source  Here are some examples of conversion to and from Newton representation.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = 3x*y^2 + (x + 1)*y + 3\ng = deepcopy(f)\nroots = [R(1), R(2), R(3)]\n\nmonomial_to_newton!(g.coeffs, roots)\nnewton_to_monomial!(g.coeffs, roots)", 
            "title": "Newton representation"
        }, 
        {
            "location": "/build/polynomial/#interpolation", 
            "text": "#  Nemo.interpolate     Method .  interpolate{T  : RingElem}(S::PolyRing, x::Array{T, 1}, y::Array{T, 1})   Given two arrays of values  xs  and  ys  of the same length  n , find the polynomial  f  in the polynomial ring  R  of length at most  n  such that  f  has the value  ys  at the points  xs . The values in the arrays  xs  and  ys  must belong to the base ring of the polynomial ring  R .   source  Here is an example of interpolation.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nxs = [R(1), R(2), R(3), R(4)]\nys = [R(1), R(4), R(9), R(16)]\n\nf = interpolate(S, xs, ys)", 
            "title": "Interpolation"
        }, 
        {
            "location": "/build/polynomial/#signature", 
            "text": "Signature is only available for certain coefficient rings.  #  Nemo.signature     Method .  signature(f::fmpz_poly)   Return the signature of the polynomial  f , i.e. a tuple  (r, s)  such that  r  is the number of real roots of  f  and  s  is half the number of complex roots.   source  #  Nemo.signature     Method .  signature(f::fmpq_poly)   Return the signature of  f , i.e. a tuple  (r, s)  where  r  is the number of real roots of  f  and  s  is half the number of complex roots.   source  Here is an example of signature.  R, x = PolynomialRing(ZZ,  x )\n\nf = x^3 + 3x + 1\n\n(r, s) = signature(f)", 
            "title": "Signature"
        }, 
        {
            "location": "/build/polynomial/#lifting", 
            "text": "When working over a residue ring it is useful to be able to lift to the base ring of the residue ring, e.g. from  \\mathbb{Z}/n\\mathbb{Z}  to  \\mathbb{Z} .  #  Nemo.lift     Method .  function lift(R::FmpzPolyRing, y::nmod_poly)   Lift from a polynomial over  \\mathbb{Z}/n\\mathbb{Z}  to a polynomial over  \\mathbb{Z}  with minimal reduced nonnegative coefficients. The ring  R  specifies the ring to lift into.   source  #  Nemo.lift     Method .  function lift(R::FmpzPolyRing, y::fmpz_mod_poly)   Lift from a polynomial over  \\mathbb{Z}/n\\mathbb{Z}  to a polynomial over  \\mathbb{Z}  with minimal reduced nonnegative coefficients. The ring  R  specifies the ring to lift into.   source  Here is an example of lifting.  R = ResidueRing(ZZ, 123456789012345678949)\nS, x = PolynomialRing(R,  x )\nT, y = PolynomialRing(ZZ,  y )\n\nf = x^2 + 2x + 1\n\na = lift(T, f)", 
            "title": "Lifting"
        }, 
        {
            "location": "/build/polynomial/#factorisation", 
            "text": "Polynomials can only be factorised over certain rings. In general we use the same format for the output as the Julia factorisation function, namely an associative array with polynomial factors as keys and exponents as values.  #  Nemo.isirreducible     Method .  isirreducible(x::nmod_poly)   Return  true  if  x  is irreducible, otherwise return  false .   source  #  Nemo.isirreducible     Method .  isirreducible(x::fmpz_mod_poly)   Return  true  if  x  is irreducible, otherwise return  false .   source  #  Nemo.issquarefree     Method .  issquarefree(x::nmod_poly)   Return  true  if  x  is squarefree, otherwise return  false .   source  #  Nemo.issquarefree     Method .  issquarefree(x::fmpz_mod_poly)   Return  true  if  x  is squarefree, otherwise return  false .   source  #  Base.factor     Method .  factor(x::nmod_poly)   Return the factorisation of  x .   source  #  Base.factor     Method .  factor(x::fmpz_mod_poly)   Return the factorisation of  x .   source  #  Nemo.factor_squarefree     Method .  factor_squarefree(x::nmod_poly)   Return the squarefree factorisation of  x .   source  #  Nemo.factor_squarefree     Method .  factor_squarefree(x::fmpz_mod_poly)   Return the squarefree factorisation of  x .   source  #  Nemo.factor_distinct_deg     Method .  factor_distinct_deg(x::nmod_poly)   Return the distinct degree factorisation of a squarefree polynomial  x .   source  #  Nemo.factor_distinct_deg     Method .  factor_distinct_deg(x::fmpz_mod_poly)   Return the distinct degree factorisation of a squarefree polynomial  x .   source  Here are some examples of factorisation.  R = ResidueRing(ZZ, 23)\nS, x = PolynomialRing(R,  x )\n\nf = x^2 + 2x + 1\ng = x^3 + 3x + 1\n\nR = factor(f*g)\nS = factor_squarefree(f*g)\nT = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))", 
            "title": "Factorisation"
        }, 
        {
            "location": "/build/polynomial/#special-functions", 
            "text": "The following special functions can be computed for any polynomial ring. Typically one uses the generator  x  of a polynomial ring to get the respective special polynomials expressed in terms of that generator.  #  Nemo.chebyshev_t     Method .  chebyshev_t(n::Int, x::PolyElem)   Return the Chebyshev polynomial of the first kind  T_n(x) , defined by   T_n(x) = \\cos(n \\cos^{-1}(x)) .   source  #  Nemo.chebyshev_u     Method .  chebyshev_u(n::Int, x::PolyElem)   Return the Chebyshev polynomial of the first kind  U_n(x) , defined by   (n+1) U_n(x) = T'_{n+1}(x) .   source  The following special polynomials are only available for certain base rings.  #  Nemo.cyclotomic     Method .  cyclotomic(n::Int, x::fmpz_poly)   Return the  n th cyclotomic polynomial, defined as  \\Phi_n(x) = \\prod_{\\omega} (x-\\omega),  where  \\omega  runs over all the   n th primitive roots of unity.   source  #  Nemo.swinnerton_dyer     Method .  swinnerton_dyer(n::Int, x::fmpz_poly)   Return the Swinnerton-Dyer polynomial  S_n , defined as the integer  polynomial  S_n = \\prod (x \\pm \\sqrt{2} \\pm \\sqrt{3} \\pm \\sqrt{5} \\pm \\ldots \\pm \\sqrt{p_n})   where  p_n  denotes the  n -th prime number and all combinations of signs are taken. This polynomial has degree  2^n  and is irreducible over the integers (it is the minimal polynomial of  \\sqrt{2} + \\ldots + \\sqrt{p_n} ).   source  #  Nemo.cos_minpoly     Method .  cos_minpoly(n::Int, x::fmpz_poly)   Return the minimal polynomial of  2 \\cos(2 \\pi / n) . For suitable choice of   n , this gives the minimal polynomial of  2 \\cos(a \\pi)  or  2 \\sin(a \\pi)  for any rational  a .   source  #  Nemo.theta_qexp     Method .  theta_qexp(e::Int, n::Int, x::fmpz_poly)   Return the  q -expansion to length  n  of the Jacobi theta function raised to the power  r , i.e.  \\vartheta(q)^r  where   \\vartheta(q) = 1 + \\sum_{k=1}^{\\infty} q^{k^2} .   source  #  Nemo.eta_qexp     Method .  eta_qexp(e::Int, n::Int, x::fmpz_poly)   Return the  q -expansion to length  n  of the Dedekind eta function (without  the leading factor  q^{1/24} ) raised to the power  r , i.e.  (q^{-1/24} \\eta(q))^r = \\prod_{k=1}^{\\infty} (1 - q^k)^r . In particular,  r = -1  gives the generating function of the partition function  p(k) , and  r = 24  gives, after multiplication by  q , the modular discriminant  \\Delta(q)  which generates the Ramanujan tau function  \\tau(k) .   source  Here are some examples of special functions.  R, x = PolynomialRing(ZZ,  x )\nS, y = PolynomialRing(R,  y )\n\nf = chebyshev_t(20, y)\ng = chebyshev_u(15, y)\nh = cyclotomic(120, x)\nj = swinnerton_dyer(5, x)\nk = cos_minpoly(30, x)\nl = theta_qexp(3, 30, x)\nm = eta_qexp(24, 30, x)\no = cyclotomic(10, 1 + x + x^2)", 
            "title": "Special functions"
        }, 
        {
            "location": "/build/series/", 
            "text": "Introduction\n\n\nNemo allows the creation of capped relative power series over any computable ring \nR\n. These are power series of the form \na_jx^j + a_{j+1}x^{j+1} + \\cdots + a_{k-1}x^{k-1} + O(x^k)\n where \ni \\geq 0\n, \na_i \\in R\n and the relative precision \nk - j\n is at most equal to some specified precision \nn\n.\n\n\nThere are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the relative power series types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenRelSeries{T}\n\n\nGenRelSeriesRing{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_rel_series\n\n\nFmpzRelSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{Z}/n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpz_mod_rel_series\n\n\nFmpzModRelSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{Q}\n\n\n\n\nFlint\n\n\nfmpq_rel_series\n\n\nFmpqRelSerieRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (small \nn\n)\n\n\nFlint\n\n\nfq_nmod_rel_series\n\n\nFqNmodRelSeriesRing\n\n\n\n\n\n\n\n\n\\mathbb{F}_{p^n}\n (large \nn\n)\n\n\nFlint\n\n\nfq_rel_series\n\n\nFqRelSeriesRing\n\n\n\n\n\n\n\n\nThe maximum relative precision, the string representation of the variable and the base ring \nR\n of a generic power series are stored in its parent object. \n\n\nAll power series element types belong to the abstract type \nSeriesElem\n and all of the power series ring types belong to the abstract type \nSeriesRing\n. This enables one to write generic functions that can accept any Nemo power series type.\n\n\n\n\nCapped relative power series\n\n\nCapped relative power series have their maximum relative precision capped at some value \nprec_max\n. This means that if the leading term of a nonzero power series element is \nc_ax^a\n and the precision is \nb\n then the power series is of the form  \nc_ax^a + c_{a+1}x^{a+1} + \\ldots + O(x^{a + b})\n.\n\n\nThe zero power series is simply taken to be \n0 + O(x^b)\n.\n\n\nThe capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series \nf\n and \ng\n we have that \ndivexact(f*g), g) == f\n.\n\n\nHowever, capped relative power series are not additively stable, i.e. we do not always have \n(f + g) - g = f\n.\n\n\nIn the capped relative model we say that two power series are equal if they agree up to the minimum \nabsolute\n precision of the two power series. Thus, for example, \nx^5 + O(x^10) == 0 + O(x^5)\n, since the minimum absolute precision is \n5\n.\n\n\nDuring computations, it is possible for power series to lose relative precision due to cancellation. For example if \nf = x^3 + x^5 + O(x^8)\n and \ng = x^3 + x^6 + O(x^8)\n then \nf - g = x^5 - x^6 + O(x^8)\n which now has relative precision \n3\n instead of relative precision \n5\n.\n\n\nAmongst other things, this means that equality is not transitive. For example \nx^6 + O(x^11) == 0 + O(x^5)\n and \nx^7 + O(x^12) == 0 + O(x^5)\n but \nx^6 + O(x^11) \\neq x^7 + O(x^12)\n.\n\n\nSometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the \nisequal\n function.\n\n\nFor example, if \nf = x^2 + O(x^7)\n and \ng = x^2 + O(x^8)\n and \nh = 0 + O(x^2)\n then \nf == g\n, \nf == h\n and \ng == h\n, but \nisequal(f, g)\n, \nisequal(f, h)\n and \nisequal(g, h)\n would all return \nfalse\n. However, if \nk = x^2 + O(x^7)\n then \nisequal(f, k)\n would return \ntrue\n.\n\n\nThere are further difficulties if we construct polynomial over power series. For example, consider the polynomial in \ny\n over the power series ring in \nx\n over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of \n(0 + O(x^10))y + (1 + O(x^10))\n?\n\n\nIf one takes it to be \n(0 + O(x^10))\n then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.\n\n\nOn the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!\n\n\nOne should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.\n\n\nSimply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!\n\n\n\n\nPower series ring constructors\n\n\nIn order to construct power series in Nemo, one must first construct the power series ring itself. This is accomplished with the following constructor.\n\n\n#\n\n\nNemo.PowerSeriesRing\n \n \nMethod\n.\n\n\nPowerSeriesRing(R::Ring, prec::Int, s::AbstractString{}; cached=true)\n\n\n\n\nReturn a tuple \n(S, x)\n consisting of the parent object \nS\n of a power series ring over the given base ring and a generator \nx\n for the power series ring. The maximum relative precision of power series in the ring is set to \nprec\n. The supplied string \ns\n specifies the way the generator of the power series ring will be printed. By default, the parent object \nS\n will be cached so that supplying the same base ring, string and precision in future will return the same parent object and generator. If caching of the parent object is not required, \ncached\n can be set to \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of creating a power series ring using the constructor and using the resulting parent object to coerce various elements into the power series ring.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = S(x)\nb = S(t + 1)\nc = S(1)\nd = S(ZZ(2))\nf = S()\n\n\n\n\n\n\nPower series element constructors\n\n\nOnce a power series ring is constructed, there are various ways to construct power series in that ring.\n\n\nThe easiest way is simply using the generator returned by the \nPowerSeriesRing\n constructor and and build up the power series using basic arithmetic. The absolute precision of a power series can be set using the following function.\n\n\n#\n\n\nNemo.O\n \n \nMethod\n.\n\n\nO{T}(a::SeriesElem{T})\n\n\n\n\n\n\nReturns \n0 + O(x^\\mbox{deg}(a))\n. Usually this function is called with \nx^n\n as parameter. Then the function returns the power series \n0 + O(x^n)\n, which can be used to set the precision of a power series when constructing it.\n\n\n\n\nsource\n\n\nIn addition we provide the following functions for constructing certain useful polynomials.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::SeriesRing)\n\n\n\n\n\n\nReturn \n0 + O(x^n)\n where \nn\n is the maximum precision of the power series ring \nR\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\nzero(R::SeriesRing)\n\n\n\n\n\n\nReturn \n1 + O(x^n)\n where \nn\n is the maximum precision of the power series ring \nR\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.gen\n \n \nMethod\n.\n\n\nzero(R::SeriesRing)\n\n\n\n\n\n\nReturn the generator of the power series ring, i.e. \nx + O(x^{n + 1})\n where \nn\n is the maximum precision of the power series ring \nR\n.\n\n\n\n\nsource\n\n\nHere are some examples of constructing power series.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = x^3 + 2x + 1\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\nc = zero(S)\nd = one(S)\nf = gen(S)\n\n\n\n\n\n\nBasic functionality\n\n\nAll power series modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own power series module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom power series types in Nemo. \n\n\nWe write \nU\n for the type of the power series in the power series ring and \nT\n for the type of elements of the coefficient ring.\n\n\nAll of these functions are provided for all existing power series types in Nemo.\n\n\nparent_type{U \n: SeriesElem}(::Type{U})\n\n\n\n\nGiven the type of power series elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::SeriesRing)\n\n\n\n\nGiven a parent object for the power series ring, return the type of elements of the power series ring.\n\n\nBase.hash(a::SeriesElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the power series \na\n. This should be xor'd with a fixed random hexadecimal specific to the power series type. The hash of each coefficient should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\nfit!(a::SeriesElem, n::Int)\n\n\n\n\nBy reallocating if necessary, ensure that the polynomial underlying the given power series has space for at least \nn\n coefficients. This function does not change the length of the power series and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.\n\n\nnormalise(a::SeriesElem, n::Int)\n\n\n\n\nReturn the normalised length of the polynomial underlying the given power series, assuming its current length is \nn\n. Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the power series. That can be done with a subsequent call to \nset_length!\n using the length returned by \nnormalise\n.\n\n\nset_length!(a::SeriesElem, n::Int)\n\n\n\n\nSet the length of the polynomial underlying a power series assuming it has sufficient space allocated, i.e. a power series for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial power series type has a field, \nlength\n, which corresponds to the current length of the polynomial underlying a power series, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.\n\n\nlength(a::SeriesElem)\n\n\n\n\nReturn the current length (not the number of allocated coefficients), of the polynomial underlying the given power series. Note that this function only needs to be provided by a developer for a custom power series type if the Julia type definition the power series type doesn't contain a field \nlength\n corresponding to the current length of the polynomial underlying the power series. Otherwise the supplied generic implementation will work.\n\n\nset_prec!(a::SeriesElem, n::Int)\n\n\n\n\nSet the precision of the given power series to \nn\n. Note this function only needs to be provided by a developer for a custom power series type if the Julia type definition of the power series type doesn't contain a field \nprec\n corresponding to the current precision of the power series. Otherwise the supplied generic implementation will work.\n\n\nprecision(a::SeriesElem)\n\n\n\n\nReturn the current precision of the given power series. This function does not have to be provided by a developer of a custom power series type if the Julia type definition of the power series type contains a field \nprec\n corresponding to the current precision of the power series. In this case the supplied generic implementation will work. Note that for convenience, the precision is stored as an absolute precision.\n\n\ncoeff(a::SeriesElem, n::Int)\n\n\n\n\nReturn the degree \nn\n coefficient of the given power series. Note coefficients are numbered from \nn = 0\n for the constant coefficient. If \nn\n exceeds the current precision of the power series, the function returns a zero coefficient. We require \nn \\geq 0\n. \n\n\nsetcoeff!{T \n: RingElem}(a::SeriesElem{T}, n::Int, c::T)\n\n\n\n\nSet the coefficient of the degree \nn\n term of the given power series to the given value \na\n. The polynomial underlying the power series is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.\n\n\ndeepcopy(a::SeriesElem)\n\n\n\n\nConstruct a copy of the given power series and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo power series are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::SeriesElem, a::SeriesElem, b::SeriesElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing power series \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::SeriesElem, a::SeriesElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a power series ring, the following coercion functions are provided to coerce various elements into the power series ring. Developers provide these by overloading the \ncall\n operator for the polynomial parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the ring \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the power series ring \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(A::Array{T, 1}, len::Int, prec::Int)\n\n\n\n\nTake an array of elements in the base ring, of type \nT\n and construct the power series with those coefficients. The length of the underlying polynomial and the precision of the power series will be set to the given values.\n\n\nS(f::SeriesElem)\n\n\n\n\nTake a power series that is already in the ring \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the power series ring. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom power series must ensure the parent object of a power series type constains a field \nbase_ring\n specifying the base ring, a field \nS\n containing a symbol (not a string) representing the variable name of the power series ring and a field \nmax_prec\n specifying the maximum relative precision of the power series. They must also ensure that each power series element contains a field \nparent\n specifying the parent object of the power series.\n\n\nTypically a developer will also overload the \nPowerSeriesRing\n generic function to create power series of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(R::SeriesRing)\n\n\n\n\n\n\nReturn the base ring of the given power series ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring(a::SeriesElem)\n\n\n\n\n\n\nReturn the base ring of the power series ring of the given power series.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::SeriesElem)\n\n\n\n\n\n\nReturn the parent of the given power series.\n\n\n\n\nsource\n\n\n#\n\n\nBase.var\n \n \nMethod\n.\n\n\nvar(a::SeriesRing)\n\n\n\n\n\n\nReturn the internal name of the generator of the power series ring. Note that this is returned as a \nSymbol\n not a \nString\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.valuation\n \n \nMethod\n.\n\n\nvaluation(a::SeriesElem)\n\n\n\n\n\n\nReturn the valuation of the given power series, i.e. the degree of the first nonzero term (or the precision if it is arithmetically zero).\n\n\n\n\nsource\n\n\n#\n\n\nNemo.max_precision\n \n \nMethod\n.\n\n\nmax_precision(R::SeriesRing)\n\n\n\n\n\n\nReturn the maximum relative precision of power series in the given power series ring.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus{T \n: ResElem}(a::SeriesElem{T})\n\n\n\n\n\n\nReturn the modulus of the coefficients of the given polynomial.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::SeriesElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given power series is arithmetically equal to zero to its current precision, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::SeriesElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given power series is arithmetically equal to one to its current precision, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isgen\n \n \nMethod\n.\n\n\nisgen(a::SeriesElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::SeriesElem)\n\n\n\n\n\n\nReturn \ntrue\n if the given power series is arithmetically equal to a unit, i.e. is invertible, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of power series.\n\n\nR, t = PowerSeriesRing(QQ, 10, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = O(x^4)\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\n\nc = gen(R)\nd = zero(R)\nf = one(S)\n\ng = iszero(d)\nh = isone(f)\nk = isgen(c)\nm = isunit(-1 + x + 2x^2)\nn = valuation(a)\np = valuation(b)\ns = var(S)\nU = base_ring(S)\nV = base_ring(t)\nW = parent(t + 1)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo power series. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x)\n\n\n\n\nUnary minus operator.\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na/b\n. Requires \nb\n to be invertible.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\nThe following ad hoc operators are also provided.\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::Integer, b::SeriesElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::SeriesElem, b::Integer)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::fmpz, b::SeriesElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::SeriesElem, b::fmpz)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::Integer, b::SeriesElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::SeriesElem, b::Integer)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::fmpz, b::SeriesElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::SeriesElem, b::fmpz)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::Integer)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::fmpz)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na/b\n. Requires \nb\n to be invertible.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::FracElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::Integer, b::FracElem)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::FracElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::fmpz, b::FracElem)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::PolyElem{T})\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::PolyElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact(a::PolyElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact(a::PolyElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::SeriesElem{T})\n\n\n\n\n\n\nReturn \na/b\n. Requires \nb\n to be invertible.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::FracElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::Integer, b::FracElem)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::FracElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact(a::fmpz, b::FracElem)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::SeriesElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\n#\n\n\nBase.^\n \n \nMethod\n.\n\n\n^(x, y)\n\n\n\n\nExponentiation operator.\n\n\nsource\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on power series.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = x^2 + 3x^3 - x^4\n\nf = -a\ng = a + b\nh = a - c\nk = b*c\nm = a*c\nn = a*d\np = 2a\nq = fmpz(3)*b\nr = c*2\ns = d*fmpz(3)\nt = a^12\nu = divexact(b, c)\nv = divexact(a, 7)\nw = divexact(b, fmpz(11))\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for power series in Nemo.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::SeriesElem{T}, y::SeriesElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n. Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::SeriesElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::T, y::SeriesElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \n \nMethod\n.\n\n\nisequal{T \n: RingElem}(x::SeriesElem{T}, y::SeriesElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n exactly, otherwise return \nfalse\n. Only if the power series are precisely the same, to the same precision, are they declared equal by this function.\n\n\n\n\nsource\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::SeriesElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::T, y::SeriesElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::SeriesElem, y::Integer)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::Integer, y::SeriesElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::SeriesElem, y::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::fmpz, y::SeriesElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of comparisons.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^3)\nc = 1 + x + 3x^2 + O(x^5)\nd = 3x^3 - x^4\n\na == 2x + x^3\nb == d\nc != d\nisequal(b, d)\nd == 3\nc == fmpz(1)\nfmpz(0) != a\n2 == b\nfmpz(1) == c\n\n\n\n\n\n\nShifting\n\n\n#\n\n\nNemo.shift_left\n \n \nMethod\n.\n\n\nshift_left(x::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted left by \nn\n terms, i.e. multiplied by \nx^n\n.\n\n\n\n\nsource\n\n\nshift_left(x::SeriesElem, n::Int)\n\n\n\n\n\n\nReturn the power series \nf\n shifted left by \nn\n terms, i.e. multiplied by \nx^n\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.shift_right\n \n \nMethod\n.\n\n\nshift_right(f::PolyElem, n::Int)\n\n\n\n\n\n\nReturn the polynomial \nf\n shifted right by \nn\n terms, i.e. divided by \nx^n\n.\n\n\n\n\nsource\n\n\nshift_right(f::SeriesElem, n::Int)\n\n\n\n\n\n\nReturn the power series \nf\n shifted right by \nn\n terms, i.e. divided by \nx^n\n.\n\n\n\n\nsource\n\n\nHere are some examples of shifting.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = shift_left(a, 2)\ng = shift_left(b, 2)\nh = shift_right(c, 1)\nk = shift_right(d, 3)\n\n\n\n\n\n\nTruncation\n\n\n#\n\n\nBase.truncate\n \n \nMethod\n.\n\n\ntruncate(file,n)\n\n\n\n\nResize the file or buffer given by the first argument to exactly \nn\n bytes, filling previously unallocated space with '\\0' if the file or buffer is grown.\n\n\nsource\n\n\ntruncate(a::PolyElem, n::Int)\n\n\n\n\n\n\nReturn \na\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\ntruncate(a::SeriesElem, n::Int)\n\n\n\n\n\n\nReturn \na\n truncated to \nn\n terms.\n\n\n\n\nsource\n\n\nHere are some examples of truncation.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = truncate(a, 3)\ng = truncate(b, 2)\nh = truncate(c, 7)\nk = truncate(d, 5)\n\n\n\n\n\n\nInverse\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(a::SeriesElem)\n\n\n\n\nReturn the inverse of the power series \na\n, i.e. \n1/a\n.\n\n\n\n\nsource\n\n\nHere are some examples of taking the inverse.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\n\na = 1 + x + 2x^2 + O(x^5)\nb = S(-1)\n\nc = inv(a)\nd = inv(b)\n\n\n\n\n\n\nSpecial functions\n\n\n#\n\n\nBase.exp\n \n \nMethod\n.\n\n\nexp(a::SeriesElem)\n\n\n\n\n\n\nReturn the exponential of the power series \na\n.\n\n\n\n\nsource\n\n\nThe following special functions are only available for certain rings.\n\n\n#\n\n\nBase.log\n \n \nMethod\n.\n\n\nlog(x)\n\n\n\n\nCompute the natural logarithm of \nx\n. Throws \nDomainError\n for negative \nReal\n arguments. Use complex negative arguments to obtain complex results.\n\n\nThere is an experimental variant in the \nBase.Math.JuliaLibm\n module, which is typically faster and more accurate.\n\n\nsource\n\n\nlog(a::fmpq_rel_series)\n\n\n\n\nReturn log\n(a)\n. Requires the constant term to be one.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sqrt\n \n \nMethod\n.\n\n\nsqrt(a::fmpq_rel_series)\n\n\n\n\nReturn the power series square root of \na\n. Requires a constant term equal to one.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tan\n \n \nMethod\n.\n\n\ntan(a::fmpq_rel_series)\n\n\n\n\nReturn tan\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.tanh\n \n \nMethod\n.\n\n\ntanh(a::fmpq_rel_series)\n\n\n\n\nReturn tanh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sin\n \n \nMethod\n.\n\n\nsin(a::fmpq_rel_series)\n\n\n\n\nReturn sin\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.sinh\n \n \nMethod\n.\n\n\nsinh(a::fmpq_rel_series)\n\n\n\n\nReturn sinh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cos\n \n \nMethod\n.\n\n\ncos(a::fmpq_rel_series)\n\n\n\n\nReturn cos\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.cosh\n \n \nMethod\n.\n\n\ncosh(a::fmpq_rel_series)\n\n\n\n\nReturn cosh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.asin\n \n \nMethod\n.\n\n\nasin(a::fmpq_rel_series)\n\n\n\n\nReturn asin\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.asinh\n \n \nMethod\n.\n\n\nasinh(a::fmpq_rel_series)\n\n\n\n\nReturn asinh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.atan\n \n \nMethod\n.\n\n\natan(a::fmpq_rel_series)\n\n\n\n\nReturn atan\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\n#\n\n\nBase.atanh\n \n \nMethod\n.\n\n\natanh(a::fmpq_rel_series)\n\n\n\n\nReturn atanh\n(a)\n. Requires a zero constant term.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\nR, t = PolynomialRing(QQ, \nt\n)\nS, x = PowerSeriesRing(R, 30, \nx\n)\nT, z = PowerSeriesRing(QQ, 30, \nz\n)\n\na = 1 + z + 3z^2 + O(z^5)\nb = z + 2z^2 + 5z^3 + O(z^5)\n\nc = exp(x + O(x^40))\nd = divexact(x, exp(x + O(x^40)) - 1)\nf = exp(b)\ng = log(a)\nh = sqrt(a)\nk = sin(b)\nm = atanh(b)", 
            "title": "Capped relative power series"
        }, 
        {
            "location": "/build/series/#introduction", 
            "text": "Nemo allows the creation of capped relative power series over any computable ring  R . These are power series of the form  a_jx^j + a_{j+1}x^{j+1} + \\cdots + a_{k-1}x^{k-1} + O(x^k)  where  i \\geq 0 ,  a_i \\in R  and the relative precision  k - j  is at most equal to some specified precision  n .  There are two different kinds of implementation: a generic one for the case where no specific implementation exists, and efficient implementations of power series over numerous specific rings, usually provided by C/C++ libraries.  The following table shows each of the relative power series types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of series (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenRelSeries{T}  GenRelSeriesRing{T}     \\mathbb{Z}   Flint  fmpz_rel_series  FmpzRelSeriesRing     \\mathbb{Z}/n\\mathbb{Z}   Flint  fmpz_mod_rel_series  FmpzModRelSeriesRing     \\mathbb{Q}   Flint  fmpq_rel_series  FmpqRelSerieRing     \\mathbb{F}_{p^n}  (small  n )  Flint  fq_nmod_rel_series  FqNmodRelSeriesRing     \\mathbb{F}_{p^n}  (large  n )  Flint  fq_rel_series  FqRelSeriesRing     The maximum relative precision, the string representation of the variable and the base ring  R  of a generic power series are stored in its parent object.   All power series element types belong to the abstract type  SeriesElem  and all of the power series ring types belong to the abstract type  SeriesRing . This enables one to write generic functions that can accept any Nemo power series type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/build/series/#capped-relative-power-series", 
            "text": "Capped relative power series have their maximum relative precision capped at some value  prec_max . This means that if the leading term of a nonzero power series element is  c_ax^a  and the precision is  b  then the power series is of the form   c_ax^a + c_{a+1}x^{a+1} + \\ldots + O(x^{a + b}) .  The zero power series is simply taken to be  0 + O(x^b) .  The capped relative model has the advantage that power series are stable multiplicatively. In other words, for nonzero power series  f  and  g  we have that  divexact(f*g), g) == f .  However, capped relative power series are not additively stable, i.e. we do not always have  (f + g) - g = f .  In the capped relative model we say that two power series are equal if they agree up to the minimum  absolute  precision of the two power series. Thus, for example,  x^5 + O(x^10) == 0 + O(x^5) , since the minimum absolute precision is  5 .  During computations, it is possible for power series to lose relative precision due to cancellation. For example if  f = x^3 + x^5 + O(x^8)  and  g = x^3 + x^6 + O(x^8)  then  f - g = x^5 - x^6 + O(x^8)  which now has relative precision  3  instead of relative precision  5 .  Amongst other things, this means that equality is not transitive. For example  x^6 + O(x^11) == 0 + O(x^5)  and  x^7 + O(x^12) == 0 + O(x^5)  but  x^6 + O(x^11) \\neq x^7 + O(x^12) .  Sometimes it is necessary to compare power series not just for arithmetic equality, as above, but to see if they have precisely the same precision and terms. For this purpose we introduce the  isequal  function.  For example, if  f = x^2 + O(x^7)  and  g = x^2 + O(x^8)  and  h = 0 + O(x^2)  then  f == g ,  f == h  and  g == h , but  isequal(f, g) ,  isequal(f, h)  and  isequal(g, h)  would all return  false . However, if  k = x^2 + O(x^7)  then  isequal(f, k)  would return  true .  There are further difficulties if we construct polynomial over power series. For example, consider the polynomial in  y  over the power series ring in  x  over the rationals. Normalisation of such polynomials is problematic. For instance, what is the leading coefficient of  (0 + O(x^10))y + (1 + O(x^10)) ?  If one takes it to be  (0 + O(x^10))  then some functions may not terminate due to the fact that algorithms may require the degree of polynomials to decrease with each iteration. Instead, the degree may remain constant and simply accumulate leading terms which are arithmetically zero but not identically zero.  On the other hand, when constructing power series over other power series, if we simply throw away terms which are arithmetically equal to zero, our computations may have different output depending on the order in which the power series are added!  One should be aware of these difficulties when working with power series. Power series, as represented on a computer, simply don't satisfy the axioms of a ring. They must be used with care in order to approximate operations in a mathematical power series ring.  Simply increasing the precision will not necessarily give a \"more correct\" answer and some computations may not even terminate due to the presence of arithmetic zeroes!", 
            "title": "Capped relative power series"
        }, 
        {
            "location": "/build/series/#power-series-ring-constructors", 
            "text": "In order to construct power series in Nemo, one must first construct the power series ring itself. This is accomplished with the following constructor.  #  Nemo.PowerSeriesRing     Method .  PowerSeriesRing(R::Ring, prec::Int, s::AbstractString{}; cached=true)   Return a tuple  (S, x)  consisting of the parent object  S  of a power series ring over the given base ring and a generator  x  for the power series ring. The maximum relative precision of power series in the ring is set to  prec . The supplied string  s  specifies the way the generator of the power series ring will be printed. By default, the parent object  S  will be cached so that supplying the same base ring, string and precision in future will return the same parent object and generator. If caching of the parent object is not required,  cached  can be set to  false .   source  Here are some examples of creating a power series ring using the constructor and using the resulting parent object to coerce various elements into the power series ring.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = S(x)\nb = S(t + 1)\nc = S(1)\nd = S(ZZ(2))\nf = S()", 
            "title": "Power series ring constructors"
        }, 
        {
            "location": "/build/series/#power-series-element-constructors", 
            "text": "Once a power series ring is constructed, there are various ways to construct power series in that ring.  The easiest way is simply using the generator returned by the  PowerSeriesRing  constructor and and build up the power series using basic arithmetic. The absolute precision of a power series can be set using the following function.  #  Nemo.O     Method .  O{T}(a::SeriesElem{T})   Returns  0 + O(x^\\mbox{deg}(a)) . Usually this function is called with  x^n  as parameter. Then the function returns the power series  0 + O(x^n) , which can be used to set the precision of a power series when constructing it.   source  In addition we provide the following functions for constructing certain useful polynomials.  #  Base.zero     Method .  zero(R::SeriesRing)   Return  0 + O(x^n)  where  n  is the maximum precision of the power series ring  R .   source  #  Base.one     Method .  zero(R::SeriesRing)   Return  1 + O(x^n)  where  n  is the maximum precision of the power series ring  R .   source  #  Nemo.gen     Method .  zero(R::SeriesRing)   Return the generator of the power series ring, i.e.  x + O(x^{n + 1})  where  n  is the maximum precision of the power series ring  R .   source  Here are some examples of constructing power series.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = x^3 + 2x + 1\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\nc = zero(S)\nd = one(S)\nf = gen(S)", 
            "title": "Power series element constructors"
        }, 
        {
            "location": "/build/series/#basic-functionality", 
            "text": "All power series modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own power series module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom power series types in Nemo.   We write  U  for the type of the power series in the power series ring and  T  for the type of elements of the coefficient ring.  All of these functions are provided for all existing power series types in Nemo.  parent_type{U  : SeriesElem}(::Type{U})  Given the type of power series elements, should return the type of the corresponding parent object.  elem_type(R::SeriesRing)  Given a parent object for the power series ring, return the type of elements of the power series ring.  Base.hash(a::SeriesElem, h::UInt)  Return a  UInt  hexadecimal hash of the power series  a . This should be xor'd with a fixed random hexadecimal specific to the power series type. The hash of each coefficient should be xor'd with the supplied parameter  h  as part of computing the hash.  fit!(a::SeriesElem, n::Int)  By reallocating if necessary, ensure that the polynomial underlying the given power series has space for at least  n  coefficients. This function does not change the length of the power series and will only ever increase the number of allocated coefficients. Any coefficients added by this function are initialised to zero.  normalise(a::SeriesElem, n::Int)  Return the normalised length of the polynomial underlying the given power series, assuming its current length is  n . Its normalised length is such that it either has nonzero leading term or is the zero polynomial. Note that this function doesn't normalise the power series. That can be done with a subsequent call to  set_length!  using the length returned by  normalise .  set_length!(a::SeriesElem, n::Int)  Set the length of the polynomial underlying a power series assuming it has sufficient space allocated, i.e. a power series for which no reallocation is needed. Note that if the Julia type definition for a custom polynomial power series type has a field,  length , which corresponds to the current length of the polynomial underlying a power series, then the developer doesn't need to supply this function, as the supplied generic implementation will work. Note that it can change the length to any value from zero to the number of coefficients currently allocated and initialised.  length(a::SeriesElem)  Return the current length (not the number of allocated coefficients), of the polynomial underlying the given power series. Note that this function only needs to be provided by a developer for a custom power series type if the Julia type definition the power series type doesn't contain a field  length  corresponding to the current length of the polynomial underlying the power series. Otherwise the supplied generic implementation will work.  set_prec!(a::SeriesElem, n::Int)  Set the precision of the given power series to  n . Note this function only needs to be provided by a developer for a custom power series type if the Julia type definition of the power series type doesn't contain a field  prec  corresponding to the current precision of the power series. Otherwise the supplied generic implementation will work.  precision(a::SeriesElem)  Return the current precision of the given power series. This function does not have to be provided by a developer of a custom power series type if the Julia type definition of the power series type contains a field  prec  corresponding to the current precision of the power series. In this case the supplied generic implementation will work. Note that for convenience, the precision is stored as an absolute precision.  coeff(a::SeriesElem, n::Int)  Return the degree  n  coefficient of the given power series. Note coefficients are numbered from  n = 0  for the constant coefficient. If  n  exceeds the current precision of the power series, the function returns a zero coefficient. We require  n \\geq 0 .   setcoeff!{T  : RingElem}(a::SeriesElem{T}, n::Int, c::T)  Set the coefficient of the degree  n  term of the given power series to the given value  a . The polynomial underlying the power series is not normalised automatically after this operation, however the polynomial is automatically resized if there is not sufficient allocated space.  deepcopy(a::SeriesElem)  Construct a copy of the given power series and return it. This function must recursively construct copies of all of the internal data in the given polynomial. Nemo power series are mutable and so returning shallow copies is not sufficient.  mul!(c::SeriesElem, a::SeriesElem, b::SeriesElem)  Multiply  a  by  b  and set the existing power series  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::SeriesElem, a::SeriesElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a power series ring, the following coercion functions are provided to coerce various elements into the power series ring. Developers provide these by overloading the  call  operator for the polynomial parent objects.  S()  Coerce zero into the ring  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the power series ring  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(A::Array{T, 1}, len::Int, prec::Int)  Take an array of elements in the base ring, of type  T  and construct the power series with those coefficients. The length of the underlying polynomial and the precision of the power series will be set to the given values.  S(f::SeriesElem)  Take a power series that is already in the ring  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the power series ring. This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom power series must ensure the parent object of a power series type constains a field  base_ring  specifying the base ring, a field  S  containing a symbol (not a string) representing the variable name of the power series ring and a field  max_prec  specifying the maximum relative precision of the power series. They must also ensure that each power series element contains a field  parent  specifying the parent object of the power series.  Typically a developer will also overload the  PowerSeriesRing  generic function to create power series of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/build/series/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate polynomials and to set and retrieve coefficients and other basic data associated with the polynomials. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring(R::SeriesRing)   Return the base ring of the given power series ring.   source  #  Nemo.base_ring     Method .  base_ring(a::SeriesElem)   Return the base ring of the power series ring of the given power series.   source  #  Base.parent     Method .  parent(a::SeriesElem)   Return the parent of the given power series.   source  #  Base.var     Method .  var(a::SeriesRing)   Return the internal name of the generator of the power series ring. Note that this is returned as a  Symbol  not a  String .   source  #  Nemo.valuation     Method .  valuation(a::SeriesElem)   Return the valuation of the given power series, i.e. the degree of the first nonzero term (or the precision if it is arithmetically zero).   source  #  Nemo.max_precision     Method .  max_precision(R::SeriesRing)   Return the maximum relative precision of power series in the given power series ring.   source  #  Nemo.modulus     Method .  modulus{T  : ResElem}(a::SeriesElem{T})   Return the modulus of the coefficients of the given polynomial.   source  #  Nemo.iszero     Method .  iszero(a::SeriesElem)   Return  true  if the given power series is arithmetically equal to zero to its current precision, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::SeriesElem)   Return  true  if the given power series is arithmetically equal to one to its current precision, otherwise return  false .   source  #  Nemo.isgen     Method .  isgen(a::SeriesElem)   Return  true  if the given power series is arithmetically equal to the generator of its power series ring to its current precision, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::SeriesElem)   Return  true  if the given power series is arithmetically equal to a unit, i.e. is invertible, otherwise return  false .   source  Here are some examples of basic manipulation of power series.  R, t = PowerSeriesRing(QQ, 10,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = O(x^4)\nb = (t^2 + 1)*x^2 + (t + 3)x + O(x^4)\n\nc = gen(R)\nd = zero(R)\nf = one(S)\n\ng = iszero(d)\nh = isone(f)\nk = isgen(c)\nm = isunit(-1 + x + 2x^2)\nn = valuation(a)\np = valuation(b)\ns = var(S)\nU = base_ring(S)\nV = base_ring(t)\nW = parent(t + 1)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/build/series/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo power series. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  #  Base.-     Method .  -(x)  Unary minus operator.  source  #  Base.+     Method .  +{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})   Return  a + b .   source  +{T  : RingElem}(a::T, b::SeriesElem{T})   Return  a + b .   source  +{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})   Return  a - b .   source  -{T  : RingElem}(a::T, b::SeriesElem{T})   Return  a - b .   source  -{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::T, b::SeriesElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})   Return  a/b . Requires  b  to be invertible.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  The following ad hoc operators are also provided.  #  Base.+     Method .  +(a::Integer, b::SeriesElem)   Return  a + b .   source  #  Base.+     Method .  +(a::SeriesElem, b::Integer)   Return  a + b .   source  #  Base.+     Method .  +(a::fmpz, b::SeriesElem)   Return  a + b .   source  #  Base.+     Method .  +(a::SeriesElem, b::fmpz)   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::T, b::SeriesElem{T})   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::Integer, b::SeriesElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::SeriesElem, b::Integer)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::fmpz, b::SeriesElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::SeriesElem, b::fmpz)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::T, b::SeriesElem{T})   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::SeriesElem{T}, b::Integer)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a\\times b .   source  *{T  : RingElem}(a::SeriesElem{T}, b::fmpz)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::T, b::SeriesElem{T})   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  divexact(a::PolyElem, b::Integer)   Return  a/b  where the quotient is expected to be exact.   source  divexact(a::PolyElem, b::fmpz)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})   Return  a/b . Requires  b  to be invertible.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::Integer)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::fmpz)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return  a/b .   source  divexact(a::FracElem, b::Integer)   Return  a/b .   source  divexact(a::Integer, b::FracElem)   Return  a/b .   source  divexact(a::FracElem, b::fmpz)   Return  a/b .   source  divexact(a::fmpz, b::FracElem)   Return  a/b .   source  divexact{T  : RingElem}(a::FracElem{T}, b::T)   Return  a/b .   source  divexact{T  : RingElem}(a::T, b::FracElem{T})   Return  a/b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::PolyElem{T}, b::PolyElem{T})   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::PolyElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  divexact(a::PolyElem, b::Integer)   Return  a/b  where the quotient is expected to be exact.   source  divexact(a::PolyElem, b::fmpz)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::SeriesElem{T})   Return  a/b . Requires  b  to be invertible.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::Integer)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::fmpz)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  divexact{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return  a/b .   source  divexact(a::FracElem, b::Integer)   Return  a/b .   source  divexact(a::Integer, b::FracElem)   Return  a/b .   source  divexact(a::FracElem, b::fmpz)   Return  a/b .   source  divexact(a::fmpz, b::FracElem)   Return  a/b .   source  divexact{T  : RingElem}(a::FracElem{T}, b::T)   Return  a/b .   source  divexact{T  : RingElem}(a::T, b::FracElem{T})   Return  a/b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::SeriesElem{T}, b::T)   Return  a/b  where the quotient is expected to be exact.   source  #  Base.^     Method .  ^(x, y)  Exponentiation operator.  source  If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on power series.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = x^2 + 3x^3 - x^4\n\nf = -a\ng = a + b\nh = a - c\nk = b*c\nm = a*c\nn = a*d\np = 2a\nq = fmpz(3)*b\nr = c*2\ns = d*fmpz(3)\nt = a^12\nu = divexact(b, c)\nv = divexact(a, 7)\nw = divexact(b, fmpz(11))", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/build/series/#comparison-operators", 
            "text": "The following comparison operators are implemented for power series in Nemo.  #  Base.==     Method .  =={T  : RingElem}(x::SeriesElem{T}, y::SeriesElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false . Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.   source  =={T  : RingElem}(x::SeriesElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  =={T  : RingElem}(x::T, y::SeriesElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.isequal     Method .  isequal{T  : RingElem}(x::SeriesElem{T}, y::SeriesElem{T})   Return  true  if  x == y  exactly, otherwise return  false . Only if the power series are precisely the same, to the same precision, are they declared equal by this function.   source  In addition we have the following ad hoc comparison operators.  #  Base.==     Method .  =={T  : RingElem}(x::SeriesElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  =={T  : RingElem}(x::T, y::SeriesElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::SeriesElem, y::Integer)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::Integer, y::SeriesElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::SeriesElem, y::fmpz)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::fmpz, y::SeriesElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  Here are some examples of comparisons.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^3)\nc = 1 + x + 3x^2 + O(x^5)\nd = 3x^3 - x^4\n\na == 2x + x^3\nb == d\nc != d\nisequal(b, d)\nd == 3\nc == fmpz(1)\nfmpz(0) != a\n2 == b\nfmpz(1) == c", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/build/series/#shifting", 
            "text": "#  Nemo.shift_left     Method .  shift_left(x::PolyElem, n::Int)   Return the polynomial  f  shifted left by  n  terms, i.e. multiplied by  x^n .   source  shift_left(x::SeriesElem, n::Int)   Return the power series  f  shifted left by  n  terms, i.e. multiplied by  x^n .   source  #  Nemo.shift_right     Method .  shift_right(f::PolyElem, n::Int)   Return the polynomial  f  shifted right by  n  terms, i.e. divided by  x^n .   source  shift_right(f::SeriesElem, n::Int)   Return the power series  f  shifted right by  n  terms, i.e. divided by  x^n .   source  Here are some examples of shifting.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = shift_left(a, 2)\ng = shift_left(b, 2)\nh = shift_right(c, 1)\nk = shift_right(d, 3)", 
            "title": "Shifting"
        }, 
        {
            "location": "/build/series/#truncation", 
            "text": "#  Base.truncate     Method .  truncate(file,n)  Resize the file or buffer given by the first argument to exactly  n  bytes, filling previously unallocated space with '\\0' if the file or buffer is grown.  source  truncate(a::PolyElem, n::Int)   Return  a  truncated to  n  terms.   source  truncate(a::SeriesElem, n::Int)   Return  a  truncated to  n  terms.   source  Here are some examples of truncation.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 2x + x^3\nb = O(x^4)\nc = 1 + x + 2x^2 + O(x^5)\nd = 2x + x^3 + O(x^4)\n\nf = truncate(a, 3)\ng = truncate(b, 2)\nh = truncate(c, 7)\nk = truncate(d, 5)", 
            "title": "Truncation"
        }, 
        {
            "location": "/build/series/#inverse", 
            "text": "#  Base.inv     Method .  inv(a::SeriesElem)   Return the inverse of the power series  a , i.e.  1/a .   source  Here are some examples of taking the inverse.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\n\na = 1 + x + 2x^2 + O(x^5)\nb = S(-1)\n\nc = inv(a)\nd = inv(b)", 
            "title": "Inverse"
        }, 
        {
            "location": "/build/series/#special-functions", 
            "text": "#  Base.exp     Method .  exp(a::SeriesElem)   Return the exponential of the power series  a .   source  The following special functions are only available for certain rings.  #  Base.log     Method .  log(x)  Compute the natural logarithm of  x . Throws  DomainError  for negative  Real  arguments. Use complex negative arguments to obtain complex results.  There is an experimental variant in the  Base.Math.JuliaLibm  module, which is typically faster and more accurate.  source  log(a::fmpq_rel_series)   Return log (a) . Requires the constant term to be one.   source  #  Base.sqrt     Method .  sqrt(a::fmpq_rel_series)   Return the power series square root of  a . Requires a constant term equal to one.   source  #  Base.tan     Method .  tan(a::fmpq_rel_series)   Return tan (a) . Requires a zero constant term.   source  #  Base.tanh     Method .  tanh(a::fmpq_rel_series)   Return tanh (a) . Requires a zero constant term.   source  #  Base.sin     Method .  sin(a::fmpq_rel_series)   Return sin (a) . Requires a zero constant term.   source  #  Base.sinh     Method .  sinh(a::fmpq_rel_series)   Return sinh (a) . Requires a zero constant term.   source  #  Base.cos     Method .  cos(a::fmpq_rel_series)   Return cos (a) . Requires a zero constant term.   source  #  Base.cosh     Method .  cosh(a::fmpq_rel_series)   Return cosh (a) . Requires a zero constant term.   source  #  Base.asin     Method .  asin(a::fmpq_rel_series)   Return asin (a) . Requires a zero constant term.   source  #  Base.asinh     Method .  asinh(a::fmpq_rel_series)   Return asinh (a) . Requires a zero constant term.   source  #  Base.atan     Method .  atan(a::fmpq_rel_series)   Return atan (a) . Requires a zero constant term.   source  #  Base.atanh     Method .  atanh(a::fmpq_rel_series)   Return atanh (a) . Requires a zero constant term.   source  Here are some examples of special functions.  R, t = PolynomialRing(QQ,  t )\nS, x = PowerSeriesRing(R, 30,  x )\nT, z = PowerSeriesRing(QQ, 30,  z )\n\na = 1 + z + 3z^2 + O(z^5)\nb = z + 2z^2 + 5z^3 + O(z^5)\n\nc = exp(x + O(x^40))\nd = divexact(x, exp(x + O(x^40)) - 1)\nf = exp(b)\ng = log(a)\nh = sqrt(a)\nk = sin(b)\nm = atanh(b)", 
            "title": "Special functions"
        }, 
        {
            "location": "/build/residue/", 
            "text": "Introduction\n\n\nNemo allows the creation of residue rings of the form \nR/(a)\n for an element \na\n of a ring \nR\n.\n\n\nWe don't require \n(a)\n to be a prime or maximal ideal. Instead, we allow the creation of the residue ring \nR/(a)\n for any nonzero \na\n and simply raise an exception if an impossible inverse is encountered during computations  involving elements of \nR/(a)\n.\n\n\nThere is a generic implementation of residue rings of this form in Nemo, which accepts any ring \nR\n as base ring. The associated types of parent object and elements in such residue rings are given in the following table.\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenRes{T}\n\n\nGeResRing{T}\n\n\n\n\n\n\n\n\nThe modulus \na\n of a residue ring is stored in its parent object.\n\n\nAll residue element types belong to the abstract type \nResElem\n and all the residue ring parent object types belong to the abstract type \nResRing\n. This enables one to write generic functions that accept any Nemo residue type.\n\n\n\n\nResidue ring constructors\n\n\nIn order to construct residues in Nemo, one must first construct the residue ring itself. This is accomplished with the following constructor.\n\n\n#\n\n\nNemo.ResidueRing\n \n \nMethod\n.\n\n\nResidueRing{T \n: RingElem}(R::Ring, a::T; cached=true)\n\n\n\n\n\n\nCreate the residue ring \nR/(a)\n where \na\n is an element of the ring \nR\n. We require \na \\neq 0\n. If \ncached == true\n (the default) then the resulting residue ring parent object is cached and returned for any subsequent calls to the constructor with the same base ring \nR\n and element \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into those rings.\n\n\nR = ResidueRing(ZZ, 17)\nS, x = PolynomialRing(QQ, \nx\n)\nT = ResidueRing(S, x^2 + 1)\n\na = R(11)\nb = T(x)\nc = T(ZZ(3))\n\n\n\n\n\n\nResidue element constructors\n\n\nOnce a residue ring is constructed, there are various ways to construct residues in that ring.\n\n\nApart from coercing elements into the residue ring as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::ResRing)\n\n\n\n\n\n\nReturn the zero element of the given residue ring, i.e. \n0 \\pmod{a}\n where \na\n is the modulus of the residue ring.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\nzero(R::ResRing)\n\n\n\n\n\n\nReturn \n1 \\pmod{a}\n where \na\n is the modulus of the residue ring.\n\n\n\n\nsource\n\n\nHere are some examples of constructing residues.\n\n\nR = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)\n\n\n\n\n\n\nBasic functionality\n\n\nAll residue ring modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own residue ring module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom residue ring types in Nemo. \n\n\nWe write \nU\n for the type of residue elements in the residue ring and \nT\n for the type of elements of the base ring.\n\n\nAll of these functions are provided for all existing residue types in Nemo.\n\n\nparent_type{U \n: ResElem}(::Type{U})\n\n\n\n\nGiven the type of residue elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::ResRing)\n\n\n\n\nGiven a parent object for the residue ring, return the type of elements of the residue ring.\n\n\nBase.hash(a::ResElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the residue \na\n. This should be xor'd with a fixed random hexadecimal specific to the residue type. The hash of the data associated with a residue should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\ndata(a::ResElem)\n\n\n\n\nReturn the data of the given residue element, i.e. for \nc \\pmod{a}\n in the ring \nR/(a)\n return the value \nc\n as an element of the ring \nR\n.\n\n\ndeepcopy(a::ResElem)\n\n\n\n\nConstruct a copy of the given residue and return it. This function must recursively construct copies of all of the internal data in the given residue. Nemo residues are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::ResElem, a::ResElem, b::ResElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing residue \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::ResElem, a::ResElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a residue ring, the following coercion functions are provided to coerce various elements into the residue ring. Developers provide these by overloading the \ncall\n operator for the residue ring parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the ring \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the residue ring \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(f::ResElem)\n\n\n\n\nTake a residue that is already in the ring \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the residue ring. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nIn addition to the above, developers of custom residues must ensure the parent object of a residue type constains a field \nbase_ring\n specifying the base ring, a field \nmodulus\n containing the modulus \na\n of the residue ring \nR/(a)\n. They must also ensure that each residue element contains a field \nparent\n specifying the parent object of the residue.\n\n\nTypically a developer will also overload the \nResidueRing\n generic function to create residues of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate residues. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring{T}(S::ResRing{T})\n\n\n\n\n\n\nReturn the base ring \nR\n of the given residue ring \nS = R/(a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring{T}(r::ResElem)\n\n\n\n\n\n\nReturn the base ring \nR\n of the residue ring \nR/(a)\n that the supplied element \nr\n belongs to.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::ResElem)\n\n\n\n\n\n\nReturn the parent object of the given residue element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus(R::ResRing)\n\n\n\n\n\n\nReturn the modulus \na\n of the given residue ring \nS = R/(a)\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.modulus\n \n \nMethod\n.\n\n\nmodulus(R::ResRing)\n\n\n\n\n\n\nReturn the modulus \na\n of the residue ring \nS = R/(a)\n that the supplied residue \nr\n belongs to.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is zero in the residue ring it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\niszero(a::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is one in the residue ring it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\niszero(a::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is invertible in the residue ring it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of residues.\n\n\nR = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)\n\na = modulus(R)\nb = modulus(T(x + 1))\nc = isunit(h)\nd = isone(h)\nf = iszero(g)\nU = parent(g)\nV = base_ring(R)\nW = base_ring(T(x + 1))\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo residues. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x)\n\n\n\n\nUnary minus operator.\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::T, b::ResElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::ResElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::ResElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn \na/b\n where the quotient is expected to be exact.\n\n\n\n\nsource\n\n\nThe following ad hoc operators are also provided.\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::Integer, b::ResElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::ResElem, b::Integer)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::fmpz, b::ResElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::ResElem, b::Integer)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::T, b::ResElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::Integer, b::ResElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::ResElem, b::Integer)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::fmpz, b::ResElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::ResElem, b::fmpz)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::ResElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::Integer, b::ResElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::ResElem, b::Integer)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::fmpz, b::ResElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::ResElem, b::fmpz)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::ResElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::ResElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.^\n \n \nMethod\n.\n\n\n^(x, y)\n\n\n\n\nExponentiation operator.\n\n\nsource\n\n\n^(a::ResElem, b::Int)\n\n\n\n\n\n\nReturn \na^b\n.\n\n\n\n\nsource\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on residues.\n\n\nR = ResidueRing(ZZ, 16453889)\n\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\nf = R(4)\ng = R(6)\nn = T(x^5 + 1)\np = T(x^2 + 2x + 1)\n\na = -R(12345)\nb = -T(x^5 + 1)\nc = f + g\nd = f - g\nh = f*g\nk = n + p\nl = n - p\nm = n*p\nq = divexact(a*b, a)\nr = divexact(n*p, p)\ns = f + 3\nt = 3 - g\nu = 5g\nv = n + 4\nw = 4 - p\ny = n*5\nz = p^12\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for residues in Nemo.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::ResElem{T}, y::ResElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n. Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::ResElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::T, y::ResElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \n \nMethod\n.\n\n\nisequal{T \n: RingElem}(x::ResElem{T}, y::ResElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n exactly, otherwise return \nfalse\n. This function is useful in cases where the data of the residues are inexact, e.g. power series Only if the power series are precisely the same, to the same precision, are they declared equal by this function.\n\n\n\n\nsource\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::ResElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::T, y::ResElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::ResElem, y::Integer)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::Integer, y::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::ResElem, y::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::fmpz, y::ResElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of comparisons.\n\n\nR = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(3)\nb = a\nc = R(2)\nf = T(x^5 + 1)\ng = 8f\nh = f + g\n\nb == a\nc != a\nf == g\nh != g\nisequal(f, g)\na == 3\n4 != a\nf != 5\n\n\n\n\n\n\nInversion\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(a::ResElem)\n\n\n\n\n\n\nReturn the inverse of the element \na\n in the residue ring. If an impossible inverse is encountered, an exception is raised.\n\n\n\n\nsource\n\n\nHere are some examples of computing inverses.\n\n\nR = ResidueRing(ZZ, 49)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(5)\nf = T(x^5 + 1)\n\nb = inv(a)\ng = inv(f)\n\n\n\n\n\n\nGreatest common divisor\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd{T \n: RingElem}(a::ResElem{T}, b::ResElem{T})\n\n\n\n\n\n\nReturn a greatest common divisor of \na\n and \nb\n if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.\n\n\n\n\nsource\n\n\nHere are some examples of computing a greatest common divisor.\n\n\nR = ResidueRing(ZZ, 43)\nS, x = PolynomialRing(R, \nx\n)\nT = ResidueRing(S, x^3 - 2x + 1)\n\na = R(5)\nb = R(7)\nc = T(x^5 + 1)\nd = T(x^2 + x)\n\nf = gcd(a, b)\ng = gcd(c, d)", 
            "title": "Residue rings"
        }, 
        {
            "location": "/build/residue/#introduction", 
            "text": "Nemo allows the creation of residue rings of the form  R/(a)  for an element  a  of a ring  R .  We don't require  (a)  to be a prime or maximal ideal. Instead, we allow the creation of the residue ring  R/(a)  for any nonzero  a  and simply raise an exception if an impossible inverse is encountered during computations  involving elements of  R/(a) .  There is a generic implementation of residue rings of this form in Nemo, which accepts any ring  R  as base ring. The associated types of parent object and elements in such residue rings are given in the following table.     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenRes{T}  GeResRing{T}     The modulus  a  of a residue ring is stored in its parent object.  All residue element types belong to the abstract type  ResElem  and all the residue ring parent object types belong to the abstract type  ResRing . This enables one to write generic functions that accept any Nemo residue type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/build/residue/#residue-ring-constructors", 
            "text": "In order to construct residues in Nemo, one must first construct the residue ring itself. This is accomplished with the following constructor.  #  Nemo.ResidueRing     Method .  ResidueRing{T  : RingElem}(R::Ring, a::T; cached=true)   Create the residue ring  R/(a)  where  a  is an element of the ring  R . We require  a \\neq 0 . If  cached == true  (the default) then the resulting residue ring parent object is cached and returned for any subsequent calls to the constructor with the same base ring  R  and element  a .   source  Here are some examples of creating residue rings and making use of the resulting parent objects to coerce various elements into those rings.  R = ResidueRing(ZZ, 17)\nS, x = PolynomialRing(QQ,  x )\nT = ResidueRing(S, x^2 + 1)\n\na = R(11)\nb = T(x)\nc = T(ZZ(3))", 
            "title": "Residue ring constructors"
        }, 
        {
            "location": "/build/residue/#residue-element-constructors", 
            "text": "Once a residue ring is constructed, there are various ways to construct residues in that ring.  Apart from coercing elements into the residue ring as above, we offer the following functions.  #  Base.zero     Method .  zero(R::ResRing)   Return the zero element of the given residue ring, i.e.  0 \\pmod{a}  where  a  is the modulus of the residue ring.   source  #  Base.one     Method .  zero(R::ResRing)   Return  1 \\pmod{a}  where  a  is the modulus of the residue ring.   source  Here are some examples of constructing residues.  R = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)", 
            "title": "Residue element constructors"
        }, 
        {
            "location": "/build/residue/#basic-functionality", 
            "text": "All residue ring modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own residue ring module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom residue ring types in Nemo.   We write  U  for the type of residue elements in the residue ring and  T  for the type of elements of the base ring.  All of these functions are provided for all existing residue types in Nemo.  parent_type{U  : ResElem}(::Type{U})  Given the type of residue elements, should return the type of the corresponding parent object.  elem_type(R::ResRing)  Given a parent object for the residue ring, return the type of elements of the residue ring.  Base.hash(a::ResElem, h::UInt)  Return a  UInt  hexadecimal hash of the residue  a . This should be xor'd with a fixed random hexadecimal specific to the residue type. The hash of the data associated with a residue should be xor'd with the supplied parameter  h  as part of computing the hash.  data(a::ResElem)  Return the data of the given residue element, i.e. for  c \\pmod{a}  in the ring  R/(a)  return the value  c  as an element of the ring  R .  deepcopy(a::ResElem)  Construct a copy of the given residue and return it. This function must recursively construct copies of all of the internal data in the given residue. Nemo residues are mutable and so returning shallow copies is not sufficient.  mul!(c::ResElem, a::ResElem, b::ResElem)  Multiply  a  by  b  and set the existing residue  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::ResElem, a::ResElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a residue ring, the following coercion functions are provided to coerce various elements into the residue ring. Developers provide these by overloading the  call  operator for the residue ring parent objects.  S()  Coerce zero into the ring  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the residue ring  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(f::ResElem)  Take a residue that is already in the ring  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the residue ring. This only succeeds if  c  can be coerced into the base ring.  In addition to the above, developers of custom residues must ensure the parent object of a residue type constains a field  base_ring  specifying the base ring, a field  modulus  containing the modulus  a  of the residue ring  R/(a) . They must also ensure that each residue element contains a field  parent  specifying the parent object of the residue.  Typically a developer will also overload the  ResidueRing  generic function to create residues of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/build/residue/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate residues. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring{T}(S::ResRing{T})   Return the base ring  R  of the given residue ring  S = R/(a) .   source  #  Nemo.base_ring     Method .  base_ring{T}(r::ResElem)   Return the base ring  R  of the residue ring  R/(a)  that the supplied element  r  belongs to.   source  #  Base.parent     Method .  parent(a::ResElem)   Return the parent object of the given residue element.   source  #  Nemo.modulus     Method .  modulus(R::ResRing)   Return the modulus  a  of the given residue ring  S = R/(a) .   source  #  Nemo.modulus     Method .  modulus(R::ResRing)   Return the modulus  a  of the residue ring  S = R/(a)  that the supplied residue  r  belongs to.   source  #  Nemo.iszero     Method .  iszero(a::ResElem)   Return  true  if the supplied element  a  is zero in the residue ring it belongs to, otherwise return  false .   source  #  Nemo.isone     Method .  iszero(a::ResElem)   Return  true  if the supplied element  a  is one in the residue ring it belongs to, otherwise return  false .   source  #  Nemo.isunit     Method .  iszero(a::ResElem)   Return  true  if the supplied element  a  is invertible in the residue ring it belongs to, otherwise return  false .   source  Here are some examples of basic manipulation of residues.  R = ResidueRing(ZZ, 16453889)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\ng = zero(R)\nh = one(T)\n\na = modulus(R)\nb = modulus(T(x + 1))\nc = isunit(h)\nd = isone(h)\nf = iszero(g)\nU = parent(g)\nV = base_ring(R)\nW = base_ring(T(x + 1))", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/build/residue/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo residues. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  #  Base.-     Method .  -(x)  Unary minus operator.  source  #  Base.+     Method .  +{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return  a + b .   source  +{T  : RingElem}(a::ResElem{T}, b::T)   Return  a + b .   source  +{T  : RingElem}(a::T, b::ResElem{T})   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return  a - b .   source  -{T  : RingElem}(a::ResElem{T}, b::T)   Return  a - b .   source  -{T  : RingElem}(a::T, b::ResElem{T})   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::ResElem{T}, b::T)   Return  a\\times b .   source  *{T  : RingElem}(a::T, b::ResElem{T})   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return  a/b  where the quotient is expected to be exact.   source  The following ad hoc operators are also provided.  #  Base.+     Method .  +(a::Integer, b::ResElem)   Return  a + b .   source  #  Base.+     Method .  +(a::ResElem, b::Integer)   Return  a + b .   source  #  Base.+     Method .  +(a::fmpz, b::ResElem)   Return  a + b .   source  #  Base.+     Method .  +(a::ResElem, b::Integer)   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::T, b::ResElem{T})   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::ResElem{T}, b::T)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::Integer, b::ResElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::ResElem, b::Integer)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::fmpz, b::ResElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::ResElem, b::fmpz)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::T, b::ResElem{T})   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::ResElem{T}, b::T)   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::Integer, b::ResElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::ResElem, b::Integer)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::fmpz, b::ResElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::ResElem, b::fmpz)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::T, b::ResElem{T})   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::ResElem{T}, b::T)   Return  a\\times b .   source  #  Base.^     Method .  ^(x, y)  Exponentiation operator.  source  ^(a::ResElem, b::Int)   Return  a^b .   source  If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on residues.  R = ResidueRing(ZZ, 16453889)\n\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\nf = R(4)\ng = R(6)\nn = T(x^5 + 1)\np = T(x^2 + 2x + 1)\n\na = -R(12345)\nb = -T(x^5 + 1)\nc = f + g\nd = f - g\nh = f*g\nk = n + p\nl = n - p\nm = n*p\nq = divexact(a*b, a)\nr = divexact(n*p, p)\ns = f + 3\nt = 3 - g\nu = 5g\nv = n + 4\nw = 4 - p\ny = n*5\nz = p^12", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/build/residue/#comparison-operators", 
            "text": "The following comparison operators are implemented for residues in Nemo.  #  Base.==     Method .  =={T  : RingElem}(x::ResElem{T}, y::ResElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false . Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.   source  =={T  : RingElem}(x::ResElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  =={T  : RingElem}(x::T, y::ResElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.isequal     Method .  isequal{T  : RingElem}(x::ResElem{T}, y::ResElem{T})   Return  true  if  x == y  exactly, otherwise return  false . This function is useful in cases where the data of the residues are inexact, e.g. power series Only if the power series are precisely the same, to the same precision, are they declared equal by this function.   source  In addition we have the following ad hoc comparison operators.  #  Base.==     Method .  =={T  : RingElem}(x::ResElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  =={T  : RingElem}(x::T, y::ResElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::ResElem, y::Integer)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::Integer, y::ResElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::ResElem, y::fmpz)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::fmpz, y::ResElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  Here are some examples of comparisons.  R = ResidueRing(ZZ, 7)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(3)\nb = a\nc = R(2)\nf = T(x^5 + 1)\ng = 8f\nh = f + g\n\nb == a\nc != a\nf == g\nh != g\nisequal(f, g)\na == 3\n4 != a\nf != 5", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/build/residue/#inversion", 
            "text": "#  Base.inv     Method .  inv(a::ResElem)   Return the inverse of the element  a  in the residue ring. If an impossible inverse is encountered, an exception is raised.   source  Here are some examples of computing inverses.  R = ResidueRing(ZZ, 49)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 + 3x + 1)\n\na = R(5)\nf = T(x^5 + 1)\n\nb = inv(a)\ng = inv(f)", 
            "title": "Inversion"
        }, 
        {
            "location": "/build/residue/#greatest-common-divisor", 
            "text": "#  Base.gcd     Method .  gcd{T  : RingElem}(a::ResElem{T}, b::ResElem{T})   Return a greatest common divisor of  a  and  b  if one exists. This is done by taking the greatest common divisor of the data associated with the supplied residues and taking its greatest common divisor with the modulus.   source  Here are some examples of computing a greatest common divisor.  R = ResidueRing(ZZ, 43)\nS, x = PolynomialRing(R,  x )\nT = ResidueRing(S, x^3 - 2x + 1)\n\na = R(5)\nb = R(7)\nc = T(x^5 + 1)\nd = T(x^2 + x)\n\nf = gcd(a, b)\ng = gcd(c, d)", 
            "title": "Greatest common divisor"
        }, 
        {
            "location": "/build/fraction/", 
            "text": "Introduction\n\n\nNemo allows the creation of fraction fields over any ring \nR\n. We don't require \nR\n to be an integral domain, however no attempt is made to deal with the general case. Two fractions \na/b\n and \nc/d\n are equal in Nemo iff \nad = bc\n. Thus, in practice, a greatest common divisor function is currently required for the ring \nR\n.\n\n\nIn order to make the representation \na/b\n unique for printing, we have a notion of canonical unit for elements of a ring \nR\n. When canonicalising \na/b\n, each of the elements \na\n and \nb\n is first divided by the canonical unit of \nb\n.\n\n\nThe \ncanonical_unit\n function is defined for elements of every Nemo ring. It must have the properties\n\n\ncanonical_unit(u) == u\ncanonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)\n\n\n\n\nfor any unit \nu\n of the ring in question, and \na\n and \nb\n arbitrary elements of the ring.\n\n\nFor example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.\n\n\nThe canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.\n\n\nThere are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists, and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.\n\n\nThe following table shows each of the fraction types available in Nemo, the base ring \nR\n, and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).\n\n\n\n\n\n\n\n\nBase ring\n\n\nLibrary\n\n\nElement type\n\n\nParent type\n\n\n\n\n\n\n\n\n\n\nGeneric ring \nR\n\n\n\n\nNemo\n\n\nGenFrac{T}\n\n\nGenFracField{T}\n\n\n\n\n\n\n\n\n\\mathbb{Z}\n\n\n\n\nFlint\n\n\nfmpq\n\n\nFlintRationalField\n\n\n\n\n\n\n\n\nAll fraction element types belong to the abstract type \nFracElem\n and all of the fraction field types belong to the abstract type \nFracField\n. This enables one to write generic functions that can accept any Nemo fraction type.\n\n\n\n\nFraction field constructors\n\n\nIn order to construct fractions in Nemo, one must first construct the fraction field itself. This can be accomplished manually with the following constructor.\n\n\n#\n\n\nNemo.FractionField\n \n \nMethod\n.\n\n\nFractionField(R::Ring; cached=true)\n\n\n\n\n\n\nReturn the parent object of the fraction field over the given base ring \nR\n. If \ncached == true\n (the default), the returned parent object is cached so that it will always be returned by a call to the constructor when the same base ring \nR\n is supplied.\n\n\n\n\nsource\n\n\nNote: it is also possible to construct fractions directly in Nemo without manually constructing the fraction field. In such cases, Nemo creates the relevant fraction field internally.\n\n\nFor convenience, the rational fraction field is constructed automatically in Nemo. We have the definition\n\n\nQQ = FractionField(ZZ)\n\n\n\n\nHere are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into those fields.\n\n\nR = FractionField(ZZ)\nS, x = PolynomialRing(ZZ, \nx\n)\nT = FractionField(S)\n\na = R(1)\nb = T(fmpz(3))\nc = T(x)\nd = QQ(11)\n\n\n\n\n\n\nFraction constructors\n\n\nOnce a fraction field is constructed, there are various ways to construct fractions in that field.\n\n\nApart from coercing elements into the fraction field as above, we offer the following functions.\n\n\n#\n\n\nBase.zero\n \n \nMethod\n.\n\n\nzero(R::FracField)\n\n\n\n\n\n\nReturn \n0/1\n in the given fraction field.\n\n\n\n\nsource\n\n\n#\n\n\nBase.one\n \n \nMethod\n.\n\n\none(R::FracField)\n\n\n\n\n\n\nReturn \n1/1\n in the given fraction field.\n\n\n\n\nsource\n\n\nIt is also possible to construct fractions directly in Nemo, without first manually constructing the relevant fraction field. For this purpose we overload Julia's fraction operator \n//\n.\n\n\nHere are some examples of constructing fractions.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\nT = FractionField(S)\n\na = zero(T)\nb = one(T)\nc = (x + 3)//(x^2 + 2)\n\n\n\n\n\n\nBasic functionality\n\n\nAll fraction field modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)\n\n\nDevelopers who are writing their own fraction field module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom fraction field types in Nemo. \n\n\nWe write \nU\n for the type of fraction elements in the fraction field and \nT\n for the type of elements of the base ring.\n\n\nAll of these functions are provided for all existing fraction types in Nemo.\n\n\nparent_type{U \n: FracElem}(::Type{U})\n\n\n\n\nGiven the type of fraction elements, should return the type of the corresponding parent object.\n\n\nelem_type(R::FracField)\n\n\n\n\nGiven a parent object for the fraction field, return the type of elements of the fraction field.\n\n\nBase.hash(a::FracElem, h::UInt)\n\n\n\n\nReturn a \nUInt\n hexadecimal hash of the fraction \na\n. This should be xor'd with a fixed random hexadecimal specific to the fraction type. The hash of the numerator and denominator of a fraction should be xor'd with the supplied parameter \nh\n as part of computing the hash.\n\n\nnum(a::FracElem)\n\n\n\n\nReturn the numerator of the given fraction element, i.e. for \na = b/c\n return \nb\n. The returned numerator will be divided by the canonical unit of the denominator.\n\n\nden(a::FracElem)\n\n\n\n\nReturn the denominator of the given fraction element, i.e. for \na = b/c\n return \nc\n. The returned denominator will be divided by the canonical unit of the denominator.\n\n\ndeepcopy(a::FracElem)\n\n\n\n\nConstruct a copy of the given fraction and return it. This function must recursively construct copies of all of the internal data in the given fraction. Nemo fractions are mutable and so returning shallow copies is not sufficient.\n\n\nmul!(c::FracElem, a::FracElem, b::FracElem)\n\n\n\n\nMultiply \na\n by \nb\n and set the existing fraction \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\naddeq!(c::FracElem, a::FracElem)\n\n\n\n\nIn-place addition. Adds \na\n to \nc\n and sets \nc\n to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.\n\n\nGiven a parent object \nS\n for a fraction field, the following coercion functions are provided to coerce various elements into the fraction field.  Developers provide these by overloading the \ncall\n operator for the fraction field parent objects.\n\n\nS()\n\n\n\n\nCoerce zero into the field \nS\n.\n\n\nS(n::Integer)\nS(n::fmpz)\n\n\n\n\nCoerce an integer value or Flint integer into the fraction field \nS\n.\n\n\nS(n::T)\n\n\n\n\nCoerces an element of the base ring, of type \nT\n into \nS\n.\n\n\nS(f::FracElem)\n\n\n\n\nTake a fraction that is already in the field \nS\n and simply return it. A copy of the original is not made.\n\n\nS(c::RingElem)\n\n\n\n\nTry to coerce the given ring element into the fraction field. This only succeeds if \nc\n can be coerced into the base ring.\n\n\nThere are also the followin constructors for creatinf fracions from a numerator and denominator.\n\n\nS(n::T, d::T)\nS(n::Integer, d::T)\nS(n::T, d::Integer)\n\n\n\n\nCreate the fraction \nn/d\n in the fraction field \nS\n.\n\n\nIn addition to the above, developers of custom fractions must ensure the parent object of a fraction type constains a field \nbase_ring\n specifying the base ring. They must also ensure that each fraction element contains a field \nparent\n specifying the parent object of the fraction.\n\n\nTypically a developer will also overload the \nFractionField\n generic function to create fractions of the custom type they are implementing.\n\n\n\n\nBasic manipulation\n\n\nNumerous functions are provided to manipulate fractions. Also see the section on basic functionality above.\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring{T}(S::FracField{T})\n\n\n\n\n\n\nReturn the base ring \nR\n of the given fraction field.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.base_ring\n \n \nMethod\n.\n\n\nbase_ring{T}(r::FracElem)\n\n\n\n\n\n\nReturn the base ring \nR\n of the fraction field that the supplied element \na\n belongs to.\n\n\n\n\nsource\n\n\n#\n\n\nBase.parent\n \n \nMethod\n.\n\n\nparent(a::FracElem)\n\n\n\n\n\n\nReturn the parent object of the given fraction element.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.iszero\n \n \nMethod\n.\n\n\niszero(a::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is zero in the fraction field it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isone\n \n \nMethod\n.\n\n\nisone(a::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is one in the fraction field it belongs to, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.isunit\n \n \nMethod\n.\n\n\nisunit(a::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if the supplied element \na\n is invertible in the fraction field it belongs to, i.e. the numerator is nonzero, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nSome functions are only available for certain rings.\n\n\n#\n\n\nBase.abs\n \n \nMethod\n.\n\n\nabs(a::fmpq)\n\n\n\n\n\n\nReturn the absolute value of \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.height\n \n \nMethod\n.\n\n\nheight(a::fmpq)\n\n\n\n\n\n\nReturn the height of the fraction \na\n, namely the largest of the absolute values of the numerator and denominator.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.height_bits\n \n \nMethod\n.\n\n\nheight_bits(a::fmpq)\n\n\n\n\n\n\nReturn the number of bits of the height of the fraction \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.\n \n \nMethod\n.\n\n\n(a::fmpq, b::Int)\n\n\n\n\n\n\nReturn \n2^b\\times a\n.\n\n\n\n\nsource\n\n\n\n\nBase.\n \n \nMethod\n.\n\n\n(a::fmpq, b::Int)\n\n\n\n\n\n\nReturn \n2^b/a\n.\n\n\n\n\nsource\n\n\nRational fractions can be compared with each other and with integers. Julia provides the full range of operators \n<, >, \\leq, \\geq\n which depend on the following functions.\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpq, b::fmpq)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::Integer, b::fmpq)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpq, b::Integer)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpq, b::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isless\n \n \nMethod\n.\n\n\nisless(a::fmpz, b::fmpq)\n\n\n\n\n\n\nReturn \ntrue\n if \na < b\n, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of basic manipulation of fractions.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\nf = zero(S)\ng = one(S)\n\na = isunit((x + 1)//(-x^2 + 1))\nb = iszero(f)\nc = isone(g)\nd = abs(ZZ(11)//3)\nU = base_ring(S)\nV = base_ring((x + 1)//(-x^2 + 1))\nW = parent(S(x))\n4 \n= ZZ(7)//ZZ(3)\n\n\n\n\n\n\nArithmetic operators\n\n\nAll the usual arithmetic operators are overloaded for Nemo fractions. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use \ndivexact\n. To construct an element of a fraction field one can use the double slash operator \n//\n.\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x)\n\n\n\n\nUnary minus operator.\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n+{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\ndivexact{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\nThe following ad hoc operators are also provided.\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::Integer, b::FracElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::FracElem, b::Integer)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::fmpz, b::FracElem)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(a::FracElem, b::fmpz)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na + b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::Integer, b::FracElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::FracElem, b::Integer)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::fmpz, b::FracElem)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-(a::FracElem, b::fmpz)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.-\n \n \nMethod\n.\n\n\n-(x, y)\n\n\n\n\nSubtraction operator.\n\n\nsource\n\n\n-{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na - b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::Integer, b::FracElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::FracElem, b::Integer)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::fmpz, b::FracElem)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*(a::FracElem, b::fmpz)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.*\n \n \nMethod\n.\n\n\n*(x, y...)\n\n\n\n\nMultiplication operator. \nx*y*z*...\n calls this function with all arguments, i.e. \n*(x, y, z, ...)\n.\n\n\nsource\n\n\n*{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na\\times b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::Integer, b::FracElem)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::FracElem, b::Integer)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::fmpz, b::FracElem)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact(a::FracElem, b::fmpz)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::T, b::FracElem{T})\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.divexact\n \n \nMethod\n.\n\n\ndivexact{T \n: RingElem}(a::FracElem{T}, b::T)\n\n\n\n\n\n\nReturn \na/b\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.^\n \n \nMethod\n.\n\n\n^(x, y)\n\n\n\n\nExponentiation operator.\n\n\nsource\n\n\nIf the appropriate \npromote_rule\n and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.\n\n\nHere are some examples of arithmetic operations on fractions.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = -((x + 1)//(-x^2 + 1))\nb = -(x + 3)//(x + 1) + (2x + 3)//(x^2 + 4)\nc = (x + 1)//(-x^2 + 1) - x//(2x + 1)\nd = ((x^2 + 3x)//(5x))*((x + 1)//(2x^2 + 2))\nf = a + 2\ng = 3 - a\nh = b*(x + 1)\nk = divexact(a, b)\nm = divexact(a, x + 1)\nn = divexact(b, 23)\np = divexact(ZZ(2), b)\nq = a^3\n\n\n\n\n\n\nComparison operators\n\n\nThe following comparison operators are implemented for fractions in Nemo.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::FracElem{T}, y::FracElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n. Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::FracElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n=={T \n: RingElem}(x::T, y::FracElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \n \nMethod\n.\n\n\nisequal{T \n: RingElem}(x::FracElem{T}, y::FracElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n exactly, otherwise return \nfalse\n. This function is useful in cases where the numerators and denominators of the fractions are inexact, e.g. power series. Only if the power series are precisely the same, to the same precision, are they declared equal by this function.\n\n\n\n\nsource\n\n\nIn addition we have the following ad hoc comparison operators.\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::FracElem{T}, y::T)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n=={T \n: RingElem}(x::T, y::FracElem{T})\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::FracElem, y::Integer)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::Integer, y::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::FracElem, y::fmpz)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.==\n \n \nMethod\n.\n\n\n==(x::fmpz, y::FracElem)\n\n\n\n\n\n\nReturn \ntrue\n if \nx == y\n arithmetically, otherwise return \nfalse\n.\n\n\n\n\nsource\n\n\nHere are some examples of comparisons.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = -(ZZ(4)//ZZ(6))\nb = -((x + 1)//(-x^2 + 1))\n\na == -ZZ(2)//ZZ(3)\nb == 1//(x - 1)\na == 4\nZZ(2) == b\nb == x + 1\n\n\n\n\n\n\nInversion\n\n\n#\n\n\nBase.inv\n \n \nMethod\n.\n\n\ninv(a::FracElem)\n\n\n\n\n\n\nReturn the inverse of the fraction \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of computing inverses.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = (x + 1)//(-x^2 + 1)\n\nb = inv(a)\n\n\n\n\n\n\nGreatest common divisor\n\n\n#\n\n\nBase.gcd\n \n \nMethod\n.\n\n\ngcd{T \n: RingElem}(a::FracElem{T}, b::FracElem{T})\n\n\n\n\n\n\nReturn a greatest common divisor of \na\n and \nb\n if one exists. N.B: we define the GCD of \na/b\n and \nc/d\n to be gcd\n(ad, bc)/bd\n, reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.\n\n\n\n\nsource\n\n\nHere are some examples of computing a greatest common divisor.\n\n\nS, x = PolynomialRing(ZZ, \nx\n)\n\na = -x//(2x + 1)\n\nf = gcd(a, (x + 1)//(x - 1))\n\n\n\n\n\n\nModular arithmetic\n\n\nThe following functions are available for rationals.\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod(a::fmpq, b::fmpz)\n\n\n\n\n\n\nReturn \na \\pmod{b}\n where \nb\n is an integer coprime to the denominator of \na\n.\n\n\n\n\nsource\n\n\n#\n\n\nBase.mod\n \n \nMethod\n.\n\n\nmod(a::fmpq, b::Integer)\n\n\n\n\n\n\nReturn \na \\pmod{b}\n where \nb\n is an integer coprime to the denominator of \na\n.\n\n\n\n\nsource\n\n\nHere are some examples of modular arithmetic.\n\n\na = -fmpz(2)//3\nb = fmpz(1)//2\n\nc = mod(a, 7)\nd = mod(b, fmpz(5))\n\n\n\n\n\n\nRational Reconstruction\n\n\nRational reconstruction is available for rational numbers.\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::fmpz, b::fmpz)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::fmpz, b::Integer)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::Integer, b::fmpz)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.reconstruct\n \n \nMethod\n.\n\n\nreconstruct(a::Integer, b::Integer)\n\n\n\n\n\n\nAttempt to find a rational number \nn/d\n such that  \n0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor\n and  \n0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor\n such that gcd\n(n, d) = 1\n and \na \\equiv nd^{-1} \\pmod{m}\n. If no solution exists, an exception is thrown.\n\n\n\n\nsource\n\n\nHere are some examples of rational reconstruction.\n\n\na = reconstruct(7, 13)\nb = reconstruct(fmpz(15), 31)\nc = reconstruct(fmpz(123), fmpz(237))\n\n\n\n\n\n\nRational enumeration\n\n\nVarious methods exist to enumerator rationals.\n\n\n#\n\n\nNemo.next_minimal\n \n \nMethod\n.\n\n\nnext_minimal(a::fmpq)\n\n\n\n\n\n\nGiven \nx\n, returns the next rational number in the sequence obtained by enumerating all positive denominators \nq\n, and for each \nq\n enumerating the numerators \n1 \\le p < q\n in order and generating both \np/q\n and \nq/p\n, but skipping all gcd\n(p,q) \\neq 1\n. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being \n0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, \\ldots\n. This enumeration produces the rational numbers in order of minimal height.  It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If \nx < 0\n we throw a \nDomainError()\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.next_signed_minimal\n \n \nMethod\n.\n\n\nnext_signed_minimal(a::fmpq)\n\n\n\n\n\n\nGiven a signed rational number \nx\n assumed to be in canonical form,  returns the next element in the minimal-height sequence generated by  \nnext_minimal\n but with negative numbers interleaved. The sequence begins \n0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots\n. Starting with zero, this generates every rational number once and only once, in order of minimal height.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.next_calkin_wilf\n \n \nMethod\n.\n\n\nnext_calkin_wilf(a::fmpq)\n\n\n\n\n\n\nGiven \nx\n return the next number in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being \n0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \\ldots\n. Despite the appearance of the initial entries, the Calkin-Wilf enumeration  does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.next_signed_calkin_wilf\n \n \nMethod\n.\n\n\nnext_signed_calkin_wilf(a::fmpq)\n\n\n\n\n\n\nGiven a signed rational number \nx\n returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins \n0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots\n. Starting with zero, this generates every rational number once and only once, but not in order of minimal height.\n\n\n\n\nsource\n\n\nHere are some examples of rational enumeration.\n\n\nnext_minimal(fmpz(2)//3)\nnext_signed_minimal(-fmpz(21)//31)\nnext_calkin_wilf(fmpz(321)//113)\nnext_signed_calkin_wilf(-fmpz(51)//(17))\n\n\n\n\n\n\nSpecial functions\n\n\nThe following special functions are available for specific rings in Nemo.\n\n\n#\n\n\nNemo.harmonic\n \n \nMethod\n.\n\n\nharmonic(n::Int)\n\n\n\n\n\n\nComputes the harmonic number \nH_n = 1 + 1/2 + 1/3 + \\cdots + 1/n\n. Table lookup is used for \nH_n\n whose numerator and denominator  fit in a single limb. For larger \nn\n, a divide and conquer strategy is used.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bernoulli\n \n \nMethod\n.\n\n\nbernoulli(n::Int)\n\n\n\n\n\n\nComputes the Bernoulli number \nB_n\n for nonnegative \nn\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.bernoulli_cache\n \n \nMethod\n.\n\n\nbernoulli_cache(n::Int)\n\n\n\n\n\n\nPrecomputes and caches all the Bernoulli numbers up to \nB_n\n. This is much faster than repeatedly calling \nbernoulli(k)\n. Once cached, subsequent calls to \nbernoulli(k)\n for any \nk \\le n\n will read from the cache, making them virtually free.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::fmpz, k::fmpz)\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::fmpz, k::Integer)\n\n\n\n\n\n\nComputes the Dedekind sum \ns(h,k)\n for arbitrary \nh\n and \nk\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::Integer, k::fmpz)\n\n\n\n\n\n\nComputes the Dedekind sum \ns(h,k)\n for arbitrary \nh\n and \nk\n.\n\n\n\n\nsource\n\n\n#\n\n\nNemo.dedekind_sum\n \n \nMethod\n.\n\n\ndedekind_sum(h::Integer, k::Integer)\n\n\n\n\n\n\nComputes the Dedekind sum \ns(h,k)\n for arbitrary \nh\n and \nk\n.\n\n\n\n\nsource\n\n\nHere are some examples of special functions.\n\n\na = harmonic(12)\n\nb = dedekind_sum(12, 13)\nc = dedekind_sum(-120, fmpz(1305))\n\nd = bernoulli(12)\n\nbernoulli_cache(100)\ne = bernoulli(100)", 
            "title": "Fraction fields"
        }, 
        {
            "location": "/build/fraction/#introduction", 
            "text": "Nemo allows the creation of fraction fields over any ring  R . We don't require  R  to be an integral domain, however no attempt is made to deal with the general case. Two fractions  a/b  and  c/d  are equal in Nemo iff  ad = bc . Thus, in practice, a greatest common divisor function is currently required for the ring  R .  In order to make the representation  a/b  unique for printing, we have a notion of canonical unit for elements of a ring  R . When canonicalising  a/b , each of the elements  a  and  b  is first divided by the canonical unit of  b .  The  canonical_unit  function is defined for elements of every Nemo ring. It must have the properties  canonical_unit(u) == u\ncanonical_unit(a*b) == canonical_unit(a)*canonical_unit(b)  for any unit  u  of the ring in question, and  a  and  b  arbitrary elements of the ring.  For example, the canonical unit of an integer is its sign. Thus a fraction of integers always has positive denominator after canonicalisation.  The canonical unit of a polynomial is the canonical unit of its leading coefficient, etc.  There are two different kinds of implementation of fraction fields in Nemo: a generic one for the case where no specific implementation exists, and efficient implementations of fractions over specific rings, usually provided by C/C++ libraries.  The following table shows each of the fraction types available in Nemo, the base ring  R , and the Julia/Nemo types for that kind of fraction (the type information is mainly of concern to developers).     Base ring  Library  Element type  Parent type      Generic ring  R   Nemo  GenFrac{T}  GenFracField{T}     \\mathbb{Z}   Flint  fmpq  FlintRationalField     All fraction element types belong to the abstract type  FracElem  and all of the fraction field types belong to the abstract type  FracField . This enables one to write generic functions that can accept any Nemo fraction type.", 
            "title": "Introduction"
        }, 
        {
            "location": "/build/fraction/#fraction-field-constructors", 
            "text": "In order to construct fractions in Nemo, one must first construct the fraction field itself. This can be accomplished manually with the following constructor.  #  Nemo.FractionField     Method .  FractionField(R::Ring; cached=true)   Return the parent object of the fraction field over the given base ring  R . If  cached == true  (the default), the returned parent object is cached so that it will always be returned by a call to the constructor when the same base ring  R  is supplied.   source  Note: it is also possible to construct fractions directly in Nemo without manually constructing the fraction field. In such cases, Nemo creates the relevant fraction field internally.  For convenience, the rational fraction field is constructed automatically in Nemo. We have the definition  QQ = FractionField(ZZ)  Here are some examples of creating fraction fields and making use of the resulting parent objects to coerce various elements into those fields.  R = FractionField(ZZ)\nS, x = PolynomialRing(ZZ,  x )\nT = FractionField(S)\n\na = R(1)\nb = T(fmpz(3))\nc = T(x)\nd = QQ(11)", 
            "title": "Fraction field constructors"
        }, 
        {
            "location": "/build/fraction/#fraction-constructors", 
            "text": "Once a fraction field is constructed, there are various ways to construct fractions in that field.  Apart from coercing elements into the fraction field as above, we offer the following functions.  #  Base.zero     Method .  zero(R::FracField)   Return  0/1  in the given fraction field.   source  #  Base.one     Method .  one(R::FracField)   Return  1/1  in the given fraction field.   source  It is also possible to construct fractions directly in Nemo, without first manually constructing the relevant fraction field. For this purpose we overload Julia's fraction operator  // .  Here are some examples of constructing fractions.  S, x = PolynomialRing(ZZ,  x )\nT = FractionField(S)\n\na = zero(T)\nb = one(T)\nc = (x + 3)//(x^2 + 2)", 
            "title": "Fraction constructors"
        }, 
        {
            "location": "/build/fraction/#basic-functionality", 
            "text": "All fraction field modules in Nemo must provide the functionality listed in this section. (Note that only some of these functions are useful to a user.)  Developers who are writing their own fraction field module, whether as an interface to a C library, or as some kind of generic module, must provide all of these functions for custom fraction field types in Nemo.   We write  U  for the type of fraction elements in the fraction field and  T  for the type of elements of the base ring.  All of these functions are provided for all existing fraction types in Nemo.  parent_type{U  : FracElem}(::Type{U})  Given the type of fraction elements, should return the type of the corresponding parent object.  elem_type(R::FracField)  Given a parent object for the fraction field, return the type of elements of the fraction field.  Base.hash(a::FracElem, h::UInt)  Return a  UInt  hexadecimal hash of the fraction  a . This should be xor'd with a fixed random hexadecimal specific to the fraction type. The hash of the numerator and denominator of a fraction should be xor'd with the supplied parameter  h  as part of computing the hash.  num(a::FracElem)  Return the numerator of the given fraction element, i.e. for  a = b/c  return  b . The returned numerator will be divided by the canonical unit of the denominator.  den(a::FracElem)  Return the denominator of the given fraction element, i.e. for  a = b/c  return  c . The returned denominator will be divided by the canonical unit of the denominator.  deepcopy(a::FracElem)  Construct a copy of the given fraction and return it. This function must recursively construct copies of all of the internal data in the given fraction. Nemo fractions are mutable and so returning shallow copies is not sufficient.  mul!(c::FracElem, a::FracElem, b::FracElem)  Multiply  a  by  b  and set the existing fraction  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  addeq!(c::FracElem, a::FracElem)  In-place addition. Adds  a  to  c  and sets  c  to the result. This function is provided for performance reasons as it saves allocating a new object for the result and eliminates associated garbage collection.  Given a parent object  S  for a fraction field, the following coercion functions are provided to coerce various elements into the fraction field.  Developers provide these by overloading the  call  operator for the fraction field parent objects.  S()  Coerce zero into the field  S .  S(n::Integer)\nS(n::fmpz)  Coerce an integer value or Flint integer into the fraction field  S .  S(n::T)  Coerces an element of the base ring, of type  T  into  S .  S(f::FracElem)  Take a fraction that is already in the field  S  and simply return it. A copy of the original is not made.  S(c::RingElem)  Try to coerce the given ring element into the fraction field. This only succeeds if  c  can be coerced into the base ring.  There are also the followin constructors for creatinf fracions from a numerator and denominator.  S(n::T, d::T)\nS(n::Integer, d::T)\nS(n::T, d::Integer)  Create the fraction  n/d  in the fraction field  S .  In addition to the above, developers of custom fractions must ensure the parent object of a fraction type constains a field  base_ring  specifying the base ring. They must also ensure that each fraction element contains a field  parent  specifying the parent object of the fraction.  Typically a developer will also overload the  FractionField  generic function to create fractions of the custom type they are implementing.", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/build/fraction/#basic-manipulation", 
            "text": "Numerous functions are provided to manipulate fractions. Also see the section on basic functionality above.  #  Nemo.base_ring     Method .  base_ring{T}(S::FracField{T})   Return the base ring  R  of the given fraction field.   source  #  Nemo.base_ring     Method .  base_ring{T}(r::FracElem)   Return the base ring  R  of the fraction field that the supplied element  a  belongs to.   source  #  Base.parent     Method .  parent(a::FracElem)   Return the parent object of the given fraction element.   source  #  Nemo.iszero     Method .  iszero(a::FracElem)   Return  true  if the supplied element  a  is zero in the fraction field it belongs to, otherwise return  false .   source  #  Nemo.isone     Method .  isone(a::FracElem)   Return  true  if the supplied element  a  is one in the fraction field it belongs to, otherwise return  false .   source  #  Nemo.isunit     Method .  isunit(a::FracElem)   Return  true  if the supplied element  a  is invertible in the fraction field it belongs to, i.e. the numerator is nonzero, otherwise return  false .   source  Some functions are only available for certain rings.  #  Base.abs     Method .  abs(a::fmpq)   Return the absolute value of  a .   source  #  Nemo.height     Method .  height(a::fmpq)   Return the height of the fraction  a , namely the largest of the absolute values of the numerator and denominator.   source  #  Nemo.height_bits     Method .  height_bits(a::fmpq)   Return the number of bits of the height of the fraction  a .   source  #  Base.     Method .  (a::fmpq, b::Int)   Return  2^b\\times a .   source   Base.     Method .  (a::fmpq, b::Int)   Return  2^b/a .   source  Rational fractions can be compared with each other and with integers. Julia provides the full range of operators  <, >, \\leq, \\geq  which depend on the following functions.  #  Base.isless     Method .  isless(a::fmpq, b::fmpq)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::Integer, b::fmpq)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::fmpq, b::Integer)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::fmpq, b::fmpz)   Return  true  if  a < b , otherwise return  false .   source  #  Base.isless     Method .  isless(a::fmpz, b::fmpq)   Return  true  if  a < b , otherwise return  false .   source  Here are some examples of basic manipulation of fractions.  S, x = PolynomialRing(ZZ,  x )\n\nf = zero(S)\ng = one(S)\n\na = isunit((x + 1)//(-x^2 + 1))\nb = iszero(f)\nc = isone(g)\nd = abs(ZZ(11)//3)\nU = base_ring(S)\nV = base_ring((x + 1)//(-x^2 + 1))\nW = parent(S(x))\n4  = ZZ(7)//ZZ(3)", 
            "title": "Basic manipulation"
        }, 
        {
            "location": "/build/fraction/#arithmetic-operators", 
            "text": "All the usual arithmetic operators are overloaded for Nemo fractions. Note that Julia uses the single slash for floating point division. Therefore to perform exact division in a ring we use  divexact . To construct an element of a fraction field one can use the double slash operator  // .  #  Base.-     Method .  -(x)  Unary minus operator.  source  #  Base.+     Method .  +{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return  a + b .   source  +{T  : RingElem}(a::FracElem{T}, b::T)   Return  a + b .   source  +{T  : RingElem}(a::T, b::FracElem{T})   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return  a - b .   source  -{T  : RingElem}(a::FracElem{T}, b::T)   Return  a - b .   source  -{T  : RingElem}(a::T, b::FracElem{T})   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return  a\\times b .   source  *{T  : RingElem}(a::FracElem{T}, b::T)   Return  a\\times b .   source  *{T  : RingElem}(a::T, b::FracElem{T})   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return  a/b .   source  divexact{T  : RingElem}(a::FracElem{T}, b::T)   Return  a/b .   source  divexact{T  : RingElem}(a::T, b::FracElem{T})   Return  a/b .   source  The following ad hoc operators are also provided.  #  Base.+     Method .  +(a::Integer, b::FracElem)   Return  a + b .   source  #  Base.+     Method .  +(a::FracElem, b::Integer)   Return  a + b .   source  #  Base.+     Method .  +(a::fmpz, b::FracElem)   Return  a + b .   source  #  Base.+     Method .  +(a::FracElem, b::fmpz)   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::T, b::FracElem{T})   Return  a + b .   source  #  Base.+     Method .  +{T  : RingElem}(a::FracElem{T}, b::T)   Return  a + b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::Integer, b::FracElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::FracElem, b::Integer)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::fmpz, b::FracElem)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -(a::FracElem, b::fmpz)   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::T, b::FracElem{T})   Return  a - b .   source  #  Base.-     Method .  -(x, y)  Subtraction operator.  source  -{T  : RingElem}(a::FracElem{T}, b::T)   Return  a - b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::Integer, b::FracElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::FracElem, b::Integer)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::fmpz, b::FracElem)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *(a::FracElem, b::fmpz)   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::T, b::FracElem{T})   Return  a\\times b .   source  #  Base.*     Method .  *(x, y...)  Multiplication operator.  x*y*z*...  calls this function with all arguments, i.e.  *(x, y, z, ...) .  source  *{T  : RingElem}(a::FracElem{T}, b::T)   Return  a\\times b .   source  #  Nemo.divexact     Method .  divexact(a::Integer, b::FracElem)   Return  a/b .   source  #  Nemo.divexact     Method .  divexact(a::FracElem, b::Integer)   Return  a/b .   source  #  Nemo.divexact     Method .  divexact(a::fmpz, b::FracElem)   Return  a/b .   source  #  Nemo.divexact     Method .  divexact(a::FracElem, b::fmpz)   Return  a/b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::T, b::FracElem{T})   Return  a/b .   source  #  Nemo.divexact     Method .  divexact{T  : RingElem}(a::FracElem{T}, b::T)   Return  a/b .   source  #  Base.^     Method .  ^(x, y)  Exponentiation operator.  source  If the appropriate  promote_rule  and coercion exists, these operators can also be used with elements of other rings. Nemo will try to coerce the operands to the dominating type and then apply the operator.  Here are some examples of arithmetic operations on fractions.  S, x = PolynomialRing(ZZ,  x )\n\na = -((x + 1)//(-x^2 + 1))\nb = -(x + 3)//(x + 1) + (2x + 3)//(x^2 + 4)\nc = (x + 1)//(-x^2 + 1) - x//(2x + 1)\nd = ((x^2 + 3x)//(5x))*((x + 1)//(2x^2 + 2))\nf = a + 2\ng = 3 - a\nh = b*(x + 1)\nk = divexact(a, b)\nm = divexact(a, x + 1)\nn = divexact(b, 23)\np = divexact(ZZ(2), b)\nq = a^3", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/build/fraction/#comparison-operators", 
            "text": "The following comparison operators are implemented for fractions in Nemo.  #  Base.==     Method .  =={T  : RingElem}(x::FracElem{T}, y::FracElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false . Recall that power series to different precisions may still be arithmetically equal to the minimum of the two precisions.   source  =={T  : RingElem}(x::FracElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  =={T  : RingElem}(x::T, y::FracElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.isequal     Method .  isequal{T  : RingElem}(x::FracElem{T}, y::FracElem{T})   Return  true  if  x == y  exactly, otherwise return  false . This function is useful in cases where the numerators and denominators of the fractions are inexact, e.g. power series. Only if the power series are precisely the same, to the same precision, are they declared equal by this function.   source  In addition we have the following ad hoc comparison operators.  #  Base.==     Method .  =={T  : RingElem}(x::FracElem{T}, y::T)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  =={T  : RingElem}(x::T, y::FracElem{T})   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::FracElem, y::Integer)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::Integer, y::FracElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::FracElem, y::fmpz)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  #  Base.==     Method .  ==(x::fmpz, y::FracElem)   Return  true  if  x == y  arithmetically, otherwise return  false .   source  Here are some examples of comparisons.  S, x = PolynomialRing(ZZ,  x )\n\na = -(ZZ(4)//ZZ(6))\nb = -((x + 1)//(-x^2 + 1))\n\na == -ZZ(2)//ZZ(3)\nb == 1//(x - 1)\na == 4\nZZ(2) == b\nb == x + 1", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/build/fraction/#inversion", 
            "text": "#  Base.inv     Method .  inv(a::FracElem)   Return the inverse of the fraction  a .   source  Here are some examples of computing inverses.  S, x = PolynomialRing(ZZ,  x )\n\na = (x + 1)//(-x^2 + 1)\n\nb = inv(a)", 
            "title": "Inversion"
        }, 
        {
            "location": "/build/fraction/#greatest-common-divisor", 
            "text": "#  Base.gcd     Method .  gcd{T  : RingElem}(a::FracElem{T}, b::FracElem{T})   Return a greatest common divisor of  a  and  b  if one exists. N.B: we define the GCD of  a/b  and  c/d  to be gcd (ad, bc)/bd , reduced to lowest terms. This requires the existence of a greatest common divisor function for the base ring.   source  Here are some examples of computing a greatest common divisor.  S, x = PolynomialRing(ZZ,  x )\n\na = -x//(2x + 1)\n\nf = gcd(a, (x + 1)//(x - 1))", 
            "title": "Greatest common divisor"
        }, 
        {
            "location": "/build/fraction/#modular-arithmetic", 
            "text": "The following functions are available for rationals.  #  Base.mod     Method .  mod(a::fmpq, b::fmpz)   Return  a \\pmod{b}  where  b  is an integer coprime to the denominator of  a .   source  #  Base.mod     Method .  mod(a::fmpq, b::Integer)   Return  a \\pmod{b}  where  b  is an integer coprime to the denominator of  a .   source  Here are some examples of modular arithmetic.  a = -fmpz(2)//3\nb = fmpz(1)//2\n\nc = mod(a, 7)\nd = mod(b, fmpz(5))", 
            "title": "Modular arithmetic"
        }, 
        {
            "location": "/build/fraction/#rational-reconstruction", 
            "text": "Rational reconstruction is available for rational numbers.  #  Nemo.reconstruct     Method .  reconstruct(a::fmpz, b::fmpz)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  #  Nemo.reconstruct     Method .  reconstruct(a::fmpz, b::Integer)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  #  Nemo.reconstruct     Method .  reconstruct(a::Integer, b::fmpz)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  #  Nemo.reconstruct     Method .  reconstruct(a::Integer, b::Integer)   Attempt to find a rational number  n/d  such that   0 \\leq |n| \\leq \\lfloor\\sqrt{m/2}\\rfloor  and   0 < d \\leq \\lfloor\\sqrt{m/2}\\rfloor  such that gcd (n, d) = 1  and  a \\equiv nd^{-1} \\pmod{m} . If no solution exists, an exception is thrown.   source  Here are some examples of rational reconstruction.  a = reconstruct(7, 13)\nb = reconstruct(fmpz(15), 31)\nc = reconstruct(fmpz(123), fmpz(237))", 
            "title": "Rational Reconstruction"
        }, 
        {
            "location": "/build/fraction/#rational-enumeration", 
            "text": "Various methods exist to enumerator rationals.  #  Nemo.next_minimal     Method .  next_minimal(a::fmpq)   Given  x , returns the next rational number in the sequence obtained by enumerating all positive denominators  q , and for each  q  enumerating the numerators  1 \\le p < q  in order and generating both  p/q  and  q/p , but skipping all gcd (p,q) \\neq 1 . Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being  0, 1, 1/2, 2, 1/3, 3, 2/3, 3/2, 1/4, 4, 3/4, 4/3, \\ldots . This enumeration produces the rational numbers in order of minimal height.  It has the disadvantage of being somewhat slower to compute than the Calkin-Wilf enumeration. If  x < 0  we throw a  DomainError() .   source  #  Nemo.next_signed_minimal     Method .  next_signed_minimal(a::fmpq)   Given a signed rational number  x  assumed to be in canonical form,  returns the next element in the minimal-height sequence generated by   next_minimal  but with negative numbers interleaved. The sequence begins  0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots . Starting with zero, this generates every rational number once and only once, in order of minimal height.   source  #  Nemo.next_calkin_wilf     Method .  next_calkin_wilf(a::fmpq)   Given  x  return the next number in the breadth-first traversal of the Calkin-Wilf tree. Starting with zero, this generates every nonnegative rational number once and only once, with the first few entries being  0, 1, 1/2, 2, 1/3, 3/2, 2/3, 3, 1/4, 4/3, 3/5, 5/2, 2/5, \\ldots . Despite the appearance of the initial entries, the Calkin-Wilf enumeration  does not produce the rational numbers in order of height: some small fractions will appear late in the sequence. This order has the advantage of being faster to produce than the minimal-height order.   source  #  Nemo.next_signed_calkin_wilf     Method .  next_signed_calkin_wilf(a::fmpq)   Given a signed rational number  x  returns the next element in the Calkin-Wilf sequence with negative numbers interleaved. The sequence begins  0, 1, -1, 1/2, -1/2, 2, -2, 1/3, -1/3, \\ldots . Starting with zero, this generates every rational number once and only once, but not in order of minimal height.   source  Here are some examples of rational enumeration.  next_minimal(fmpz(2)//3)\nnext_signed_minimal(-fmpz(21)//31)\nnext_calkin_wilf(fmpz(321)//113)\nnext_signed_calkin_wilf(-fmpz(51)//(17))", 
            "title": "Rational enumeration"
        }, 
        {
            "location": "/build/fraction/#special-functions", 
            "text": "The following special functions are available for specific rings in Nemo.  #  Nemo.harmonic     Method .  harmonic(n::Int)   Computes the harmonic number  H_n = 1 + 1/2 + 1/3 + \\cdots + 1/n . Table lookup is used for  H_n  whose numerator and denominator  fit in a single limb. For larger  n , a divide and conquer strategy is used.   source  #  Nemo.bernoulli     Method .  bernoulli(n::Int)   Computes the Bernoulli number  B_n  for nonnegative  n .   source  #  Nemo.bernoulli_cache     Method .  bernoulli_cache(n::Int)   Precomputes and caches all the Bernoulli numbers up to  B_n . This is much faster than repeatedly calling  bernoulli(k) . Once cached, subsequent calls to  bernoulli(k)  for any  k \\le n  will read from the cache, making them virtually free.   source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::fmpz, k::fmpz)  source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::fmpz, k::Integer)   Computes the Dedekind sum  s(h,k)  for arbitrary  h  and  k .   source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::Integer, k::fmpz)   Computes the Dedekind sum  s(h,k)  for arbitrary  h  and  k .   source  #  Nemo.dedekind_sum     Method .  dedekind_sum(h::Integer, k::Integer)   Computes the Dedekind sum  s(h,k)  for arbitrary  h  and  k .   source  Here are some examples of special functions.  a = harmonic(12)\n\nb = dedekind_sum(12, 13)\nc = dedekind_sum(-120, fmpz(1305))\n\nd = bernoulli(12)\n\nbernoulli_cache(100)\ne = bernoulli(100)", 
            "title": "Special functions"
        }
    ]
}
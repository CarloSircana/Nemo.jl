<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="William Hart">
  
  <title>Univariate polynomials - Nemo.jl</title>
  

  <link rel="shortcut icon" href="../../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../build/assets/Documenter.css" rel="stylesheet">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Univariate polynomials";
    var mkdocs_page_input_path = "src/polynomial.md";
    var mkdocs_page_url = "/src/polynomial/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 
  <script src="../../mathjaxhelper.js"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Nemo.jl</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Getting Started</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../about/">About Nemo</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../types/">Types in Nemo</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../constructors/">Parent object constructors</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Univariate polynomials</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#polynomial-element-constructors">Polynomial element constructors</a></li>
                
            
                <li class="toctree-l3"><a href="#comparison-operators">Comparison operators</a></li>
                
            
                <li class="toctree-l3"><a href="#truncation">Truncation</a></li>
                
            
                <li class="toctree-l3"><a href="#reversal">Reversal</a></li>
                
            
                <li class="toctree-l3"><a href="#shifting">Shifting</a></li>
                
            
                <li class="toctree-l3"><a href="#modulo-arithmetic">Modulo arithmetic</a></li>
                
            
                <li class="toctree-l3"><a href="#euclidean-division">Euclidean division</a></li>
                
            
                <li class="toctree-l3"><a href="#pseudodivision">Pseudodivision</a></li>
                
            
                <li class="toctree-l3"><a href="#content-primitive-part-gcd-and-lcm">Content, primitive part, GCD and LCM</a></li>
                
            
                <li class="toctree-l3"><a href="#derivative-and-integral">Derivative and integral</a></li>
                
            
                <li class="toctree-l3"><a href="#resultant-and-discriminant">Resultant and discriminant</a></li>
                
            
                <li class="toctree-l3"><a href="#newton-representation">Newton representation</a></li>
                
            
                <li class="toctree-l3"><a href="#interpolation">Interpolation</a></li>
                
            
            </ul>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Nemo.jl</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Univariate polynomials</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/Nemocas/Nemo.jl" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>```@meta
CurrentModule = Nemo</p>
<pre><code>
# Univariate polynomials

Nemo allow the creation of dense, univariate polynomials over any ring $R$.

## Polynomial types

Although the user rarely needs to deal directly with Julia types for Nemo
objects, we provide the relevant information here for developers.

Generic univariate polynomials in Nemo have type `GenPoly{T}`, where `T` is the
type of the coefficients of the polynomial.

The string representation of the variable and the base ring $R$ of a generic
polynomial is stored in its parent object. Parent objects of generic univariate
polynomials have type `GenPolyRing{T}`.

In addition to generic polynomials, Nemo provides access to numerous polynomial
implementations over specific rings, provided by C/C++ libraries. The following
table shows each of the polynomial types available in Nemo, their base ring $R$,
the type of their parent objects and the library providing those types.

Base ring                             | Library             | Element type        | Parent type
--------------------------------------|---------------------|---------------------|----------------------
Generic ring $R$                      | Nemo                | `GenPoly{T}`        | `GenPolyRing{T}`
$\mathbb{Z}$                          | Flint               | `fmpz_poly`         | `FmpzPolyRing`
$\mathbb{Z}/n\mathbb{Z}$ (small $n$)  | Flint               | `nmod_poly`         | `NmodPolyRing`
$\mathbb{Z}/n\mathbb{Z}$ (large $n$)  | Flint               | `fmpz_mod_poly`     | `FmpzModPolyRing`
$\mathbb{Q}$                          | Flint               | `fmpq_poly`         | `FmpqPolyRing`
$\mathbb{F}_{p^n}$ (small $n$)        | Flint               | `fq_nmod_poly`      | `FqNmodPolyRing`
$\mathbb{F}_{p^n}$ (large $n$)        | Flint               | `fq_poly`           | `FqPolyRing`

All polynomial element types belong to the abstract type `PolyElem` and all of
the polynomial ring types belong to the abstract type `PolyRing`. This enables
one to write generic functions that can accept any Nemo polynomial type.

## Basic functionality

All univariate polynomial modules in Nemo must provide the functionality listed
below. Note that only some of these functions are useful to a user.

Developers who are writing their own polynomial module, whether as an interface
to a C library, or as some kind of generic module, must provide all of these
functions for custom univariate polynomial types in Nemo. 

We write `T` for the type of the polynomials in the polynomial ring.

All of these functions are provided for all existing polynomial types in Nemo.

</code></pre>

<p>parent_type{T &lt;: PolyElem}(::Type{T})</p>
<pre><code>
Given the type of polynomial elements, should return the type of the
corresponding parent object.

</code></pre>

<p>elem_type(R::PolyRing)</p>
<pre><code>
Given a parent object for the polynomial ring, return the type of elements
of the polynomial ring.

</code></pre>

<p>Base.hash(a::PolyElem, h::UInt)</p>
<pre><code>
Return a `UInt` hexadecimal hash of the polynomial $a$. This should be xor'd
with a fixed random hexadecimal specific to the polynomial type. The hash of
each coefficient should be xor'd with the supplied parameter `h` as part of
computing the hash.

</code></pre>

<p>fit!(a::PolyElem, n::Int)</p>
<pre><code>
By reallocating if necessary, ensure that the given polynomial has space for at
least $n$ coefficients. This function does not change the length of the
polynomial and will only ever increase the number of allocated coefficients.
Any coefficients added by this function are initialised to zero.

</code></pre>

<p>normalise(a::PolyElem, n::Int)</p>
<pre><code>
Return the normalised length of the given polynomial, assuming its current
length is $n$. Its normalised length is such that it either has nonzero
leading term or is the zero polynomial. Note that this function doesn't
normalise the polynomial. That can be done with a subsequent call to
`set_length!` using the length returned by `normalise`.

</code></pre>

<p>set_length!(a::PolyElem, n::Int)</p>
<pre><code>
Set the length of an existing polynomial that has sufficient space allocated,
i.e. a polynomial for which no reallocation is needed. Note that if the Julia
type definition for a custom polynomial type has a field, `length`, which
corresponds to the current length of the polynomial, then the developer doesn't
need to supply this function, as the supplied generic implementation will work.
Note that it can change the length to any value from zero to the number of
coefficients currently allocated and initialised.

</code></pre>

<p>length(a::PolyElem)</p>
<pre><code>
Return the current length (not the number of allocated coefficients), of the
given polynomial. Note that this function only needs to be provided by a
developer for a custome polynomial type if the Julia type definition for
polynomial elements doesn't contain a field `length` corresponding to the
current length of the polynomial. Otherwise the supplied generic implementation
will work.

</code></pre>

<p>coeff(a::PolyElem, n::Int)</p>
<pre><code>
Return the degree `n` coefficient of the given polynomial. Note coefficients
are numbered from `n = 0` for the constant coefficient. If $n$ is bigger
then the degree of the polynomial, the function returns a zero coefficient.
We require $n \geq 0$. 

</code></pre>

<p>setcoeff!{T &lt;: RingElem}(a::PolyElem{T}, n::Int, c::T)</p>
<pre><code>
Set the coefficient of the degree $n$ term of the given polynomial to the given
value `a`. The polynomial is not normalised automatically after this operation,
however the polynomial is automatically resized if there is not sufficient
allocated space.

</code></pre>

<p>deepcopy(a::PolyElem)</p>
<pre><code>
Construct a copy of the given polynomial and return it. This function must
recursively construct copies of all of the internal data in the given
polynomial. Nemo polynomials are mutable and so returning shallow copies is not
sufficient.

</code></pre>

<p>mul!(c::PolyElem, a::PolyElem, b::PolyElem)</p>
<pre><code>
Multiply $a$ by $b$ and set the existing polynomial $c$ to the result. This
function is provided for performance reasons as it saves allocating a new
object for the result and eliminates associated garbage collection.

</code></pre>

<p>addeq!(c::PolyElem, a::PolyElem)</p>
<pre><code>
In-place addition. Adds $a$ to $c$ and sets $c$ to the result. This function
is provided for performance reasons as it saves allocating a new object for
the result and eliminates associated garbage collection.

Given a parent object `S` for a polynomial ring, the following coercion
functions are provided to coerce various elements into the polynomial
ring. Developers provide these by overloading the `call` operator for the
polynomial parent objects.

</code></pre>

<p>S()</p>
<pre><code>
Coerce zero into the ring $S$.

</code></pre>

<p>S(n::Integer)
S(n::fmpz)</p>
<pre><code>
Coerce an integer value or Flint integer into the polynomial ring $S$.

</code></pre>

<p>S(n::T)</p>
<pre><code>
Coerces an element of the base ring, of type `T` into $S$.

</code></pre>

<p>S(A::Array{T, 1})</p>
<pre><code>
Take an array of elements in the base ring, of type `T` and construct the
polynomial with those coefficients, starting with the constant coefficient.

</code></pre>

<p>S(f::PolyElem)</p>
<pre><code>
Take a polynomial that is already in the ring $S$ and simply return it. A copy
of the original is not made.

</code></pre>

<p>S(c::RingElem)</p>
<pre><code>
Try to coerce the given ring element into the polynomial ring. This only
succeeds if $c$ can be coerced into the base ring.

In addition to the above, developers of custom polynomials must ensure the
parent object of a polynomial type constains a field `base_ring` specifying the
base ring, a field `S` containing a symbol (not a string) representing the
variable name of the polynomial ring. They must also ensure that each
polynomial element contains a field `parent` specifying the parent object of
the polynomial.

Typically a developer will also overload the `PolynomialRing` generic function
to create polynomials of the custom type they are implementing.

## Polynomial ring constructors

In order to construct polynomials, one must first construct the polynomial ring
itself. This is accomplished with the following constructor.

```@docs
PolynomialRing(::Ring, ::AbstractString{}, ::Bool)
</code></pre>

<p>A shorthand version of this function is provided. Given a base ring <code>R</code>, we can
abbreviate the above constructor as follows.</p>
<pre><code>R[&quot;x&quot;]
</code></pre>

<p>Here are some examples of creating polynomial rings and making use of the
resulting parent objects to coerce various elements into the polynomial ring.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)
T, z = QQ[&quot;z&quot;]

f = R()
g = R(123)
h = S(ZZ(1234))
k = S(x + 1)
m = T(z + 1)
</code></pre>

<h2 id="polynomial-element-constructors">Polynomial element constructors</h2>
<p>Once a polynomial ring is constructed, there are various ways to construct
polynomials in that ring.</p>
<p>The easiest way is simply using the generator returned by the <code>PolynomialRing</code>
constructor and and build up the polynomial using basic arithmetic. Julia has
quite flexible notation for the construction of polynomials in this way.</p>
<p>In addition we provide the following functions for constructing certain useful
polynomials.</p>
<p>```@docs
zero(::PolyRing)</p>
<pre><code>
```@docs
one(::PolyRing)
</code></pre>

<p>```@docs
gen(::PolyRing)</p>
<pre><code>
Here are some examples of constructing polynomials.

</code></pre>

<p>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")</p>
<p>f = x^3 + 3x + 21
g = (x + 1)*y^2 + 2x + 1</p>
<p>h = zero(S)
k = one(R)
m = gen(S)</p>
<pre><code>
## Basic manipulation

Numerous functions are provided to manipulate polynomials and to set and
retrieve coefficients and other basic data associated with the polynomials.
Also see the section on basic functionality above.

```@docs
base_ring(::PolyRing)
</code></pre>

<p>```@docs
base_ring(::PolyElem)</p>
<pre><code>
```@docs
parent(::PolyElem)
</code></pre>

<p>```@docs
var(::PolyRing)</p>
<pre><code>
```@docs
degree(::PolyElem)
</code></pre>

<p>```@docs
modulus{T &lt;: ResElem}(::PolyElem{T})</p>
<pre><code>
```@docs
lead(::PolyElem)
</code></pre>

<p>```@docs
iszero(::PolyElem)</p>
<pre><code>
```@docs
isone(::PolyElem)
</code></pre>

<p>```@docs
isgen(::PolyElem)</p>
<pre><code>
```@docs
isunit(::PolyElem)
</code></pre>

<p>```@docs
den(::fmpq_poly)</p>
<pre><code>
Here are some examples of basic manipulation of polynomials.

</code></pre>

<p>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")
T, z = PolynomialRing(QQ, "z")</p>
<p>a = zero(S)
b = one(S)</p>
<p>c = ZZ(1)//2<em>z^2 + ZZ(1)//3
d = x</em>y^2 + (x + 1)*y + 3</p>
<p>U = base_ring(S)
V = base_ring(y + 1)
v = var(S)
T = parent(y + 1)</p>
<p>f = lead(d)</p>
<p>g = isgen(y)
h = isone(b)
k = iszero(a)
m = isunit(b)
n = degree(d)
p = length(b)
q = den(c)</p>
<pre><code>
## Arithmetic operators

All the usual arithmetic operators are overloaded for Nemo polynomials. Note
that Julia uses the single slash for floating point division. Therefore to
perform exact division in a ring we use `divexact`. To construct an element
of a fraction field one can use the double slash operator `//`.

```@docs
-(::PolyElem)
</code></pre>

<p>```@docs
+{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
-{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})
</code></pre>

<p>```@docs
*{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
divexact(::PolyElem, ::PolyElem)
</code></pre>

<p>The following ad hoc operators are also provided.</p>
<p>```@docs
+(::Integer, ::PolyElem)</p>
<pre><code>
```@docs
+(::PolyElem, ::Integer)
</code></pre>

<p>```@docs
+(::fmpz, ::PolyElem)</p>
<pre><code>
```@docs
+(::PolyElem, ::fmpz)
</code></pre>

<p>```@docs
+{T &lt;: RingElem}(::T, ::PolyElem{T})</p>
<pre><code>
```@docs
+{T &lt;: RingElem}(::PolyElem, ::T)
</code></pre>

<p>```@docs
-(::Integer, ::PolyElem)</p>
<pre><code>
```@docs
-(::PolyElem, ::Integer)
</code></pre>

<p>```@docs
-(::fmpz, ::PolyElem)</p>
<pre><code>
```@docs
-(::PolyElem, ::fmpz)
</code></pre>

<p>```@docs
-{T &lt;: RingElem}(::T, ::PolyElem{T})</p>
<pre><code>
```@docs
-{T &lt;: RingElem}(::PolyElem, ::T)
</code></pre>

<p>```@docs
*(::Integer, ::PolyElem)</p>
<pre><code>
```@docs
*(::PolyElem, ::Integer)
</code></pre>

<p>```@docs
*(::fmpz, ::PolyElem)</p>
<pre><code>
```@docs
*(::PolyElem, ::fmpz)
</code></pre>

<p>```@docs
*{T &lt;: RingElem}(::T, ::PolyElem{T})</p>
<pre><code>
```@docs
*{T &lt;: RingElem}(::PolyElem, ::T)
</code></pre>

<p>```@docs
divexact(::PolyElem, ::Integer)</p>
<pre><code>
```@docs
divexact(::PolyElem, ::fmpz)
</code></pre>

<p>```@docs
divexact{T &lt;: RingElem}(::PolyElem{T}, ::T)</p>
<pre><code>
```@docs
^(::PolyElem, ::Int)
</code></pre>

<p>If the appropriate <code>promote_rule</code> and coercion exists, these operators can also
be used with elements of other rings. Nemo will try to coerce the operands to
the dominating type and then apply the operator.</p>
<p>Here are some examples of arithmetic operations on polynomials.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = f - g
k = f*g
m = f + g
n = g - 4
p = fmpz(5) - g
q = f*7
r = divexact(f, -1)
s = divexact(g*(x + 1), x + 1)
t = f^3
</code></pre>

<h2 id="comparison-operators">Comparison operators</h2>
<p>The following comparison operators are implemented for polynomials in Nemo.</p>
<p>```@docs
=={T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
isequal{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})
</code></pre>

<p>In addition we have the following ad hoc comparison operators.</p>
<p>```@docs
=={T &lt;: RingElem}(::PolyElem{T}, ::T)</p>
<pre><code>
```@docs
=={T &lt;: RingElem}(::T, ::PolyElem{T})
</code></pre>

<p>```@docs
==(::PolyElem, ::Integer)</p>
<pre><code>
```@docs
==(::Integer, ::PolyElem)
</code></pre>

<p>```@docs
==(::PolyElem, ::fmpz)</p>
<pre><code>
```@docs
==(::fmpz, ::PolyElem)
</code></pre>

<p>Here are some examples of comparisons.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = x*y^2 + (x + 1)*y + 3
h = S(3)

f == g
isequal(f, g)
f != 3
g != x
h == fmpz(3)
</code></pre>

<h2 id="truncation">Truncation</h2>
<p>```@docs
truncate(::PolyElem, ::Int)</p>
<pre><code>
```@docs
mullow{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T}, ::Int)
</code></pre>

<p>Here are some examples of truncated operations.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = truncate(f, 1)
k = mullow(f, g, 4)
</code></pre>

<h2 id="reversal">Reversal</h2>
<p>```@docs
reverse(::PolyElem, ::Int)</p>
<pre><code>
```@docs
reverse(::PolyElem)
</code></pre>

<p>Here are some examples of reversal.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3

g = reverse(f, 7)
h = reverse(f)
</code></pre>

<h2 id="shifting">Shifting</h2>
<p>```@docs
shift_left(::PolyElem, ::Int)</p>
<pre><code>
```@docs
shift_right(::PolyElem, ::Int)
</code></pre>

<p>Here are some examples of shifting.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3

g = shift_left(f, 7)
h = shift_right(f, 2)
</code></pre>

<h2 id="modulo-arithmetic">Modulo arithmetic</h2>
<p>For polynomials over a field or residue ring, we can reduce modulo a given
polynomial. This isn't always well-defined in the case of a residue ring,
but when it is well-defined, we obtain the correct result. If Nemo encounters
an impossible inverse, an exception will be raised.</p>
<p>```@docs
mulmod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
powmod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::Int, ::PolyElem{T})
</code></pre>

<p>```@docs
powmod(::fmpz_mod_poly, ::fmpz, ::fmpz_mod_poly)</p>
<pre><code>
```@docs
invmod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})
</code></pre>

<p>Here are some examples of modular arithmetic.</p>
<pre><code>R, x = PolynomialRing(QQ, &quot;x&quot;)
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, &quot;y&quot;)

f = (3*x^2 + x + 2)*y + x^2 + 1
g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1
h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1

invmod(f, g)
mulmod(f, g, h)
powmod(f, 3, h)
</code></pre>

<h2 id="euclidean-division">Euclidean division</h2>
<p>For polynomials over a field, we have a euclidean domain, and in many cases for
polynomials over a residue ring things behave as though we had a euclidean
domain so long as we don't hit an impossible inverse. For such rings we define
euclidean division of polynomials. If an impossible inverse is hit, we raise an
exception.</p>
<p>```@docs
mod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
divrem{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})
</code></pre>

<p>Here are some examples of euclidean division.</p>
<pre><code>R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, &quot;x&quot;)
T = ResidueRing(S, x^3 + 3x + 1)
U, y = PolynomialRing(T, &quot;y&quot;)

f = y^3 + x*y^2 + (x + 1)*y + 3
g = (x + 1)*y^2 + (x^3 + 2x + 2)

h = mod(f, g)
q, r = divrem(f, g)
</code></pre>

<h2 id="pseudodivision">Pseudodivision</h2>
<p>Given two polynomials <script type="math/tex">a, b</script>, pseudodivision computes polynomials <script type="math/tex">q</script> and <script type="math/tex">r</script>
with length<script type="math/tex">(r) <</script> length<script type="math/tex">(b)</script> such that
<script type="math/tex; mode=display">L^d a = bq + r,</script>
where <script type="math/tex">d =</script> length<script type="math/tex">(a) -</script> length<script type="math/tex">(b) + 1</script> and <script type="math/tex">L</script> is the leading coefficient
of <script type="math/tex">b</script>.</p>
<p>We call <script type="math/tex">q</script> the pseudoquotient and <script type="math/tex">r</script> the pseudoremainder.</p>
<p>```@docs
pseudorem{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
pseudodivrem{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})
</code></pre>

<p>Here are some examples of pseudodivision.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = pseudorem(f, g)
q, r = pseudodivrem(f, g)
</code></pre>

<h2 id="content-primitive-part-gcd-and-lcm">Content, primitive part, GCD and LCM</h2>
<p>In Nemo, we allow computation of the greatest common divisor of polynomials
over any ring. This is enabled by making use of pseudoremainders when we
aren't working over a euclidean domain or something mimicking such a domain.
In certain cases this allows us to return a greatest common divisor when it
otherwise wouldn't be possible. However, a greatest common divisor is not
necessarily unique, or even well-defined.</p>
<p>If an impossible inverse is encountered whilst computing the greatest common
divisor, an exception is thrown.</p>
<p>```@docs
gcd{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
lcm{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})
</code></pre>

<p>```@docs
content(::PolyElem)</p>
<pre><code>
```@docs
primpart(::PolyElem)
</code></pre>

<p>```@docs
gcdx{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
gcdx{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})
</code></pre>

<p>```@docs
gcdinv{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
Here are some examples of content, primitive part and GCD.

</code></pre>

<p>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")</p>
<p>k = x<em>y^2 + (x + 1)</em>y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = y^2 + x + 1</p>
<p>n = content(k)
p = primpart(k<em>(x^2 + 1))
q = gcd(k</em>m, l<em>m)
r = lcm(k</em>m, l*m)</p>
<p>R, x = PolynomialRing(QQ, "x")
T = ResidueRing(R, x^3 + 3x + 1)
U, z = PolynomialRing(T, "z")</p>
<p>g = z^3 + 2z + 1
h = z^5 + 1</p>
<p>r, s, t = gcdx(g, h)
u, v = gcdinv(g, h)</p>
<pre><code>
## Evaluation, composition and substitution

```@docs
evaluate{T &lt;: RingElem}(::PolyElem{T}, ::T)
</code></pre>

<p>```@docs
evaluate(::PolyElem, ::Integer)</p>
<pre><code>
```@docs
evaluate(::PolyElem, ::fmpz)
</code></pre>

<p>```@docs
compose(::PolyElem, ::PolyElem)</p>
<pre><code>
```@docs
subst{T &lt;: RingElem}(::PolyElem{T}, ::Any)
</code></pre>

<p>We also overload the functional notation so that the polynomial <script type="math/tex">f</script> can be
evaluated at <script type="math/tex">a</script> by writing <script type="math/tex">f(a)</script>. This feature is only available with 
Julia 0.5 however.</p>
<p>Here are some examples of polynomial evaluation, composition and substitution.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
M = R[x + 1 2x; x - 3 2x - 1]

h = evaluate(f, 3)
k = evaluate(f, x^2 + 2x + 1)
m = compose(f, g)
n = subst(f, M)
p = f(M)
k = f(23)
</code></pre>

<h2 id="derivative-and-integral">Derivative and integral</h2>
<p>```@docs
derivative(::PolyElem)</p>
<pre><code>
```@docs
integral{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T})
</code></pre>

<p>Here are some examples of integral and derivative.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)
T, z = PolynomialRing(QQ, &quot;z&quot;)
U = ResidueRing(T, z^3 + 3z + 1)
V, w = PolynomialRing(U, &quot;w&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4

h = derivative(f)
k = integral(g)   
</code></pre>

<h2 id="resultant-and-discriminant">Resultant and discriminant</h2>
<p>```@docs
resultant{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})</p>
<pre><code>
```@docs
discriminant(a::PolyElem)
</code></pre>

<p>Here are some examples of computing the resultant and discriminant.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)

h = resultant(f, g)
k = discriminant(f)
</code></pre>

<h2 id="newton-representation">Newton representation</h2>
<p>```@docs
monomial_to_newton!{T &lt;: RingElem}(::Array{T, 1}, ::Array{T, 1})</p>
<pre><code>
```@docs
newton_to_monomial!{T &lt;: RingElem}(::Array{T, 1}, ::Array{T, 1})
</code></pre>

<p>Here are some examples of conversion to and from Newton representation.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = 3x*y^2 + (x + 1)*y + 3
g = deepcopy(f)
roots = [R(1), R(2), R(3)]

monomial_to_newton!(g.coeffs, roots)
newton_to_monomial!(g.coeffs, roots)
</code></pre>

<h2 id="interpolation">Interpolation</h2>
<p>```@docs
interpolate{T &lt;: RingElem}(::PolyRing, ::Array{T, 1}, ::Array{T, 1})</p>
<pre><code>
Here is an example of interpolation.

</code></pre>

<p>R, x = PolynomialRing(ZZ, "x")
S, y = PolynomialRing(R, "y")</p>
<p>xs = [R(1), R(2), R(3), R(4)]
ys = [R(1), R(4), R(9), R(16)]</p>
<p>f = interpolate(S, xs, ys)</p>
<pre><code>
## Signature

Signature is only available for certain coefficient rings.

```@docs
signature(::fmpz_poly)
</code></pre>

<p>```@docs
signature(::fmpq_poly)</p>
<pre><code>
Here is an example of signature.

</code></pre>

<p>R, x = PolynomialRing(ZZ, "x")</p>
<p>f = x^3 + 3x + 1</p>
<p>(r, s) = signature(f)</p>
<pre><code>
## Lifting

When working over a residue ring it is useful to be able to lift to the base
ring of the residue ring, e.g. from $\mathbb{Z}/n\mathbb{Z}$ to $\mathbb{Z}$.

```@docs
lift(::FmpzPolyRing, ::nmod_poly)
</code></pre>

<p>```@docs
lift(::FmpzPolyRing, ::fmpz_mod_poly)</p>
<pre><code>
Here is an example of lifting.

</code></pre>

<p>R = ResidueRing(ZZ, 123456789012345678949)
S, x = PolynomialRing(R, "x")
T, y = PolynomialRing(ZZ, "y")</p>
<p>f = x^2 + 2x + 1</p>
<p>a = lift(T, f)</p>
<pre><code>
## Factorisation

Polynomials can only be factorised over certain rings. In general we use the
same format for the output as the Julia factorisation function, namely an
associative array with polynomial factors as keys and exponents as values.

```@docs
isirreducible(::nmod_poly)
</code></pre>

<p>```@docs
isirreducible(::fmpz_mod_poly)</p>
<pre><code>
```@docs
issquarefree(::nmod_poly)
</code></pre>

<p>```@docs
issquarefree(::fmpz_mod_poly)</p>
<pre><code>
```@docs
factor(::nmod_poly)
</code></pre>

<p>```@docs
factor(::fmpz_mod_poly)</p>
<pre><code>
```@docs
factor_squarefree(::nmod_poly)
</code></pre>

<p>```@docs
factor_squarefree(::fmpz_mod_poly)</p>
<pre><code>
```@docs
factor_distinct_deg(::nmod_poly)
</code></pre>

<p>```@docs
factor_distinct_deg(::fmpz_mod_poly)</p>
<pre><code>
Here are some examples of factorisation.

</code></pre>

<p>R = ResidueRing(ZZ, 23)
S, x = PolynomialRing(R, "x")</p>
<p>f = x^2 + 2x + 1
g = x^3 + 3x + 1</p>
<p>R = factor(f<em>g)
S = factor_squarefree(f</em>g)
T = factor_distinct_deg((x + 1)<em>g</em>(x^5+x^3+x+1))</p>
<pre><code>
## Special functions

The following special functions can be computed for any polynomial ring.
Typically one uses the generator $x$ of a polynomial ring to get the respective
special polynomials expressed in terms of that generator.

```@docs
chebyshev_t(::Int, ::PolyElem)
</code></pre>

<p>```@docs
chebyshev_u(::Int, ::PolyElem)</p>
<pre><code>
The following special polynomials are only available for certain base rings.

```@docs
cyclotomic(::Int, ::fmpz_poly)
</code></pre>

<p>```@docs
swinnerton_dyer(::Int, ::fmpz_poly)</p>
<pre><code>
```@docs
cos_minpoly(::Int, ::fmpz_poly)
</code></pre>

<p>```@docs
theta_qexp(::Int, ::Int, ::fmpz_poly)</p>
<pre><code>
```@docs
eta_qexp(::Int, ::Int, ::fmpz_poly)
</code></pre>

<p>Here are some examples of special functions.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = chebyshev_t(20, y)
g = chebyshev_u(15, y)
h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
o = cyclotomic(10, 1 + x + x^2)
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../../constructors/" class="btn btn-neutral" title="Parent object constructors"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Nemocas/Nemo.jl" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../../constructors/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>

</body>
</html>

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="William Hart">
  
  <title>Univariate polynomials - Nemo.jl</title>
  

  <link rel="shortcut icon" href="../../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../build/assets/Documenter.css" rel="stylesheet">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Univariate polynomials";
    var mkdocs_page_input_path = "src/polynomial.md";
    var mkdocs_page_url = "/src/polynomial/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 
  <script src="../../mathjaxhelper.js"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Nemo.jl</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Getting Started</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../about/">About Nemo</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../types/">Types in Nemo</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../constructors/">Parent object constructors</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Univariate polynomials</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#univariate-polynomials">Univariate polynomials</a></li>
                
                    <li><a class="toctree-l4" href="#polynomial-types">Polynomial types</a></li>
                
                    <li><a class="toctree-l4" href="#basic-functionality">Basic functionality</a></li>
                
                    <li><a class="toctree-l4" href="#polynomial-ring-constructors">Polynomial ring constructors</a></li>
                
                    <li><a class="toctree-l4" href="#polynomial-element-constructors">Polynomial element constructors</a></li>
                
                    <li><a class="toctree-l4" href="#basic-manipulation">Basic manipulation</a></li>
                
                    <li><a class="toctree-l4" href="#arithmetic-operators">Arithmetic operators</a></li>
                
                    <li><a class="toctree-l4" href="#comparison-operators">Comparison operators</a></li>
                
                    <li><a class="toctree-l4" href="#truncation">Truncation</a></li>
                
                    <li><a class="toctree-l4" href="#reversal">Reversal</a></li>
                
                    <li><a class="toctree-l4" href="#shifting">Shifting</a></li>
                
                    <li><a class="toctree-l4" href="#modulo-arithmetic">Modulo arithmetic</a></li>
                
                    <li><a class="toctree-l4" href="#euclidean-division">Euclidean division</a></li>
                
                    <li><a class="toctree-l4" href="#pseudodivision">Pseudodivision</a></li>
                
                    <li><a class="toctree-l4" href="#content-primitive-part-gcd-and-lcm">Content, primitive part, GCD and LCM</a></li>
                
                    <li><a class="toctree-l4" href="#evaluation-composition-and-substitution">Evaluation, composition and substitution</a></li>
                
                    <li><a class="toctree-l4" href="#derivative-and-integral">Derivative and integral</a></li>
                
                    <li><a class="toctree-l4" href="#resultant-and-discriminant">Resultant and discriminant</a></li>
                
                    <li><a class="toctree-l4" href="#newton-representation">Newton representation</a></li>
                
                    <li><a class="toctree-l4" href="#interpolation">Interpolation</a></li>
                
                    <li><a class="toctree-l4" href="#signature">Signature</a></li>
                
                    <li><a class="toctree-l4" href="#lifting">Lifting</a></li>
                
                    <li><a class="toctree-l4" href="#factorisation">Factorisation</a></li>
                
                    <li><a class="toctree-l4" href="#special-functions">Special functions</a></li>
                
            
            </ul>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Nemo.jl</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Univariate polynomials</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/Nemocas/Nemo.jl" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="univariate-polynomials">Univariate polynomials</h1>
<p>Nemo allow the creation of dense, univariate polynomials over any ring <script type="math/tex">R</script>.</p>
<h2 id="polynomial-types">Polynomial types</h2>
<p>Although the user rarely needs to deal directly with Julia types for Nemo
objects, we provide the relevant information here for developers.</p>
<p>Generic univariate polynomials in Nemo have type <code>GenPoly{T}</code>, where <code>T</code> is the
type of the coefficients of the polynomial.</p>
<p>The string representation of the variable and the base ring <script type="math/tex">R</script> of a generic
polynomial is stored in its parent object. Parent objects of generic univariate
polynomials have type <code>GenPolyRing{T}</code>.</p>
<p>In addition to generic polynomials, Nemo provides access to numerous polynomial
implementations over specific rings, provided by C/C++ libraries. The following
table shows each of the polynomial types available in Nemo, their base ring <script type="math/tex">R</script>,
the type of their parent objects and the library providing those types.</p>
<table>
<thead>
<tr>
<th>Base ring</th>
<th>Library</th>
<th>Element type</th>
<th>Parent type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Generic ring <script type="math/tex">R</script>
</td>
<td>Nemo</td>
<td><code>GenPoly{T}</code></td>
<td><code>GenPolyRing{T}</code></td>
</tr>
<tr>
<td>
<script type="math/tex">\mathbb{Z}</script>
</td>
<td>Flint</td>
<td><code>fmpz_poly</code></td>
<td><code>FmpzPolyRing</code></td>
</tr>
<tr>
<td>
<script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> (small <script type="math/tex">n</script>)</td>
<td>Flint</td>
<td><code>nmod_poly</code></td>
<td><code>NmodPolyRing</code></td>
</tr>
<tr>
<td>
<script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> (large <script type="math/tex">n</script>)</td>
<td>Flint</td>
<td><code>fmpz_mod_poly</code></td>
<td><code>FmpzModPolyRing</code></td>
</tr>
<tr>
<td>
<script type="math/tex">\mathbb{Q}</script>
</td>
<td>Flint</td>
<td><code>fmpq_poly</code></td>
<td><code>FmpqPolyRing</code></td>
</tr>
<tr>
<td>
<script type="math/tex">\mathbb{F}_{p^n}</script> (small <script type="math/tex">n</script>)</td>
<td>Flint</td>
<td><code>fq_nmod_poly</code></td>
<td><code>FqNmodPolyRing</code></td>
</tr>
<tr>
<td>
<script type="math/tex">\mathbb{F}_{p^n}</script> (large <script type="math/tex">n</script>)</td>
<td>Flint</td>
<td><code>fq_poly</code></td>
<td><code>FqPolyRing</code></td>
</tr>
</tbody>
</table>
<p>All polynomial element types belong to the abstract type <code>PolyElem</code> and all of
the polynomial ring types belong to the abstract type <code>PolyRing</code>. This enables
one to write generic functions that can accept any Nemo polynomial type.</p>
<h2 id="basic-functionality">Basic functionality</h2>
<p>All univariate polynomial modules in Nemo must provide the functionality listed
below. Note that only some of these functions are useful to a user.</p>
<p>Developers who are writing their own polynomial module, whether as an interface
to a C library, or as some kind of generic module, must provide all of these
functions for custom univariate polynomial types in Nemo. </p>
<p>We write <code>T</code> for the type of the polynomials in the polynomial ring.</p>
<p>All of these functions are provided for all existing polynomial types in Nemo.</p>
<pre><code>parent_type{T &lt;: PolyElem}(::Type{T})
</code></pre>

<p>Given the type of polynomial elements, should return the type of the
corresponding parent object.</p>
<pre><code>elem_type(R::PolyRing)
</code></pre>

<p>Given a parent object for the polynomial ring, return the type of elements
of the polynomial ring.</p>
<pre><code>Base.hash(a::PolyElem, h::UInt)
</code></pre>

<p>Return a <code>UInt</code> hexadecimal hash of the polynomial <script type="math/tex">a</script>. This should be xor'd
with a fixed random hexadecimal specific to the polynomial type. The hash of
each coefficient should be xor'd with the supplied parameter <code>h</code> as part of
computing the hash.</p>
<pre><code>fit!(a::PolyElem, n::Int)
</code></pre>

<p>By reallocating if necessary, ensure that the given polynomial has space for at
least <script type="math/tex">n</script> coefficients. This function does not change the length of the
polynomial and will only ever increase the number of allocated coefficients.
Any coefficients added by this function are initialised to zero.</p>
<pre><code>normalise(a::PolyElem, n::Int)
</code></pre>

<p>Return the normalised length of the given polynomial, assuming its current
length is <script type="math/tex">n</script>. Its normalised length is such that it either has nonzero
leading term or is the zero polynomial. Note that this function doesn't
normalise the polynomial. That can be done with a subsequent call to
<code>set_length!</code> using the length returned by <code>normalise</code>.</p>
<pre><code>set_length!(a::PolyElem, n::Int)
</code></pre>

<p>Set the length of an existing polynomial that has sufficient space allocated,
i.e. a polynomial for which no reallocation is needed. Note that if the Julia
type definition for a custom polynomial type has a field, <code>length</code>, which
corresponds to the current length of the polynomial, then the developer doesn't
need to supply this function, as the supplied generic implementation will work.
Note that it can change the length to any value from zero to the number of
coefficients currently allocated and initialised.</p>
<pre><code>length(a::PolyElem)
</code></pre>

<p>Return the current length (not the number of allocated coefficients), of the
given polynomial. Note that this function only needs to be provided by a
developer for a custome polynomial type if the Julia type definition for
polynomial elements doesn't contain a field <code>length</code> corresponding to the
current length of the polynomial. Otherwise the supplied generic implementation
will work.</p>
<pre><code>coeff(a::PolyElem, n::Int)
</code></pre>

<p>Return the degree <code>n</code> coefficient of the given polynomial. Note coefficients
are numbered from <code>n = 0</code> for the constant coefficient. If <script type="math/tex">n</script> is bigger
then the degree of the polynomial, the function returns a zero coefficient.
We require <script type="math/tex">n \geq 0</script>. </p>
<pre><code>setcoeff!{T &lt;: RingElem}(a::PolyElem{T}, n::Int, c::T)
</code></pre>

<p>Set the coefficient of the degree <script type="math/tex">n</script> term of the given polynomial to the given
value <code>a</code>. The polynomial is not normalised automatically after this operation,
however the polynomial is automatically resized if there is not sufficient
allocated space.</p>
<pre><code>deepcopy(a::PolyElem)
</code></pre>

<p>Construct a copy of the given polynomial and return it. This function must
recursively construct copies of all of the internal data in the given
polynomial. Nemo polynomials are mutable and so returning shallow copies is not
sufficient.</p>
<pre><code>mul!(c::PolyElem, a::PolyElem, b::PolyElem)
</code></pre>

<p>Multiply <script type="math/tex">a</script> by <script type="math/tex">b</script> and set the existing polynomial <script type="math/tex">c</script> to the result. This
function is provided for performance reasons as it saves allocating a new
object for the result and eliminates associated garbage collection.</p>
<pre><code>addeq!(c::PolyElem, a::PolyElem)
</code></pre>

<p>In-place addition. Adds <script type="math/tex">a</script> to <script type="math/tex">c</script> and sets <script type="math/tex">c</script> to the result. This function
is provided for performance reasons as it saves allocating a new object for
the result and eliminates associated garbage collection.</p>
<p>Given a parent object <code>S</code> for a polynomial ring, the following coercion
functions are provided to coerce various elements into the polynomial
ring. Developers provide these by overloading the <code>call</code> operator for the
polynomial parent objects.</p>
<pre><code>S()
</code></pre>

<p>Coerce zero into the ring <script type="math/tex">S</script>.</p>
<pre><code>S(n::Integer)
S(n::fmpz)
</code></pre>

<p>Coerce an integer value or Flint integer into the polynomial ring <script type="math/tex">S</script>.</p>
<pre><code>S(n::T)
</code></pre>

<p>Coerces an element of the base ring, of type <code>T</code> into <script type="math/tex">S</script>.</p>
<pre><code>S(A::Array{T, 1})
</code></pre>

<p>Take an array of elements in the base ring, of type <code>T</code> and construct the
polynomial with those coefficients, starting with the constant coefficient.</p>
<pre><code>S(f::PolyElem)
</code></pre>

<p>Take a polynomial that is already in the ring <script type="math/tex">S</script> and simply return it. A copy
of the original is not made.</p>
<pre><code>S(c::RingElem)
</code></pre>

<p>Try to coerce the given ring element into the polynomial ring. This only
succeeds if <script type="math/tex">c</script> can be coerced into the base ring.</p>
<p>In addition to the above, developers of custom polynomials must ensure the
parent object of a polynomial type constains a field <code>base_ring</code> specifying the
base ring, a field <code>S</code> containing a symbol (not a string) representing the
variable name of the polynomial ring. They must also ensure that each
polynomial element contains a field <code>parent</code> specifying the parent object of
the polynomial.</p>
<p>Typically a developer will also overload the <code>PolynomialRing</code> generic function
to create polynomials of the custom type they are implementing.</p>
<h2 id="polynomial-ring-constructors">Polynomial ring constructors</h2>
<p>In order to construct polynomials, one must first construct the polynomial ring
itself. This is accomplished with the following constructor.</p>
<p>@{PolynomialRing(::Ring, ::AbstractString{}, ::Bool)}</p>
<p>A shorthand version of this function is provided. Given a base ring <code>R</code>, we can
abbreviate the above constructor as follows.</p>
<pre><code>R[&quot;x&quot;]
</code></pre>

<p>Here are some examples of creating polynomial rings and making use of the
resulting parent objects to coerce various elements into the polynomial ring.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)
T, z = QQ[&quot;z&quot;]

f = R()
g = R(123)
h = S(ZZ(1234))
k = S(x + 1)
m = T(z + 1)
</code></pre>

<h2 id="polynomial-element-constructors">Polynomial element constructors</h2>
<p>Once a polynomial ring is constructed, there are various ways to construct
polynomials in that ring.</p>
<p>The easiest way is simply using the generator returned by the <code>PolynomialRing</code>
constructor and and build up the polynomial using basic arithmetic. Julia has
quite flexible notation for the construction of polynomials in this way.</p>
<p>In addition we provide the following functions for constructing certain useful
polynomials.</p>
<p>@{zero(::PolyRing)}</p>
<p>@{one(::PolyRing)}</p>
<p>@{gen(::PolyRing)}</p>
<p>Here are some examples of constructing polynomials.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x^3 + 3x + 21
g = (x + 1)*y^2 + 2x + 1

h = zero(S)
k = one(R)
m = gen(S)
</code></pre>

<h2 id="basic-manipulation">Basic manipulation</h2>
<p>Numerous functions are provided to manipulate polynomials and to set and
retrieve coefficients and other basic data associated with the polynomials.
Also see the section on basic functionality above.</p>
<p>@{base_ring(::PolyRing)}</p>
<p>@{base_ring(::PolyElem)}</p>
<p>@{parent(::PolyElem)}</p>
<p>@{var(::PolyRing)}</p>
<p>@{degree(::PolyElem)}</p>
<p>@{modulus{T &lt;: ResElem}(a::PolyElem{T})}</p>
<p>@{lead(::PolyElem)}</p>
<p>@{iszero(::PolyElem)}</p>
<p>@{isone(::PolyElem)}</p>
<p>@{isgen(::PolyElem)}</p>
<p>@{isunit(::PolyElem)}</p>
<p>@den(a::fmpq_poly)</p>
<p>Here are some examples of basic manipulation of polynomials.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)
T, z = PolynomialRing(QQ, &quot;z&quot;)

a = zero(S)
b = one(S)

c = ZZ(1)//2*z^2 + ZZ(1)//3
d = x*y^2 + (x + 1)*y + 3

U = base_ring(S)
V = base_ring(y + 1)
v = var(S)
T = parent(y + 1)

f = lead(d)

g = isgen(y)
h = isone(b)
k = iszero(a)
m = isunit(b)
n = degree(d)
p = length(b)
q = den(c)
</code></pre>

<h2 id="arithmetic-operators">Arithmetic operators</h2>
<p>All the usual arithmetic operators are overloaded for Nemo polynomials. Note
that Julia uses the single slash for floating point division. Therefore to
perform exact division in a ring we use <code>divexact</code>. To construct an element
of a fraction field one can use the double slash operator <code>//</code>.</p>
<p>@{-(::PolyElem)}</p>
<p>@{+{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{-{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{*{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{divexact(::PolyElem, ::PolyElem)}</p>
<p>The following ad hoc operators are also provided.</p>
<p>@{+(::Integer, ::PolyElem)}</p>
<p>@{+(::PolyElem, ::Integer)} </p>
<p>@{+(::fmpz, ::PolyElem)}</p>
<p>@{+(::PolyElem, ::fmpz)}</p>
<p>@{+{T &lt;: RingElem}(::T, ::PolyElem{T})}</p>
<p>@{+{T &lt;: RingElem}(::PolyElem, ::T)} </p>
<p>@{-(::Integer, ::PolyElem)}</p>
<p>@{-(::PolyElem, ::Integer)} </p>
<p>@{-(::fmpz, ::PolyElem)}</p>
<p>@{-(::PolyElem, ::fmpz)}</p>
<p>@{-{T &lt;: RingElem}(::T, ::PolyElem{T})}</p>
<p>@{-{T &lt;: RingElem}(::PolyElem, ::T)} </p>
<p>@{*(::Integer, ::PolyElem)}</p>
<p>@{*(::PolyElem, ::Integer)} </p>
<p>@{*(::fmpz, ::PolyElem)}</p>
<p>@{*(::PolyElem, ::fmpz)}</p>
<p>@{*{T &lt;: RingElem}(::T, ::PolyElem{T})}</p>
<p>@{*{T &lt;: RingElem}(::PolyElem, ::T)} </p>
<p>@{divexact(::PolyElem, ::Integer)} </p>
<p>@{divexact(::PolyElem, ::fmpz)}</p>
<p>@{divexact{T &lt;: RingElem}(::PolyElem{T}, ::T)} </p>
<p>@{^(::PolyElem, ::Int)}</p>
<p>If the appropriate <code>promote_rule</code> and coercion exists, these operators can also
be used with elements of other rings. Nemo will try to coerce the operands to
the dominating type and then apply the operator.</p>
<p>Here are some examples of arithmetic operations on polynomials.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = f - g
k = f*g
m = f + g
n = g - 4
p = fmpz(5) - g
q = f*7
r = divexact(f, -1)
s = divexact(g*(x + 1), x + 1)
t = f^3
</code></pre>

<h2 id="comparison-operators">Comparison operators</h2>
<p>The following comparison operators are implemented for polynomials in Nemo.</p>
<p>@{=={T &lt;: RingElem}(x::PolyElem{T}, y::PolyElem{T})}</p>
<p>@{isequal{T &lt;: RingElem}(x::PolyElem{T}, y::PolyElem{T})}</p>
<p>In addition we have the following ad hoc comparison operators.</p>
<p>@{=={T &lt;: RingElem}(::PolyElem{T}, ::T)}</p>
<p>@{=={T &lt;: RingElem}(::T, ::PolyElem{T})}</p>
<p>@{==(::PolyElem, ::Integer)}</p>
<p>@{==(::Integer, ::PolyElem)}</p>
<p>@{==(::PolyElem, ::fmpz)}</p>
<p>@{==(::fmpz, ::PolyElem)}</p>
<p>Here are some examples of comparisons.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = x*y^2 + (x + 1)*y + 3
h = S(3)

f == g
isequal(f, g)
f != 3
g != x
h == fmpz(3)
</code></pre>

<h2 id="truncation">Truncation</h2>
<p>@{truncate(::PolyElem, ::Int)}</p>
<p>@{mullow{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T}, ::Int)}</p>
<p>Here are some examples of truncated operations.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = truncate(f, 1)
k = mullow(f, g, 4)
</code></pre>

<h2 id="reversal">Reversal</h2>
<p>@{reverse(::PolyElem, ::Int)}</p>
<p>@{reverse(::PolyElem)}</p>
<p>Here are some examples of reversal.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3

g = reverse(f, 7)
h = reverse(f)
</code></pre>

<h2 id="shifting">Shifting</h2>
<p>@{shift_left(x::PolyElem, n::Int)}</p>
<p>@{shift_right(f::PolyElem, n::Int)}</p>
<p>Here are some examples of shifting.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3

g = shift_left(f, 7)
h = shift_right(f, 2)
</code></pre>

<h2 id="modulo-arithmetic">Modulo arithmetic</h2>
<p>For polynomials over a field or residue ring, we can reduce modulo a given
polynomial. This isn't always well-defined in the case of a residue ring,
but when it is well-defined, we obtain the correct result. If Nemo encounters
an impossible inverse, an exception will be raised.</p>
<p>@{mulmod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{powmod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::Int, ::PolyElem{T})}</p>
<p>@{powmod(x::fmpz_mod_poly, e::fmpz, y::fmpz_mod_poly)}</p>
<p>@{invmod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>Here are some examples of modular arithmetic.</p>
<pre><code>R, x = PolynomialRing(QQ, &quot;x&quot;)
S = ResidueRing(R, x^3 + 3x + 1)
T, y = PolynomialRing(S, &quot;y&quot;)

f = (3*x^2 + x + 2)*y + x^2 + 1
g = (5*x^2 + 2*x + 1)*y^2 + 2x*y + x + 1
h = (3*x^3 + 2*x^2 + x + 7)*y^5 + 2x*y + 1

invmod(f, g)
mulmod(f, g, h)
powmod(f, 3, h)
</code></pre>

<h2 id="euclidean-division">Euclidean division</h2>
<p>For polynomials over a field, we have a euclidean domain, and in many cases for
polynomials over a residue ring things behave as though we had a euclidean
domain so long as we don't hit an impossible inverse. For such rings we define
euclidean division of polynomials. If an impossible inverse is hit, we raise an
exception.</p>
<p>@{mod{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{divrem{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>Here are some examples of euclidean division.</p>
<pre><code>R = ResidueRing(ZZ, 7)
S, x = PolynomialRing(R, &quot;x&quot;)
T = ResidueRing(S, x^3 + 3x + 1)
U, y = PolynomialRing(T, &quot;y&quot;)

f = y^3 + x*y^2 + (x + 1)*y + 3
g = (x + 1)*y^2 + (x^3 + 2x + 2)

h = mod(f, g)
q, r = divrem(f, g)
</code></pre>

<h2 id="pseudodivision">Pseudodivision</h2>
<p>Given two polynomials <script type="math/tex">a, b</script>, pseudodivision computes polynomials <script type="math/tex">q</script> and <script type="math/tex">r</script>
with length<script type="math/tex">(r) <</script> length<script type="math/tex">(b)</script> such that
<script type="math/tex; mode=display">L^d a = bq + r,</script>
where <script type="math/tex">d =</script> length<script type="math/tex">(a) -</script> length<script type="math/tex">(b) + 1</script> and <script type="math/tex">L</script> is the leading coefficient
of <script type="math/tex">b</script>.</p>
<p>We call <script type="math/tex">q</script> the pseudoquotient and <script type="math/tex">r</script> the pseudoremainder.</p>
<p>@{pseudorem{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{pseudodivrem{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>Here are some examples of pseudodivision.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)

h = pseudorem(f, g)
q, r = pseudodivrem(f, g)
</code></pre>

<h2 id="content-primitive-part-gcd-and-lcm">Content, primitive part, GCD and LCM</h2>
<p>In Nemo, we allow computation of the greatest common divisor of polynomials
over any ring. This is enabled by making use of pseudoremainders when we
aren't working over a euclidean domain or something mimicking such a domain.
In certain cases this allows us to return a greatest common divisor when it
otherwise wouldn't be possible. However, a greatest common divisor is not
necessarily unique, or even well-defined.</p>
<p>If an impossible inverse is encountered whilst computing the greatest common
divisor, an exception is thrown.</p>
<p>@{gcd{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{lcm{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{content(::PolyElem)}</p>
<p>@{primpart(::PolyElem)}</p>
<p>@{gcdx{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{gcdx{T &lt;: Union{ResElem, FieldElem}}(a::PolyElem{T}, b::PolyElem{T})}</p>
<p>@{gcdinv{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>Here are some examples of content, primitive part and GCD.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

k = x*y^2 + (x + 1)*y + 3
l = (x + 1)*y + (x^3 + 2x + 2)
m = y^2 + x + 1

n = content(k)
p = primpart(k*(x^2 + 1))
q = gcd(k*m, l*m)
r = lcm(k*m, l*m)

R, x = PolynomialRing(QQ, &quot;x&quot;)
T = ResidueRing(R, x^3 + 3x + 1)
U, z = PolynomialRing(T, &quot;z&quot;)

g = z^3 + 2z + 1
h = z^5 + 1

r, s, t = gcdx(g, h)
u, v = gcdinv(g, h)
</code></pre>

<h2 id="evaluation-composition-and-substitution">Evaluation, composition and substitution</h2>
<p>@{evaluate{T &lt;: RingElem}(::PolyElem{T}, ::T)}</p>
<p>@{evaluate(::PolyElem, ::Integer)}</p>
<p>@{evaluate(::PolyElem, ::fmpz)}</p>
<p>@{compose(::PolyElem, ::PolyElem)}</p>
<p>@{subst{T &lt;: RingElem}(::PolyElem{T}, ::Any)}</p>
<p>We also overload the functional notation so that the polynomial <script type="math/tex">f</script> can be
evaluated at <script type="math/tex">a</script> by writing <script type="math/tex">f(a)</script>. This feature is only available with 
Julia 0.5 however.</p>
<p>Here are some examples of polynomial evaluation, composition and substitution.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (x + 1)*y + (x^3 + 2x + 2)
M = R[x + 1 2x; x - 3 2x - 1]

h = evaluate(f, 3)
k = evaluate(f, x^2 + 2x + 1)
m = compose(f, g)
n = subst(f, M)
p = f(M)
k = f(23)
</code></pre>

<h2 id="derivative-and-integral">Derivative and integral</h2>
<p>@{derivative(::PolyElem)}</p>
<p>@{integral{T &lt;: Union{ResElem, FieldElem}}(::PolyElem{T})}</p>
<p>Here are some examples of integral and derivative.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)
T, z = PolynomialRing(QQ, &quot;z&quot;)
U = ResidueRing(T, z^3 + 3z + 1)
V, w = PolynomialRing(U, &quot;w&quot;)

f = x*y^2 + (x + 1)*y + 3
g = (z^2 + 2z + 1)*w^2 + (z + 1)*w - 2z + 4

h = derivative(f)
k = integral(g)   
</code></pre>

<h2 id="resultant-and-discriminant">Resultant and discriminant</h2>
<p>@{resultant{T &lt;: RingElem}(::PolyElem{T}, ::PolyElem{T})}</p>
<p>@{discriminant(a::PolyElem)}</p>
<p>Here are some examples of computing the resultant and discriminant.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = 3x*y^2 + (x + 1)*y + 3
g = 6(x + 1)*y + (x^3 + 2x + 2)

h = resultant(f, g)
k = discriminant(f)
</code></pre>

<h2 id="newton-representation">Newton representation</h2>
<p>@{monomial_to_newton!{T &lt;: RingElem}(::Array{T, 1}, ::Array{T, 1})}</p>
<p>@{newton_to_monomial!{T &lt;: RingElem}(::Array{T, 1}, ::Array{T, 1})}</p>
<p>Here are some examples of conversion to and from Newton representation.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = 3x*y^2 + (x + 1)*y + 3
g = deepcopy(f)
roots = [R(1), R(2), R(3)]

monomial_to_newton!(g.coeffs, roots)
newton_to_monomial!(g.coeffs, roots)
</code></pre>

<h2 id="interpolation">Interpolation</h2>
<p>@{interpolate{T &lt;: RingElem}(::PolyRing, ::Array{T, 1}, ::Array{T, 1})}</p>
<p>Here is an example of interpolation.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

xs = [R(1), R(2), R(3), R(4)]
ys = [R(1), R(4), R(9), R(16)]

f = interpolate(S, xs, ys)
</code></pre>

<h2 id="signature">Signature</h2>
<p>Signature is only available for certain coefficient rings.</p>
<p>@{signature(::fmpz_poly)}</p>
<p>@{signature(::fmpq_poly)}</p>
<p>Here is an example of signature.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)

f = x^3 + 3x + 1

(r, s) = signature(f)
</code></pre>

<h2 id="lifting">Lifting</h2>
<p>When working over a residue ring it is useful to be able to lift to the base
ring of the residue ring, e.g. from <script type="math/tex">\mathbb{Z}/n\mathbb{Z}</script> to <script type="math/tex">\mathbb{Z}</script>.</p>
<p>@{function lift(R::FmpzPolyRing, y::nmod_poly)}</p>
<p>@{function lift(R::FmpzPolyRing, y::fmpz_mod_poly)}</p>
<p>Here is an example of lifting.</p>
<pre><code>R = ResidueRing(ZZ, 123456789012345678949)
S, x = PolynomialRing(R, &quot;x&quot;)
T, y = PolynomialRing(ZZ, &quot;y&quot;)

f = x^2 + 2x + 1

a = lift(T, f)
</code></pre>

<h2 id="factorisation">Factorisation</h2>
<p>Polynomials can only be factorised over certain rings. In general we use the
same format for the output as the Julia factorisation function, namely an
associative array with polynomial factors as keys and exponents as values.</p>
<p>@{isirreducible(x::nmod_poly)}</p>
<p>@{isirreducible(x::fmpz_mod_poly)}</p>
<p>@{issquarefree(x::nmod_poly)}</p>
<p>@{issquarefree(x::fmpz_mod_poly)}</p>
<p>@{factor(x::nmod_poly)}</p>
<p>@{factor(x::fmpz_mod_poly)}</p>
<p>@{factor_squarefree(x::nmod_poly)}</p>
<p>@{factor_squarefree(x::fmpz_mod_poly)}</p>
<p>@{factor_distinct_deg(x::nmod_poly)}</p>
<p>@{factor_distinct_deg(x::fmpz_mod_poly)}</p>
<p>Here are some examples of factorisation.</p>
<pre><code>R = ResidueRing(ZZ, 23)
S, x = PolynomialRing(R, &quot;x&quot;)

f = x^2 + 2x + 1
g = x^3 + 3x + 1

R = factor(f*g)
S = factor_squarefree(f*g)
T = factor_distinct_deg((x + 1)*g*(x^5+x^3+x+1))
</code></pre>

<h2 id="special-functions">Special functions</h2>
<p>The following special functions can be computed for any polynomial ring.
Typically one uses the generator <script type="math/tex">x</script> of a polynomial ring to get the respective
special polynomials expressed in terms of that generator.</p>
<p>@{chebyshev_t(n::Int, x::PolyElem)}</p>
<p>@{chebyshev_u(::Int, ::PolyElem)}</p>
<p>The following special polynomials are only available for certain base rings.</p>
<p>@{cyclotomic(::Int, ::fmpz_poly)}</p>
<p>@{swinnerton_dyer(::Int, ::fmpz_poly)}</p>
<p>@{cos_minpoly(::Int, ::fmpz_poly)}</p>
<p>@{theta_qexp(::Int, ::Int, ::fmpz_poly)}</p>
<p>@{eta_qexp(::Int, ::Int, ::fmpz_poly)}</p>
<p>Here are some examples of special functions.</p>
<pre><code>R, x = PolynomialRing(ZZ, &quot;x&quot;)
S, y = PolynomialRing(R, &quot;y&quot;)

f = chebyshev_t(20, y)
g = chebyshev_u(15, y)
h = cyclotomic(120, x)
j = swinnerton_dyer(5, x)
k = cos_minpoly(30, x)
l = theta_qexp(3, 30, x)
m = eta_qexp(24, 30, x)
o = cyclotomic(10, 1 + x + x^2)
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../../constructors/" class="btn btn-neutral" title="Parent object constructors"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Nemocas/Nemo.jl" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../../constructors/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>

</body>
</html>
